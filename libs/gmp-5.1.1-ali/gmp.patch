diff -Nur openssl-1.0.1e/config sp-120/libs/openssl-1.0.1e/config
--- openssl-1.0.1e/config	2013-04-24 22:21:56.533799412 +0800
+++ sp-120/libs/openssl-1.0.1e/config	2013-04-24 22:11:07.007800026 +0800
@@ -660,7 +660,8 @@
 	#fi
 	OUT="linux64-s390x"
 	;;
-  x86_64-*-linux?) OUT="linux-x86_64" ;;
+  x86_64-*-linux?) OUT="linux-x86_64"
+	options="$options -DOPENSSL_NO_HW -DOPENSSL_NO_RSAX" ;;
   *86-*-linux2) OUT="linux-elf"
 	if [ "$GCCVER" -gt 28 ]; then
           if grep '^model.*Pentium' /proc/cpuinfo >/dev/null ; then
diff -Nur openssl-1.0.1e/Makefile.org sp-120/libs/openssl-1.0.1e/Makefile.org
--- openssl-1.0.1e/Makefile.org	2013-04-24 22:21:56.534799412 +0800
+++ sp-120/libs/openssl-1.0.1e/Makefile.org	2013-04-24 22:11:07.007800026 +0800
@@ -253,7 +253,7 @@
 # RECURSIVE_BUILD_CMD is a macro to build a given target in all
 # subdirectories defined in $(DIRS).  It requires that the target
 # is given through the shell variable `target'.
-BUILD_CMD=  if [ -d "$$dir" ]; then \
+BUILD_CMD=  if [ -d "$$dir" -a "$$dir" != "gmp" ]; then \
 	    (	cd $$dir && echo "making $$target in $$dir..." && \
 		$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. DIR=$$dir $$target \
 	    ) || exit 1; \
@@ -263,6 +263,17 @@
 	if expr " $(DIRS) " : ".* $$dir " >/dev/null 2>&1; then \
 		$(BUILD_CMD); \
 	fi
+BUILD_GMP_CMD=\
+	cd $$dir && echo "making all in gmp..." && \
+	if [ ! -f .libs/libgmp.a ]; then \
+	( ./configure && $(MAKE) -j 16 ) || exit 1; \
+	fi && \
+	cd ..
+PACK_CRYPTO_CMD=\
+	mkdir tmp && cd tmp && \
+	ar x ../libcrypto.a && ar x ../gmp/.libs/libgmp.a && \
+	ar -rcs libcrypto.a *.o && mv libcrypto.a ../ && \
+	cd .. && rm -fr tmp
 
 reflect:
 	@[ -n "$(THIS)" ] && $(CLEARENV) && $(MAKE) $(THIS) -e $(BUILDENV)
@@ -270,10 +281,12 @@
 sub_all: build_all
 build_all: build_libs build_apps build_tests build_tools
 
-build_libs: build_crypto build_ssl build_engines
+build_libs: build_gmp build_crypto build_ssl build_engines
 
+build_gmp:
+	@dir=gmp; $(BUILD_GMP_CMD)
 build_crypto:
-	@dir=crypto; target=all; $(BUILD_ONE_CMD)
+	@dir=crypto; target=all; $(BUILD_ONE_CMD); $(PACK_CRYPTO_CMD)
 build_ssl:
 	@dir=ssl; target=all; $(BUILD_ONE_CMD)
 build_engines:
@@ -553,6 +566,7 @@
 	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
 	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
 	done;
+	@cp $(TOP)/include/openssl/gmp.h $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/
 	@set -e; target=install; $(RECURSIVE_BUILD_CMD)
 	@set -e; liblist="$(LIBS)"; for i in $$liblist ;\
 	do \
diff -Nur openssl-1.0.1e/apps/genrsa.c sp-120/libs/openssl-1.0.1e/apps/genrsa.c
--- openssl-1.0.1e/apps/genrsa.c	2013-04-24 22:21:56.522799412 +0800
+++ sp-120/libs/openssl-1.0.1e/apps/genrsa.c	2013-04-24 22:11:07.008800024 +0800
@@ -71,7 +71,6 @@
 #include "apps.h"
 #include <openssl/bio.h>
 #include <openssl/err.h>
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/evp.h>
 #include <openssl/x509.h>
@@ -82,19 +81,15 @@
 #undef PROG
 #define PROG genrsa_main
 
-static int MS_CALLBACK genrsa_cb(int p, int n, BN_GENCB *cb);
-
 int MAIN(int, char **);
 
 int MAIN(int argc, char **argv)
 	{
-	BN_GENCB cb;
 #ifndef OPENSSL_NO_ENGINE
 	ENGINE *e = NULL;
 #endif
 	int ret=1;
-	int i,num=DEFBITS;
-	long l;
+	int num=DEFBITS;
 	const EVP_CIPHER *enc=NULL;
 	unsigned long f4=RSA_F4;
 	char *outfile=NULL;
@@ -103,14 +98,11 @@
 	char *engine=NULL;
 #endif
 	char *inrand=NULL;
+	mpz_t bn;
 	BIO *out=NULL;
-	BIGNUM *bn = BN_new();
 	RSA *rsa = NULL;
 
-	if(!bn) goto err;
-
 	apps_startup();
-	BN_GENCB_set(&cb, genrsa_cb, bio_err);
 
 	if (bio_err == NULL)
 		if ((bio_err=BIO_new(BIO_s_file())) != NULL)
@@ -273,23 +265,13 @@
 	if (!rsa)
 		goto err;
 
-	if(!BN_set_word(bn, f4) || !RSA_generate_key_ex(rsa, num, bn, &cb))
+	mpz_init_set_ui (bn, f4);
+	if (!RSA_generate_key_ex(rsa, num, bn))
 		goto err;
 		
 	app_RAND_write_file(NULL, bio_err);
 
-	/* We need to do the following for when the base number size is <
-	 * long, esp windows 3.1 :-(. */
-	l=0L;
-	for (i=0; i<rsa->e->top; i++)
-		{
-#ifndef SIXTY_FOUR_BIT
-		l<<=BN_BITS4;
-		l<<=BN_BITS4;
-#endif
-		l+=rsa->e->d[i];
-		}
-	BIO_printf(bio_err,"e is %ld (0x%lX)\n",l,l);
+	BIO_printf(bio_err,"e is %ld (0x%lX)\n",f4,f4);
 	{
 	PW_CB_DATA cb_data;
 	cb_data.password = passout;
@@ -301,8 +283,11 @@
 
 	ret=0;
 err:
-	if (bn) BN_free(bn);
-	if (rsa) RSA_free(rsa);
+	if (rsa)
+		{
+		mpz_clear (bn);
+		RSA_free (rsa);
+		}
 	if (out) BIO_free_all(out);
 	if(passout) OPENSSL_free(passout);
 	if (ret != 0)
@@ -311,21 +296,6 @@
 	OPENSSL_EXIT(ret);
 	}
 
-static int MS_CALLBACK genrsa_cb(int p, int n, BN_GENCB *cb)
-	{
-	char c='*';
-
-	if (p == 0) c='.';
-	if (p == 1) c='+';
-	if (p == 2) c='*';
-	if (p == 3) c='\n';
-	BIO_write(cb->arg,&c,1);
-	(void)BIO_flush(cb->arg);
-#ifdef LINT
-	p=n;
-#endif
-	return 1;
-	}
 #else /* !OPENSSL_NO_RSA */
 
 # if PEDANTIC
diff -Nur openssl-1.0.1e/apps/req.c sp-120/libs/openssl-1.0.1e/apps/req.c
--- openssl-1.0.1e/apps/req.c	2013-04-24 22:21:56.522799412 +0800
+++ sp-120/libs/openssl-1.0.1e/apps/req.c	2013-04-24 22:11:07.009800021 +0800
@@ -1036,7 +1036,7 @@
 		fprintf(stdout,"Modulus=");
 #ifndef OPENSSL_NO_RSA
 		if (EVP_PKEY_base_id(tpubkey) == EVP_PKEY_RSA)
-			BN_print(out,tpubkey->pkey.rsa->n);
+			MPZ_print(out, tpubkey->pkey.rsa->n);
 		else
 #endif
 			fprintf(stdout,"Wrong Algorithm type");
diff -Nur openssl-1.0.1e/apps/rsa.c sp-120/libs/openssl-1.0.1e/apps/rsa.c
--- openssl-1.0.1e/apps/rsa.c	2013-04-24 22:21:56.513799412 +0800
+++ sp-120/libs/openssl-1.0.1e/apps/rsa.c	2013-04-24 22:11:07.010800019 +0800
@@ -333,7 +333,7 @@
 	if (modulus)
 		{
 		BIO_printf(out,"Modulus=");
-		BN_print(out,rsa->n);
+		MPZ_print(out,rsa->n);
 		BIO_printf(out,"\n");
 		}
 
diff -Nur openssl-1.0.1e/apps/x509.c sp-120/libs/openssl-1.0.1e/apps/x509.c
--- openssl-1.0.1e/apps/x509.c	2013-04-24 22:21:56.523799412 +0800
+++ sp-120/libs/openssl-1.0.1e/apps/x509.c	2013-04-24 22:11:07.011800017 +0800
@@ -827,7 +827,7 @@
 				BIO_printf(STDout,"Modulus=");
 #ifndef OPENSSL_NO_RSA
 				if (pkey->type == EVP_PKEY_RSA)
-					BN_print(STDout,pkey->pkey.rsa->n);
+					MPZ_print(STDout,pkey->pkey.rsa->n);
 				else
 #endif
 #ifndef OPENSSL_NO_DSA
diff -Nur openssl-1.0.1e/apps/s_server.c sp-120/libs/openssl-1.0.1e/apps/s_server.c
--- openssl-1.0.1e/apps/s_server.c	2013-04-24 22:21:56.523799412 +0800
+++ sp-120/libs/openssl-1.0.1e/apps/s_server.c	2013-04-24 22:11:07.013800016 +0800
@@ -2958,20 +2958,17 @@
 #ifndef OPENSSL_NO_RSA
 static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
 	{
-	BIGNUM *bn = NULL;
-	static RSA *rsa_tmp=NULL;
-
-	if (!rsa_tmp && ((bn = BN_new()) == NULL))
-		BIO_printf(bio_err,"Allocation error in generating RSA key\n");
-	if (!rsa_tmp && bn)
-		{
+	static RSA* rsa_tmp = NULL;
+	if (!rsa_tmp) {
+		mpz_t bn;
 		if (!s_quiet)
 			{
 			BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
 			(void)BIO_flush(bio_err);
 			}
-		if(!BN_set_word(bn, RSA_F4) || ((rsa_tmp = RSA_new()) == NULL) ||
-				!RSA_generate_key_ex(rsa_tmp, keylength, bn, NULL))
+		mpz_init_set_ui (bn, RSA_F4);
+		if(((rsa_tmp = RSA_new()) == NULL) ||
+				!RSA_generate_key_ex(rsa_tmp, keylength, bn))
 			{
 			if(rsa_tmp) RSA_free(rsa_tmp);
 			rsa_tmp = NULL;
@@ -2981,7 +2978,7 @@
 			BIO_printf(bio_err,"\n");
 			(void)BIO_flush(bio_err);
 			}
-		BN_free(bn);
+		mpz_clear (bn);
 		}
 	return(rsa_tmp);
 	}
diff -Nur openssl-1.0.1e/crypto/asn1/Makefile sp-120/libs/openssl-1.0.1e/crypto/asn1/Makefile
--- openssl-1.0.1e/crypto/asn1/Makefile	2013-04-24 22:21:55.416799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/asn1/Makefile	2013-04-24 22:11:07.014800017 +0800
@@ -20,7 +20,7 @@
 LIBSRC=	a_object.c a_bitstr.c a_utctm.c a_gentm.c a_time.c a_int.c a_octet.c \
 	a_print.c a_type.c a_set.c a_dup.c a_d2i_fp.c a_i2d_fp.c \
 	a_enum.c a_utf8.c a_sign.c a_digest.c a_verify.c a_mbstr.c a_strex.c \
-	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c x_bignum.c \
+	x_algor.c x_val.c x_pubkey.c x_sig.c x_req.c x_attrib.c x_bignum.c x_mpz.c \
 	x_long.c x_name.c x_x509.c x_x509a.c x_crl.c x_info.c x_spki.c nsseq.c \
 	x_nx509.c d2i_pu.c d2i_pr.c i2d_pu.c i2d_pr.c\
 	t_req.c t_x509.c t_x509a.c t_crl.c t_pkey.c t_spki.c t_bitst.c \
@@ -33,7 +33,7 @@
 LIBOBJ= a_object.o a_bitstr.o a_utctm.o a_gentm.o a_time.o a_int.o a_octet.o \
 	a_print.o a_type.o a_set.o a_dup.o a_d2i_fp.o a_i2d_fp.o \
 	a_enum.o a_utf8.o a_sign.o a_digest.o a_verify.o a_mbstr.o a_strex.o \
-	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o x_bignum.o \
+	x_algor.o x_val.o x_pubkey.o x_sig.o x_req.o x_attrib.o x_bignum.o x_mpz.o \
 	x_long.o x_name.o x_x509.o x_x509a.o x_crl.o x_info.o x_spki.o nsseq.o \
 	x_nx509.o d2i_pu.o d2i_pr.o i2d_pu.o i2d_pr.o \
 	t_req.o t_x509.o t_x509a.o t_crl.o t_pkey.o t_spki.o t_bitst.o \
@@ -749,6 +749,15 @@
 x_bignum.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
 x_bignum.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
 x_bignum.o: ../../include/openssl/symhacks.h ../cryptlib.h x_bignum.c
+x_mpz.o: ../../e_os.h ../../include/openssl/asn1.h
+x_mpz.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
+x_mpz.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
+x_mpz.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
+x_mpz.o: ../../include/openssl/err.h ../../include/openssl/lhash.h
+x_mpz.o: ../../include/openssl/opensslconf.h
+x_mpz.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
+x_mpz.o: ../../include/openssl/safestack.h ../../include/openssl/stack.h
+x_mpz.o: ../../include/openssl/symhacks.h ../cryptlib.h x_mpz.c
 x_crl.o: ../../e_os.h ../../include/openssl/asn1.h
 x_crl.o: ../../include/openssl/asn1t.h ../../include/openssl/bio.h
 x_crl.o: ../../include/openssl/buffer.h ../../include/openssl/conf.h
diff -Nur openssl-1.0.1e/crypto/asn1/asn1.h sp-120/libs/openssl-1.0.1e/crypto/asn1/asn1.h
--- openssl-1.0.1e/crypto/asn1/asn1.h	2013-04-24 22:21:55.413799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/asn1/asn1.h	2013-04-24 22:11:07.015800018 +0800
@@ -60,6 +60,7 @@
 #define HEADER_ASN1_H
 
 #include <time.h>
+#include <openssl/gmp.h>
 #include <openssl/e_os2.h>
 #ifndef OPENSSL_NO_BIO
 #include <openssl/bio.h>
@@ -1029,6 +1030,8 @@
 int ASN1_STRING_print_ex(BIO *out, ASN1_STRING *str, unsigned long flags);
 int ASN1_bn_print(BIO *bp, const char *number, const BIGNUM *num,
 				unsigned char *buf, int off);
+int ASN1_mpz_print( BIO* bp, const char* number, const mpz_t r,
+		unsigned char* buf, int off );
 int ASN1_parse(BIO *bp,const unsigned char *pp,long len,int indent);
 int ASN1_parse_dump(BIO *bp,const unsigned char *pp,long len,int indent,int dump);
 #endif
diff -Nur openssl-1.0.1e/crypto/asn1/t_pkey.c sp-120/libs/openssl-1.0.1e/crypto/asn1/t_pkey.c
--- openssl-1.0.1e/crypto/asn1/t_pkey.c	2013-04-24 22:21:55.411799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/asn1/t_pkey.c	2013-04-24 22:11:07.016800019 +0800
@@ -58,6 +58,7 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
+#include <openssl/gmp.h>
 #include <openssl/objects.h>
 #include <openssl/buffer.h>
 #include <openssl/bn.h>
@@ -92,7 +93,7 @@
 			(neg[0] == '-')?" (Negative)":"") <= 0)
 			return(0);
 		n=BN_bn2bin(num,&buf[1]);
-	
+
 		if (buf[1] & 0x80)
 			n++;
 		else	buf++;
@@ -112,3 +113,62 @@
 		}
 	return(1);
 	}
+
+int ASN1_mpz_print( BIO* bp, const char* number, const mpz_t r,
+	unsigned char* buf, int off )
+{
+	int i;
+	const char* neg;
+
+	if (!BIO_indent (bp, off, 128)) {
+		return 0;
+	}
+
+	i = mpz_cmp_si (r, 0);
+	if (i == 0) {
+		if (BIO_printf (bp, "%s 0\n", number) <= 0) {
+			return 0;
+		}
+		return 1;
+	}
+	neg = (i < 0) ? "-" : "";
+
+	if (((mpz_sizeinbase (r, 2) + 7) >> 3) <= BN_BYTES) {
+		if (BIO_printf (bp, "%s %s%lu (%s0x%lx)\n",
+				number, neg, mpz_get_ui (r),
+				neg, mpz_get_ui (r)) <= 0) {
+			return 0;
+		}
+	} else {
+		size_t n;
+		buf[0] = 0;
+		if (BIO_printf (bp, "%s%s", number,
+				(neg[0] == '-') ? " (Negative)" : "") <= 0) {
+			return 0;
+		}
+		mpz_export (&buf[1], &n, 1, 1, 0, 0, r);
+
+		if (buf[1] & 0x80) {
+			++n;
+		} else {
+			++buf;
+		}
+
+		for (i = 0; i < n; i++) {
+			if ((i % 15) == 0) {
+				if (BIO_puts (bp, "\n") <= 0 ||
+					!BIO_indent (bp, off + 4, 128)) {
+				    return 0;
+				}
+			}
+			if (BIO_printf (bp, "%02x%s", buf[i], ((i + 1) == n) ? "" : ":")
+				<= 0) {
+				return 0;
+			}
+		}
+		if (BIO_write (bp,"\n", 1) <= 0) {
+			return 0;
+		}
+	}
+	return 1;
+}
diff -Nur openssl-1.0.1e/crypto/engine/Makefile sp-120/libs/openssl-1.0.1e/crypto/engine/Makefile
--- openssl-1.0.1e/crypto/engine/Makefile	2013-04-24 22:21:55.641799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/engine/Makefile	2013-04-24 22:11:07.017800020 +0800
@@ -22,13 +22,13 @@
 	tb_rsa.c tb_dsa.c tb_ecdsa.c tb_dh.c tb_ecdh.c tb_rand.c tb_store.c \
 	tb_cipher.c tb_digest.c tb_pkmeth.c tb_asnmth.c \
 	eng_openssl.c eng_cnf.c eng_dyn.c eng_cryptodev.c \
-	eng_rsax.c eng_rdrand.c
+	eng_rdrand.c
 LIBOBJ= eng_err.o eng_lib.o eng_list.o eng_init.o eng_ctrl.o \
 	eng_table.o eng_pkey.o eng_fat.o eng_all.o \
 	tb_rsa.o tb_dsa.o tb_ecdsa.o tb_dh.o tb_ecdh.o tb_rand.o tb_store.o \
 	tb_cipher.o tb_digest.o tb_pkmeth.o tb_asnmth.o \
 	eng_openssl.o eng_cnf.o eng_dyn.o eng_cryptodev.o \
-	eng_rsax.o eng_rdrand.o
+	eng_rdrand.o
 
 SRC= $(LIBSRC)
 
@@ -265,20 +265,6 @@
 eng_rdrand.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
 eng_rdrand.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
 eng_rdrand.o: eng_rdrand.c
-eng_rsax.o: ../../include/openssl/asn1.h ../../include/openssl/bio.h
-eng_rsax.o: ../../include/openssl/bn.h ../../include/openssl/buffer.h
-eng_rsax.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
-eng_rsax.o: ../../include/openssl/ec.h ../../include/openssl/ecdh.h
-eng_rsax.o: ../../include/openssl/ecdsa.h ../../include/openssl/engine.h
-eng_rsax.o: ../../include/openssl/err.h ../../include/openssl/evp.h
-eng_rsax.o: ../../include/openssl/lhash.h ../../include/openssl/obj_mac.h
-eng_rsax.o: ../../include/openssl/objects.h ../../include/openssl/opensslconf.h
-eng_rsax.o: ../../include/openssl/opensslv.h ../../include/openssl/ossl_typ.h
-eng_rsax.o: ../../include/openssl/pkcs7.h ../../include/openssl/rsa.h
-eng_rsax.o: ../../include/openssl/safestack.h ../../include/openssl/sha.h
-eng_rsax.o: ../../include/openssl/stack.h ../../include/openssl/symhacks.h
-eng_rsax.o: ../../include/openssl/x509.h ../../include/openssl/x509_vfy.h
-eng_rsax.o: eng_rsax.c
 eng_table.o: ../../e_os.h ../../include/openssl/asn1.h
 eng_table.o: ../../include/openssl/bio.h ../../include/openssl/buffer.h
 eng_table.o: ../../include/openssl/crypto.h ../../include/openssl/e_os2.h
diff -Nur openssl-1.0.1e/crypto/pem/pvkfmt.c sp-120/libs/openssl-1.0.1e/crypto/pem/pvkfmt.c
--- openssl-1.0.1e/crypto/pem/pvkfmt.c	2013-04-24 22:21:55.788799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/pem/pvkfmt.c	2013-04-24 22:11:07.018800020 +0800
@@ -1,58 +1,9 @@
-/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
- * project 2005.
- */
-/* ====================================================================
- * Copyright (c) 2005 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    licensing@OpenSSL.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
  *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 /* Support for PVK format keys and related structures (such a PUBLICKEYBLOB
@@ -71,7 +22,7 @@
  * format
  */
 
-static unsigned int read_ledword(const unsigned char **in)
+static unsigned int read_ledword(const unsigned char** in)
 	{
 	const unsigned char *p = *in;
 	unsigned int ret;
@@ -87,7 +38,7 @@
  * bitlen/8 bytes.
  */
 
-static int read_lebn(const unsigned char **in, unsigned int nbyte, BIGNUM **r)
+static int read_lebn(const unsigned char** in, unsigned int nbyte, BIGNUM **r)
 	{
 	const unsigned char *p;
 	unsigned char *tmpbuf, *q;
@@ -110,6 +61,13 @@
 		return 0;
 	}
 
+// Read a mpz_t in little endian format.
+static int read_lempz( const unsigned char** in, unsigned int nbyte, mpz_t r )
+{
+	mpz_import (r, nbyte, 0, 1, 0, 0, *in);
+	*in += nbyte;
+	return 1;
+}
 
 /* Convert private key blob to EVP_PKEY: RSA and DSA keys supported */
 
@@ -131,12 +89,12 @@
 /* Salt length for PVK files */
 #define PVK_SALTLEN		0x10
 
-static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
+static EVP_PKEY *b2i_rsa(const unsigned char** in, unsigned int length,
 						unsigned int bitlen, int ispub);
-static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
+static EVP_PKEY *b2i_dss(const unsigned char** in, unsigned int length,
 						unsigned int bitlen, int ispub);
 
-static int do_blob_header(const unsigned char **in, unsigned int length,
+static int do_blob_header(const unsigned char** in, unsigned int length,
 				unsigned int *pmagic, unsigned int *pbitlen,
 				int *pisdss, int *pispub)
 	{
@@ -244,7 +202,7 @@
 
 	}
 
-static EVP_PKEY *do_b2i(const unsigned char **in, unsigned int length,
+static EVP_PKEY *do_b2i(const unsigned char** in, unsigned int length,
 								int ispub)
 	{
 	const unsigned char *p = *in;
@@ -308,7 +266,7 @@
 	return ret;
 	}
 
-static EVP_PKEY *b2i_dss(const unsigned char **in, unsigned int length,
+static EVP_PKEY *b2i_dss(const unsigned char** in, unsigned int length,
 						unsigned int bitlen, int ispub)
 	{
 	const unsigned char *p = *in;
@@ -366,62 +324,47 @@
 	return NULL;
 	}
 
-static EVP_PKEY *b2i_rsa(const unsigned char **in, unsigned int length,
-						unsigned int bitlen, int ispub)
-		
-	{
-	const unsigned char *p = *in;
-	EVP_PKEY *ret = NULL;
-	RSA *rsa = NULL;
-	unsigned int nbyte, hnbyte;
-	nbyte = (bitlen + 7) >> 3;
-	hnbyte = (bitlen + 15) >> 4;
-	rsa = RSA_new();
-	ret = EVP_PKEY_new();
-	if (!rsa || !ret)
-		goto memerr;
-	rsa->e = BN_new();
-	if (!rsa->e)
-		goto memerr;
-	if (!BN_set_word(rsa->e, read_ledword(&p)))
-		goto memerr;
-	if (!read_lebn(&p, nbyte, &rsa->n))
-		goto memerr;
-	if (!ispub)
-		{
-		if (!read_lebn(&p, hnbyte, &rsa->p))
-			goto memerr;
-		if (!read_lebn(&p, hnbyte, &rsa->q))
-			goto memerr;
-		if (!read_lebn(&p, hnbyte, &rsa->dmp1))
-			goto memerr;
-		if (!read_lebn(&p, hnbyte, &rsa->dmq1))
-			goto memerr;
-		if (!read_lebn(&p, hnbyte, &rsa->iqmp))
-			goto memerr;
-		if (!read_lebn(&p, nbyte, &rsa->d))
-			goto memerr;
+static EVP_PKEY *b2i_rsa( const unsigned char** in, unsigned int length,
+	unsigned int bitlen, int ispub )
+{
+	EVP_PKEY* ret = NULL;
+	RSA* rsa = RSA_new ();
+	if (rsa) {
+		ret = EVP_PKEY_new ();
+		if (ret) {
+			unsigned int nbyte, hnbyte;
+
+			nbyte = (bitlen + 7) >> 3;
+			hnbyte = (bitlen + 15) >> 4;
+
+			mpz_set_ui (rsa->e, read_ledword (in));
+			read_lempz (in, nbyte, rsa->n);
+
+			if (!ispub) {
+				read_lempz (in, hnbyte, rsa->p);
+				read_lempz (in, hnbyte, rsa->q);
+				read_lempz (in, hnbyte, rsa->dmp1);
+				read_lempz (in, hnbyte, rsa->dmq1);
+				read_lempz (in, hnbyte, rsa->iqmp);
+				read_lempz (in, nbyte, rsa->d);
+			}
+
+			EVP_PKEY_set1_RSA (ret, rsa);
 		}
+		RSA_free (rsa);
+	}
 
-	EVP_PKEY_set1_RSA(ret, rsa);
-	RSA_free(rsa);
-	*in = p;
-	return ret;
-	memerr:
 	PEMerr(PEM_F_B2I_RSA, ERR_R_MALLOC_FAILURE);
-	if (rsa)
-		RSA_free(rsa);
-	if (ret)
-		EVP_PKEY_free(ret);
-	return NULL;
-	}
 
-EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length)
+	return ret;
+}
+
+EVP_PKEY *b2i_PrivateKey(const unsigned char** in, long length)
 	{
 	return do_b2i(in, length, 0);
 	}
 
-EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length)
+EVP_PKEY *b2i_PublicKey(const unsigned char** in, long length)
 	{
 	return do_b2i(in, length, 1);
 	}
@@ -437,7 +380,7 @@
 	return do_b2i_bio(in, 1);
 	}
 
-static void write_ledword(unsigned char **out, unsigned int dw)
+static void write_ledword(unsigned char** out, unsigned int dw)
 	{
 	unsigned char *p = *out;
 	*p++ = dw & 0xff;
@@ -447,7 +390,7 @@
 	*out = p;
 	}
 
-static void write_lebn(unsigned char **out, const BIGNUM *bn, int len)
+static void write_lebn(unsigned char** out, const BIGNUM *bn, int len)
 	{
 	int nb, i;
 	unsigned char *p = *out, *q, c;
@@ -474,14 +417,25 @@
 		}
 	}
 
+static void write_lempz( unsigned char** out, const mpz_t r, int len )
+{
+	size_t nb;
+	mpz_export (*out, &nb, 0, 1, 0, 0, r);
+	*out += nb;
+
+	if (0 < (len -= nb)) {
+		memset (*out, 0, len);
+		*out += len;
+	}
+}
 
-static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *magic);
+static int check_bitlen_rsa(RSA* rsa, int ispub, unsigned int *magic);
 static int check_bitlen_dsa(DSA *dsa, int ispub, unsigned int *magic);
 
-static void write_rsa(unsigned char **out, RSA *rsa, int ispub);
-static void write_dsa(unsigned char **out, DSA *dsa, int ispub);
+static void write_rsa(unsigned char** out, RSA* rsa, int ispub);
+static void write_dsa(unsigned char** out, DSA *dsa, int ispub);
 	
-static int do_i2b(unsigned char **out, EVP_PKEY *pk, int ispub)
+static int do_i2b(unsigned char** out, EVP_PKEY *pk, int ispub)
 	{
 	unsigned char *p;
 	unsigned int bitlen, magic = 0, keyalg;
@@ -573,60 +527,51 @@
 	return 0;
 	}
 
-static int check_bitlen_rsa(RSA *rsa, int ispub, unsigned int *pmagic)
-	{
-	int nbyte, hnbyte, bitlen;
-	if (BN_num_bits(rsa->e) > 32)
-		goto badkey;
-	bitlen = BN_num_bits(rsa->n);
-	nbyte = BN_num_bytes(rsa->n);
-	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
-	if (ispub)
-		{
-		*pmagic = MS_RSA1MAGIC;
-		return bitlen;
+static int check_bitlen_rsa( RSA* rsa, int ispub, unsigned int* pmagic )
+{
+	if (mpz_sizeinbase (rsa->e, 2) <= 32) {
+		size_t bl = mpz_sizeinbase (rsa->n, 2), hbl;
+		if (ispub) {
+			*pmagic = MS_RSA1MAGIC;
+			return (int)bl;
+		}
+		hbl = (bl + 1) >> 1;
+		if (mpz_sizeinbase (rsa->d, 2) <= bl && 
+			mpz_sizeinbase (rsa->iqmp, 2) <= hbl &&
+			mpz_sizeinbase (rsa->p, 2) <= hbl &&
+			mpz_sizeinbase (rsa->q, 2) <= hbl &&
+			mpz_sizeinbase (rsa->dmp1, 2) <= hbl &&
+			mpz_sizeinbase (rsa->dmq1, 2) <= hbl) {
+			*pmagic = MS_RSA2MAGIC;
+			return (int)hbl;
 		}
-	else
-	{
-		*pmagic = MS_RSA2MAGIC;
-		/* For private key each component must fit within nbyte or
-		 * hnbyte.
-		 */
-		if (BN_num_bytes(rsa->d) > nbyte)
-			goto badkey;
-		if ((BN_num_bytes(rsa->iqmp) > hnbyte)
-			|| (BN_num_bytes(rsa->p) > hnbyte)
-			|| (BN_num_bytes(rsa->q) > hnbyte)
-			|| (BN_num_bytes(rsa->dmp1) > hnbyte)
-			|| (BN_num_bytes(rsa->dmq1) > hnbyte))
-			goto badkey;
 	}
-	return bitlen;
-	badkey:
+
 	PEMerr(PEM_F_CHECK_BITLEN_RSA, PEM_R_UNSUPPORTED_KEY_COMPONENTS);
 	return 0;
-	}
+}
 
 
-static void write_rsa(unsigned char **out, RSA *rsa, int ispub)
-	{
-	int nbyte, hnbyte;
-	nbyte = BN_num_bytes(rsa->n);
-	hnbyte = (BN_num_bits(rsa->n) + 15) >> 4;
-	write_lebn(out, rsa->e, 4);
-	write_lebn(out, rsa->n, -1);
-	if (ispub)
-		return;
-	write_lebn(out, rsa->p, hnbyte);
-	write_lebn(out, rsa->q, hnbyte);
-	write_lebn(out, rsa->dmp1, hnbyte);
-	write_lebn(out, rsa->dmq1, hnbyte);
-	write_lebn(out, rsa->iqmp, hnbyte);
-	write_lebn(out, rsa->d, nbyte);
+static void write_rsa( unsigned char** out, RSA* rsa, int ispub )
+{
+	int bl, nbyte, hnbyte;
+	bl = mpz_sizeinbase (rsa->n, 2);
+	nbyte = (bl + 7) >> 3;
+	hnbyte = (bl + 15) >> 4;
+	write_lempz (out, rsa->e, 4);
+	write_lempz (out, rsa->n, -1);
+	if (!ispub) {
+		write_lempz (out, rsa->p, hnbyte);
+		write_lempz (out, rsa->q, hnbyte);
+		write_lempz (out, rsa->dmp1, hnbyte);
+		write_lempz (out, rsa->dmq1, hnbyte);
+		write_lempz (out, rsa->iqmp, hnbyte);
+		write_lempz (out, rsa->d, nbyte);
 	}
+}
 
-	
-static void write_dsa(unsigned char **out, DSA *dsa, int ispub)
+
+static void write_dsa(unsigned char** out, DSA *dsa, int ispub)
 	{
 	int nbyte;
 	nbyte = BN_num_bytes(dsa->p);
@@ -656,7 +601,7 @@
 
 #ifndef OPENSSL_NO_RC4
 
-static int do_PVK_header(const unsigned char **in, unsigned int length,
+static int do_PVK_header(const unsigned char** in, unsigned int length,
 		int skip_magic,
 	       	unsigned int *psaltlen, unsigned int *pkeylen)
 		
@@ -722,7 +667,7 @@
 	}
 	
 
-static EVP_PKEY *do_PVK_body(const unsigned char **in,
+static EVP_PKEY *do_PVK_body(const unsigned char** in,
 		unsigned int saltlen, unsigned int keylen,
 		pem_password_cb *cb, void *u)
 	{
@@ -767,7 +712,7 @@
 			goto err;
 		if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen, &enctmplen))
 			goto err;
-		magic = read_ledword((const unsigned char **)&q);
+		magic = read_ledword((const unsigned char** )&q);
 		if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
 			{
 			q = enctmp + 8;
@@ -781,7 +726,7 @@
 			if (!EVP_DecryptFinal_ex(&cctx, q + enctmplen,
 								&enctmplen))
 				goto err;
-			magic = read_ledword((const unsigned char **)&q);
+			magic = read_ledword((const unsigned char** )&q);
 			if (magic != MS_RSA2MAGIC && magic != MS_DSS2MAGIC)
 				{
 				PEMerr(PEM_F_DO_PVK_BODY, PEM_R_BAD_DECRYPT);
@@ -844,7 +789,7 @@
 
 	
 	
-static int i2b_PVK(unsigned char **out, EVP_PKEY*pk, int enclevel,
+static int i2b_PVK(unsigned char** out, EVP_PKEY*pk, int enclevel,
 		pem_password_cb *cb, void *u)
 	{
 	int outlen = 24, pklen;
diff -Nur openssl-1.0.1e/crypto/rsa/rsa.h sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa.h
--- openssl-1.0.1e/crypto/rsa/rsa.h	2013-04-24 22:22:43.721799372 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa.h	2013-04-24 22:11:07.020800020 +0800
@@ -1,59 +1,10 @@
 /* crypto/rsa/rsa.h */
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+/* Copyright (C) 2013 Huang Le
  * All rights reserved.
  *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #ifndef HEADER_RSA_H
@@ -70,9 +21,6 @@
 #endif
 #include <openssl/crypto.h>
 #include <openssl/ossl_typ.h>
-#ifndef OPENSSL_NO_DEPRECATED
-#include <openssl/bn.h>
-#endif
 
 #ifdef OPENSSL_NO_RSA
 #error RSA is disabled.
@@ -86,29 +34,20 @@
 /* typedef struct rsa_st RSA; */
 /* typedef struct rsa_meth_st RSA_METHOD; */
 
-struct rsa_meth_st
-	{
-	const char *name;
-	int (*rsa_pub_enc)(int flen,const unsigned char *from,
-			   unsigned char *to,
-			   RSA *rsa,int padding);
-	int (*rsa_pub_dec)(int flen,const unsigned char *from,
-			   unsigned char *to,
-			   RSA *rsa,int padding);
-	int (*rsa_priv_enc)(int flen,const unsigned char *from,
-			    unsigned char *to,
-			    RSA *rsa,int padding);
-	int (*rsa_priv_dec)(int flen,const unsigned char *from,
-			    unsigned char *to,
-			    RSA *rsa,int padding);
-	int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa,BN_CTX *ctx); /* Can be null */
-	int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
-			  const BIGNUM *m, BN_CTX *ctx,
-			  BN_MONT_CTX *m_ctx); /* Can be null */
-	int (*init)(RSA *rsa);		/* called at new */
-	int (*finish)(RSA *rsa);	/* called at free */
+struct rsa_meth_st {
+	const char* name;
+	int (*rsa_pub_enc)( int flen, const unsigned char* from,
+			unsigned char* to, RSA* rsa, int padding );
+	int (*rsa_pub_dec)( int flen, const unsigned char* from,
+			unsigned char* to, RSA* rsa, int padding );
+	int (*rsa_priv_enc)( int flen, const unsigned char* from,
+			unsigned char* to, RSA* rsa, int padding );
+	int (*rsa_priv_dec)( int flen, const unsigned char* from,
+			unsigned char* to, RSA* rsa, int padding );
+	int (*init)( RSA* rsa );	/* called at new */
+	int (*finish)( RSA* rsa );	/* called at free */
 	int flags;			/* RSA_METHOD_FLAG_* things */
-	char *app_data;			/* may be needed! */
+	char *app_data;		/* may be needed! */
 /* New sign and verify functions: some libraries don't allow arbitrary data
  * to be signed/verified: this allows them to be used. Note: for this to work
  * the RSA_public_decrypt() and RSA_private_encrypt() should *NOT* be used
@@ -116,53 +55,33 @@
  * compatibility this functionality is only enabled if the RSA_FLAG_SIGN_VER
  * option is set in 'flags'.
  */
-	int (*rsa_sign)(int type,
-		const unsigned char *m, unsigned int m_length,
-		unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
-	int (*rsa_verify)(int dtype,
-		const unsigned char *m, unsigned int m_length,
-		const unsigned char *sigbuf, unsigned int siglen,
-								const RSA *rsa);
+	int (*rsa_sign)( int type,
+		const unsigned char* m, unsigned int m_length,
+		unsigned char* sigret, unsigned int* siglen, const RSA* rsa );
+	int (*rsa_verify)( int dtype,
+		const unsigned char* m, unsigned int m_length,
+		const unsigned char* sigbuf, unsigned int siglen, const RSA* rsa );
 /* If this callback is NULL, the builtin software RSA key-gen will be used. This
  * is for behavioural compatibility whilst the code gets rewired, but one day
  * it would be nice to assume there are no such things as "builtin software"
  * implementations. */
-	int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
-	};
+	int (*rsa_keygen)( RSA* rsa, int bits, mpz_t e );
+};
 
-struct rsa_st
-	{
+struct rsa_st {
 	/* The first parameter is used to pickup errors where
 	 * this is passed instead of aEVP_PKEY, it is set to 0 */
 	int pad;
 	long version;
-	const RSA_METHOD *meth;
+	const RSA_METHOD* meth;
 	/* functional reference if 'meth' is ENGINE-provided */
-	ENGINE *engine;
-	BIGNUM *n;
-	BIGNUM *e;
-	BIGNUM *d;
-	BIGNUM *p;
-	BIGNUM *q;
-	BIGNUM *dmp1;
-	BIGNUM *dmq1;
-	BIGNUM *iqmp;
+	ENGINE* engine;
+	mpz_t n, e, d, p, q, dmp1, dmq1, iqmp;
+	void *swdmp1, *swdmq1;
 	/* be careful using this if the RSA structure is shared */
 	CRYPTO_EX_DATA ex_data;
-	int references;
-	int flags;
-
-	/* Used to cache montgomery values */
-	BN_MONT_CTX *_method_mod_n;
-	BN_MONT_CTX *_method_mod_p;
-	BN_MONT_CTX *_method_mod_q;
-
-	/* all BIGNUM values are actually in the following data, if it is not
-	 * NULL */
-	char *bignum_data;
-	BN_BLINDING *blinding;
-	BN_BLINDING *mt_blinding;
-	};
+	int references, flags;
+};
 
 #ifndef OPENSSL_RSA_MAX_MODULUS_BITS
 # define OPENSSL_RSA_MAX_MODULUS_BITS	16384
@@ -178,119 +97,121 @@
 #define RSA_3	0x3L
 #define RSA_F4	0x10001L
 
-#define RSA_METHOD_FLAG_NO_CHECK			0x0001 /* don't check pub/private match */
+#define RSA_METHOD_FLAG_NO_CHECK	0x0001 /* don't check pub/private match */
 #define RSA_METHOD_FLAG_ALLOW_OFFLOADING	0x0200 /* Allow RSA operation to be offloaded to external engine */
 
-
 #define RSA_FLAG_CACHE_PUBLIC		0x0002
 #define RSA_FLAG_CACHE_PRIVATE		0x0004
-#define RSA_FLAG_BLINDING		0x0008
+#define RSA_FLAG_BLINDING			0x0008
 #define RSA_FLAG_THREAD_SAFE		0x0010
 /* This flag means the private key operations will be handled by rsa_mod_exp
  * and that they do not depend on the private key components being present:
  * for example a key stored in external hardware. Without this flag bn_mod_exp
  * gets called when private key components are absent.
  */
-#define RSA_FLAG_EXT_PKEY		0x0020
+#define RSA_FLAG_EXT_PKEY			0x0020
 
 /* This flag in the RSA_METHOD enables the new rsa_sign, rsa_verify functions.
  */
-#define RSA_FLAG_SIGN_VER		0x0040
+#define RSA_FLAG_SIGN_VER			0x0040
 
-#define RSA_FLAG_NO_BLINDING		0x0080 /* new with 0.9.6j and 0.9.7b; the built-in
-                                                * RSA implementation now uses blinding by
-                                                * default (ignoring RSA_FLAG_BLINDING),
-                                                * but other engines might not need it
-                                                */
-#define RSA_FLAG_NO_CONSTTIME		0x0100 /* new with 0.9.8f; the built-in RSA
-						* implementation now uses constant time
-						* operations by default in private key operations,
-						* e.g., constant time modular exponentiation, 
-                                                * modular inverse without leaking branches, 
-                                                * division without leaking branches. This 
-                                                * flag disables these constant time 
-                                                * operations and results in faster RSA 
-                                                * private key operations.
-                                                */ 
+#define RSA_FLAG_NO_BLINDING		0x0080	/* new with 0.9.6j and 0.9.7b; the built-in
+											 * RSA implementation now uses blinding by
+											 * default (ignoring RSA_FLAG_BLINDING),
+											 * but other engines might not need it
+											 */
+#define RSA_FLAG_NO_CONSTTIME		0x0100	/* new with 0.9.8f; the built-in RSA
+											 * implementation now uses constant time
+											 * operations by default in private key operations,
+											 * e.g., constant time modular exponentiation, 
+											 * modular inverse without leaking branches, 
+											 * division without leaking branches. This 
+											 * flag disables these constant time 
+											 * operations and results in faster RSA 
+											 * private key operations.
+											 */
 #ifndef OPENSSL_NO_DEPRECATED
 #define RSA_FLAG_NO_EXP_CONSTTIME RSA_FLAG_NO_CONSTTIME /* deprecated name for the flag*/
-                                                /* new with 0.9.7h; the built-in RSA
-                                                * implementation now uses constant time
-                                                * modular exponentiation for secret exponents
-                                                * by default. This flag causes the
-                                                * faster variable sliding window method to
-                                                * be used for all exponents.
-                                                */
-#endif
-
-#define EVP_PKEY_CTX_set_rsa_padding(ctx, pad) \
-	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, EVP_PKEY_CTRL_RSA_PADDING, \
-				pad, NULL)
-
-#define EVP_PKEY_CTX_get_rsa_padding(ctx, ppad) \
-	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, \
-				EVP_PKEY_CTRL_GET_RSA_PADDING, 0, ppad)
-
-#define EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, len) \
-	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, \
-				(EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
-				EVP_PKEY_CTRL_RSA_PSS_SALTLEN, \
-				len, NULL)
-
-#define EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx, plen) \
-	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, \
-				(EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
-				EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN, \
-				0, plen)
-
-#define EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) \
-	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN, \
-				EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)
+											/* new with 0.9.7h; the built-in RSA
+											 * implementation now uses constant time
+											 * modular exponentiation for secret exponents
+											 * by default. This flag causes the
+											 * faster variable sliding window method to
+											 * be used for all exponents.
+											 */
+#endif
 
-#define EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \
-	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN, \
-				EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)
 
-#define	 EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md)	\
-		EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_SIG,  \
-				EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)md)
-
-#define	 EVP_PKEY_CTX_get_rsa_mgf1_md(ctx, pmd)	\
-		EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_SIG,  \
-				EVP_PKEY_CTRL_GET_RSA_MGF1_MD, 0, (void *)pmd)
-
-#define EVP_PKEY_CTRL_RSA_PADDING	(EVP_PKEY_ALG_CTRL + 1)
-#define EVP_PKEY_CTRL_RSA_PSS_SALTLEN	(EVP_PKEY_ALG_CTRL + 2)
-
-#define EVP_PKEY_CTRL_RSA_KEYGEN_BITS	(EVP_PKEY_ALG_CTRL + 3)
-#define EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP	(EVP_PKEY_ALG_CTRL + 4)
-#define EVP_PKEY_CTRL_RSA_MGF1_MD	(EVP_PKEY_ALG_CTRL + 5)
+#define EVP_PKEY_CTX_set_rsa_padding(ctx, pad)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1,	\
+		EVP_PKEY_CTRL_RSA_PADDING, pad, NULL)
+
+#define EVP_PKEY_CTX_get_rsa_padding(ctx, ppad)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1,	\
+		EVP_PKEY_CTRL_GET_RSA_PADDING, 0, ppad)
+
+#define EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, len)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA,			\
+		(EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY),	\
+		EVP_PKEY_CTRL_RSA_PSS_SALTLEN, len, NULL)
+
+#define EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx, plen)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA,			\
+		(EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY),	\
+		EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN, 0, plen)
+
+#define EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA,			\
+		EVP_PKEY_OP_KEYGEN,							\
+		EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)
+
+#define EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA,			\
+		EVP_PKEY_OP_KEYGEN,							\
+		EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)
+
+#define EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, 		\
+		EVP_PKEY_OP_TYPE_SIG,					\
+		EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void*)md)
+
+#define	EVP_PKEY_CTX_get_rsa_mgf1_md(ctx, pmd)	\
+	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA,		\
+	EVP_PKEY_OP_TYPE_SIG,						\
+	EVP_PKEY_CTRL_GET_RSA_MGF1_MD, 0, (void*)pmd)
+
+#define EVP_PKEY_CTRL_RSA_PADDING			(EVP_PKEY_ALG_CTRL + 1)
+#define EVP_PKEY_CTRL_RSA_PSS_SALTLEN		(EVP_PKEY_ALG_CTRL + 2)
+
+#define EVP_PKEY_CTRL_RSA_KEYGEN_BITS		(EVP_PKEY_ALG_CTRL + 3)
+#define EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP		(EVP_PKEY_ALG_CTRL + 4)
+#define EVP_PKEY_CTRL_RSA_MGF1_MD			(EVP_PKEY_ALG_CTRL + 5)
 
 #define EVP_PKEY_CTRL_GET_RSA_PADDING		(EVP_PKEY_ALG_CTRL + 6)
 #define EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN	(EVP_PKEY_ALG_CTRL + 7)
 #define EVP_PKEY_CTRL_GET_RSA_MGF1_MD		(EVP_PKEY_ALG_CTRL + 8)
 
-#define RSA_PKCS1_PADDING	1
-#define RSA_SSLV23_PADDING	2
-#define RSA_NO_PADDING		3
+#define RSA_PKCS1_PADDING		1
+#define RSA_SSLV23_PADDING		2
+#define RSA_NO_PADDING			3
 #define RSA_PKCS1_OAEP_PADDING	4
-#define RSA_X931_PADDING	5
+#define RSA_X931_PADDING		5
 /* EVP_PKEY_ only */
 #define RSA_PKCS1_PSS_PADDING	6
 
 #define RSA_PKCS1_PADDING_SIZE	11
 
-#define RSA_set_app_data(s,arg)         RSA_set_ex_data(s,0,arg)
-#define RSA_get_app_data(s)             RSA_get_ex_data(s,0)
+#define RSA_set_app_data(s,arg)	RSA_set_ex_data(s,0,arg)
+#define RSA_get_app_data(s)		RSA_get_ex_data(s,0)
 
-RSA *	RSA_new(void);
-RSA *	RSA_new_method(ENGINE *engine);
-int	RSA_size(const RSA *rsa);
+RSA* RSA_new();
+RSA* RSA_new_method( ENGINE* engine );
+int	RSA_size( const RSA* r );
 
 /* Deprecated version */
 #ifndef OPENSSL_NO_DEPRECATED
-RSA *	RSA_generate_key(int bits, unsigned long e,void
-		(*callback)(int,int,void *),void *cb_arg);
+RSA* RSA_generate_key( int bits, unsigned long e,
+	void (*callback)( int, int, void* ), void* cb_arg );
 #endif /* !defined(OPENSSL_NO_DEPRECATED) */
 
 /* Cavium routine */
@@ -299,145 +220,139 @@
 unsigned int RSA_check_status_cavium(unsigned int req_id, unsigned int* ret_len);
 
 /* New version */
-int	RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
+int	RSA_generate_key_ex( RSA* rsa, int bits, mpz_t e );
 
-int	RSA_check_key(const RSA *);
+int	RSA_check_key( const RSA* r );
 	/* next 4 return -1 on error */
-int	RSA_public_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa, int padding);
-int	RSA_private_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa, int padding);
-int	RSA_public_decrypt(int flen, const unsigned char *from, 
-		unsigned char *to, RSA *rsa, int padding);
-int	RSA_private_decrypt(int flen, const unsigned char *from, 
-		unsigned char *to, RSA *rsa, int padding);
-void	RSA_free (RSA *r);
+int	RSA_public_encrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+int	RSA_private_encrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+int	RSA_public_decrypt( int flen, const unsigned char* from, 
+		unsigned char* to, RSA* rsa, int padding );
+int	RSA_private_decrypt( int flen, const unsigned char* from, 
+		unsigned char* to, RSA* rsa, int padding );
+void	RSA_free( RSA* r );
 /* "up" the RSA object's reference count */
-int	RSA_up_ref(RSA *r);
+int	RSA_up_ref( RSA* r );
 
-int	RSA_flags(const RSA *r);
+int	RSA_flags( const RSA* r );
 
-void RSA_set_default_method(const RSA_METHOD *meth);
-const RSA_METHOD *RSA_get_default_method(void);
-const RSA_METHOD *RSA_get_method(const RSA *rsa);
-int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);
+void RSA_set_default_method( const RSA_METHOD* meth );
+const RSA_METHOD* RSA_get_default_method();
+const RSA_METHOD* RSA_get_method( const RSA* rsa );
+int RSA_set_method( RSA* rsa, const RSA_METHOD* meth );
 
 /* This function needs the memory locking malloc callbacks to be installed */
-int RSA_memory_lock(RSA *r);
+int RSA_memory_lock( RSA* r );
 
 /* these are the actual SSLeay RSA functions */
-const RSA_METHOD *RSA_PKCS1_SSLeay(void);
+const RSA_METHOD* RSA_PKCS1_SSLeay();
 
-const RSA_METHOD *RSA_null_method(void);
+const RSA_METHOD* RSA_null_method();
 
 DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPublicKey)
 DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPrivateKey)
 
-typedef struct rsa_pss_params_st
-	{
-	X509_ALGOR *hashAlgorithm;
-	X509_ALGOR *maskGenAlgorithm;
-	ASN1_INTEGER *saltLength;
-	ASN1_INTEGER *trailerField;
-	} RSA_PSS_PARAMS;
+typedef struct rsa_pss_params_st {
+	X509_ALGOR* hashAlgorithm;
+	X509_ALGOR* maskGenAlgorithm;
+	ASN1_INTEGER* saltLength;
+	ASN1_INTEGER* trailerField;
+} RSA_PSS_PARAMS;
 
 DECLARE_ASN1_FUNCTIONS(RSA_PSS_PARAMS)
 
 #ifndef OPENSSL_NO_FP_API
-int	RSA_print_fp(FILE *fp, const RSA *r,int offset);
+int	RSA_print_fp( FILE* fp, const RSA* r, int offset );
 #endif
 
 #ifndef OPENSSL_NO_BIO
-int	RSA_print(BIO *bp, const RSA *r,int offset);
+int MPZ_print( BIO* bp, const mpz_t r );
+int RSA_print( BIO* bp, const RSA* r, int offset );
 #endif
 
 #ifndef OPENSSL_NO_RC4
-int i2d_RSA_NET(const RSA *a, unsigned char **pp,
-		int (*cb)(char *buf, int len, const char *prompt, int verify),
-		int sgckey);
-RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,
-		 int (*cb)(char *buf, int len, const char *prompt, int verify),
-		 int sgckey);
-
-int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,
-		     int (*cb)(char *buf, int len, const char *prompt,
-			       int verify));
-RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,
-		      int (*cb)(char *buf, int len, const char *prompt,
-				int verify));
+int i2d_RSA_NET( const RSA* a, unsigned char** pp,
+		int (*cb)( char* buf, int len, const char* prompt, int verify ),
+		int sgckey );
+RSA* d2i_RSA_NET( RSA** a, const unsigned char** pp, long length,
+		int (*cb)( char* buf, int len, const char* prompt, int verify ),
+		int sgckey );
+
+int i2d_Netscape_RSA( const RSA* a, unsigned char** pp,
+		int (*cb)( char* buf, int len, const char* prompt, int verify));
+RSA* d2i_Netscape_RSA( RSA** a, const unsigned char** pp, long length,
+		int (*cb)( char* buf, int len, const char* prompt, int verify));
 #endif
 
 /* The following 2 functions sign and verify a X509_SIG ASN1 object
  * inside PKCS#1 padded RSA encryption */
-int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
-	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
-int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
-	const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
+int RSA_sign( int type, const unsigned char* m, unsigned int m_length,
+		unsigned char* sigret, unsigned int* siglen, RSA* rsa );
+int RSA_verify( int type, const unsigned char* m, unsigned int m_length,
+		const unsigned char* sigbuf, unsigned int siglen, RSA* rsa );
 
 /* The following 2 function sign and verify a ASN1_OCTET_STRING
  * object inside PKCS#1 padded RSA encryption */
-int RSA_sign_ASN1_OCTET_STRING(int type,
-	const unsigned char *m, unsigned int m_length,
-	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
-int RSA_verify_ASN1_OCTET_STRING(int type,
-	const unsigned char *m, unsigned int m_length,
-	unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
-
-int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);
-void RSA_blinding_off(RSA *rsa);
-BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);
-
-int RSA_padding_add_PKCS1_type_1(unsigned char *to,int tlen,
-	const unsigned char *f,int fl);
-int RSA_padding_check_PKCS1_type_1(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,int rsa_len);
-int RSA_padding_add_PKCS1_type_2(unsigned char *to,int tlen,
-	const unsigned char *f,int fl);
-int RSA_padding_check_PKCS1_type_2(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,int rsa_len);
-int PKCS1_MGF1(unsigned char *mask, long len,
-	const unsigned char *seed, long seedlen, const EVP_MD *dgst);
-int RSA_padding_add_PKCS1_OAEP(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,
-	const unsigned char *p,int pl);
-int RSA_padding_check_PKCS1_OAEP(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,int rsa_len,
-	const unsigned char *p,int pl);
-int RSA_padding_add_SSLv23(unsigned char *to,int tlen,
-	const unsigned char *f,int fl);
-int RSA_padding_check_SSLv23(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,int rsa_len);
-int RSA_padding_add_none(unsigned char *to,int tlen,
-	const unsigned char *f,int fl);
-int RSA_padding_check_none(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,int rsa_len);
-int RSA_padding_add_X931(unsigned char *to,int tlen,
-	const unsigned char *f,int fl);
-int RSA_padding_check_X931(unsigned char *to,int tlen,
-	const unsigned char *f,int fl,int rsa_len);
-int RSA_X931_hash_id(int nid);
-
-int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
-			const EVP_MD *Hash, const unsigned char *EM, int sLen);
-int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
-			const unsigned char *mHash,
-			const EVP_MD *Hash, int sLen);
-
-int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
-			const EVP_MD *Hash, const EVP_MD *mgf1Hash, 
-			const unsigned char *EM, int sLen);
-
-int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
-			const unsigned char *mHash,
-			const EVP_MD *Hash, const EVP_MD *mgf1Hash, int sLen);
-
-int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
-	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
-int RSA_set_ex_data(RSA *r,int idx,void *arg);
-void *RSA_get_ex_data(const RSA *r, int idx);
+int RSA_sign_ASN1_OCTET_STRING( int type,
+		const unsigned char* m, unsigned int m_length,
+		unsigned char* sigret, unsigned int* siglen, RSA* rsa );
+int RSA_verify_ASN1_OCTET_STRING( int type,
+		const unsigned char* m, unsigned int m_length,
+		unsigned char* sigbuf, unsigned int siglen, RSA* rsa );
+
+int RSA_padding_add_PKCS1_type_1( unsigned char* to, int tlen,
+		const unsigned char* f, int fl );
+int RSA_padding_check_PKCS1_type_1( unsigned char* to, int tlen,
+		const unsigned char* f, int fl, int rsa_len );
+int RSA_padding_add_PKCS1_type_2( unsigned char* to, int tlen,
+		const unsigned char* f, int fl );
+int RSA_padding_check_PKCS1_type_2( unsigned char* to, int tlen,
+		const unsigned char* f, int fl, int rsa_len );
+int PKCS1_MGF1( unsigned char* mask, long len,
+		const unsigned char* seed, long seedlen, const EVP_MD* dgst );
+int RSA_padding_add_PKCS1_OAEP( unsigned char* to, int tlen,
+		const unsigned char* f, int fl,
+		const unsigned char* p, int pl );
+int RSA_padding_check_PKCS1_OAEP( unsigned char* to, int tlen,
+		const unsigned char* f, int fl, int rsa_len,
+		const unsigned char* p, int pl );
+int RSA_padding_add_SSLv23( unsigned char* to, int tlen,
+		const unsigned char* f, int fl );
+int RSA_padding_check_SSLv23( unsigned char* to, int tlen,
+		const unsigned char* f, int fl, int rsa_len );
+int RSA_padding_add_none( unsigned char* to, int tlen,
+		const unsigned char* f, int fl );
+int RSA_padding_check_none( unsigned char* to, int tlen,
+		const unsigned char* f, int fl, int rsa_len );
+int RSA_padding_add_X931( unsigned char* to, int tlen,
+		const unsigned char* f, int fl );
+int RSA_padding_check_X931( unsigned char* to, int tlen,
+		const unsigned char* f, int fl, int rsa_len );
+int RSA_X931_hash_id( int nid );
+
+int RSA_verify_PKCS1_PSS( RSA* rsa, const unsigned char* mHash,
+		const EVP_MD* Hash, const unsigned char* EM, int sLen );
+int RSA_padding_add_PKCS1_PSS( RSA* rsa, unsigned char* EM,
+		const unsigned char* mHash,
+		const EVP_MD* Hash, int sLen );
+
+int RSA_verify_PKCS1_PSS_mgf1( RSA* rsa, const unsigned char* mHash,
+		const EVP_MD* Hash, const EVP_MD* mgf1Hash,
+		const unsigned char* EM, int sLen );
+
+int RSA_padding_add_PKCS1_PSS_mgf1( RSA* rsa, unsigned char* EM,
+		const unsigned char* mHash,
+		const EVP_MD* Hash, const EVP_MD* mgf1Hash, int sLen );
+
+int RSA_get_ex_new_index( long argl, void* argp, CRYPTO_EX_new* new_func,
+		CRYPTO_EX_dup* dup_func, CRYPTO_EX_free* free_func );
+int RSA_set_ex_data( RSA* r, int idx, void* arg );
+void* RSA_get_ex_data( const RSA* r, int idx );
 
-RSA *RSAPublicKey_dup(RSA *rsa);
-RSA *RSAPrivateKey_dup(RSA *rsa);
+RSA* RSAPublicKey_dup( RSA* rsa );
+RSA* RSAPrivateKey_dup( RSA* rsa );
 
 /* If this flag is set the RSA method is FIPS compliant and can be used
  * in FIPS mode. This is set in the validated module method. If an
@@ -445,14 +360,14 @@
  * to ensure the result is compliant.
  */
 
-#define RSA_FLAG_FIPS_METHOD			0x0400
+#define RSA_FLAG_FIPS_METHOD		0x0400
 
 /* If this flag is set the operations normally disabled in FIPS mode are
  * permitted it is then the applications responsibility to ensure that the
  * usage is compliant.
  */
 
-#define RSA_FLAG_NON_FIPS_ALLOW			0x0400
+#define RSA_FLAG_NON_FIPS_ALLOW		0x0400
 /* Application has decided PRNG is good enough to generate a key: don't
  * check.
  */
@@ -467,125 +382,125 @@
 /* Error codes for the RSA functions. */
 
 /* Function codes. */
-#define RSA_F_CHECK_PADDING_MD				 140
-#define RSA_F_DO_RSA_PRINT				 146
-#define RSA_F_INT_RSA_VERIFY				 145
-#define RSA_F_MEMORY_LOCK				 100
-#define RSA_F_OLD_RSA_PRIV_DECODE			 147
-#define RSA_F_PKEY_RSA_CTRL				 143
-#define RSA_F_PKEY_RSA_CTRL_STR				 144
-#define RSA_F_PKEY_RSA_SIGN				 142
-#define RSA_F_PKEY_RSA_VERIFY				 154
-#define RSA_F_PKEY_RSA_VERIFYRECOVER			 141
-#define RSA_F_RSA_BUILTIN_KEYGEN			 129
-#define RSA_F_RSA_CHECK_KEY				 123
-#define RSA_F_RSA_EAY_PRIVATE_DECRYPT			 101
-#define RSA_F_RSA_EAY_PRIVATE_ENCRYPT			 102
-#define RSA_F_RSA_EAY_PUBLIC_DECRYPT			 103
-#define RSA_F_RSA_EAY_PUBLIC_ENCRYPT			 104
-#define RSA_F_RSA_GENERATE_KEY				 105
-#define RSA_F_RSA_GENERATE_KEY_EX			 155
-#define RSA_F_RSA_ITEM_VERIFY				 156
-#define RSA_F_RSA_MEMORY_LOCK				 130
-#define RSA_F_RSA_NEW_METHOD				 106
-#define RSA_F_RSA_NULL					 124
-#define RSA_F_RSA_NULL_MOD_EXP				 131
-#define RSA_F_RSA_NULL_PRIVATE_DECRYPT			 132
-#define RSA_F_RSA_NULL_PRIVATE_ENCRYPT			 133
-#define RSA_F_RSA_NULL_PUBLIC_DECRYPT			 134
-#define RSA_F_RSA_NULL_PUBLIC_ENCRYPT			 135
-#define RSA_F_RSA_PADDING_ADD_NONE			 107
-#define RSA_F_RSA_PADDING_ADD_PKCS1_OAEP		 121
-#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS			 125
-#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1		 148
-#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1		 108
-#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2		 109
-#define RSA_F_RSA_PADDING_ADD_SSLV23			 110
-#define RSA_F_RSA_PADDING_ADD_X931			 127
-#define RSA_F_RSA_PADDING_CHECK_NONE			 111
-#define RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP		 122
-#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1		 112
-#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2		 113
-#define RSA_F_RSA_PADDING_CHECK_SSLV23			 114
-#define RSA_F_RSA_PADDING_CHECK_X931			 128
-#define RSA_F_RSA_PRINT					 115
-#define RSA_F_RSA_PRINT_FP				 116
-#define RSA_F_RSA_PRIVATE_DECRYPT			 150
-#define RSA_F_RSA_PRIVATE_ENCRYPT			 151
-#define RSA_F_RSA_PRIV_DECODE				 137
-#define RSA_F_RSA_PRIV_ENCODE				 138
-#define RSA_F_RSA_PUBLIC_DECRYPT			 152
-#define RSA_F_RSA_PUBLIC_ENCRYPT			 153
-#define RSA_F_RSA_PUB_DECODE				 139
-#define RSA_F_RSA_SETUP_BLINDING			 136
-#define RSA_F_RSA_SIGN					 117
-#define RSA_F_RSA_SIGN_ASN1_OCTET_STRING		 118
-#define RSA_F_RSA_VERIFY				 119
-#define RSA_F_RSA_VERIFY_ASN1_OCTET_STRING		 120
-#define RSA_F_RSA_VERIFY_PKCS1_PSS			 126
-#define RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1			 149
+#define RSA_F_CHECK_PADDING_MD					140
+#define RSA_F_DO_RSA_PRINT						146
+#define RSA_F_INT_RSA_VERIFY					145
+#define RSA_F_MEMORY_LOCK						100
+#define RSA_F_OLD_RSA_PRIV_DECODE				147
+#define RSA_F_PKEY_RSA_CTRL						143
+#define RSA_F_PKEY_RSA_CTRL_STR					144
+#define RSA_F_PKEY_RSA_SIGN						142
+#define RSA_F_PKEY_RSA_VERIFY					154
+#define RSA_F_PKEY_RSA_VERIFYRECOVER			141
+#define RSA_F_RSA_BUILTIN_KEYGEN				129
+#define RSA_F_RSA_CHECK_KEY						123
+#define RSA_F_RSA_EAY_PRIVATE_DECRYPT			101
+#define RSA_F_RSA_EAY_PRIVATE_ENCRYPT			102
+#define RSA_F_RSA_EAY_PUBLIC_DECRYPT			103
+#define RSA_F_RSA_EAY_PUBLIC_ENCRYPT			104
+#define RSA_F_RSA_GENERATE_KEY					105
+#define RSA_F_RSA_GENERATE_KEY_EX				155
+#define RSA_F_RSA_ITEM_VERIFY					156
+#define RSA_F_RSA_MEMORY_LOCK					130
+#define RSA_F_RSA_NEW_METHOD					106
+#define RSA_F_RSA_NULL							124
+#define RSA_F_RSA_NULL_MOD_EXP					131
+#define RSA_F_RSA_NULL_PRIVATE_DECRYPT			132
+#define RSA_F_RSA_NULL_PRIVATE_ENCRYPT			133
+#define RSA_F_RSA_NULL_PUBLIC_DECRYPT			134
+#define RSA_F_RSA_NULL_PUBLIC_ENCRYPT			135
+#define RSA_F_RSA_PADDING_ADD_NONE				107
+#define RSA_F_RSA_PADDING_ADD_PKCS1_OAEP		121
+#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS			125
+#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1	148
+#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1		108
+#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2		109
+#define RSA_F_RSA_PADDING_ADD_SSLV23			110
+#define RSA_F_RSA_PADDING_ADD_X931				127
+#define RSA_F_RSA_PADDING_CHECK_NONE			111
+#define RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP		122
+#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1	112
+#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2	113
+#define RSA_F_RSA_PADDING_CHECK_SSLV23			114
+#define RSA_F_RSA_PADDING_CHECK_X931			128
+#define RSA_F_RSA_PRINT					 		115
+#define RSA_F_RSA_PRINT_FP						116
+#define RSA_F_RSA_PRIVATE_DECRYPT				150
+#define RSA_F_RSA_PRIVATE_ENCRYPT				151
+#define RSA_F_RSA_PRIV_DECODE					137
+#define RSA_F_RSA_PRIV_ENCODE					138
+#define RSA_F_RSA_PUBLIC_DECRYPT				152
+#define RSA_F_RSA_PUBLIC_ENCRYPT				153
+#define RSA_F_RSA_PUB_DECODE					139
+#define RSA_F_RSA_SETUP_BLINDING				136
+#define RSA_F_RSA_SIGN							117
+#define RSA_F_RSA_SIGN_ASN1_OCTET_STRING		118
+#define RSA_F_RSA_VERIFY						119
+#define RSA_F_RSA_VERIFY_ASN1_OCTET_STRING		120
+#define RSA_F_RSA_VERIFY_PKCS1_PSS				126
+#define RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1			149
 
 /* Reason codes. */
-#define RSA_R_ALGORITHM_MISMATCH			 100
-#define RSA_R_BAD_E_VALUE				 101
-#define RSA_R_BAD_FIXED_HEADER_DECRYPT			 102
-#define RSA_R_BAD_PAD_BYTE_COUNT			 103
-#define RSA_R_BAD_SIGNATURE				 104
-#define RSA_R_BLOCK_TYPE_IS_NOT_01			 106
-#define RSA_R_BLOCK_TYPE_IS_NOT_02			 107
-#define RSA_R_DATA_GREATER_THAN_MOD_LEN			 108
-#define RSA_R_DATA_TOO_LARGE				 109
-#define RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE		 110
-#define RSA_R_DATA_TOO_LARGE_FOR_MODULUS		 132
-#define RSA_R_DATA_TOO_SMALL				 111
-#define RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE		 122
-#define RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY		 112
-#define RSA_R_DMP1_NOT_CONGRUENT_TO_D			 124
-#define RSA_R_DMQ1_NOT_CONGRUENT_TO_D			 125
-#define RSA_R_D_E_NOT_CONGRUENT_TO_1			 123
-#define RSA_R_FIRST_OCTET_INVALID			 133
-#define RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE	 144
-#define RSA_R_INVALID_DIGEST_LENGTH			 143
-#define RSA_R_INVALID_HEADER				 137
-#define RSA_R_INVALID_KEYBITS				 145
-#define RSA_R_INVALID_MESSAGE_LENGTH			 131
-#define RSA_R_INVALID_MGF1_MD				 156
-#define RSA_R_INVALID_PADDING				 138
-#define RSA_R_INVALID_PADDING_MODE			 141
-#define RSA_R_INVALID_PSS_PARAMETERS			 149
-#define RSA_R_INVALID_PSS_SALTLEN			 146
-#define RSA_R_INVALID_SALT_LENGTH			 150
-#define RSA_R_INVALID_TRAILER				 139
-#define RSA_R_INVALID_X931_DIGEST			 142
-#define RSA_R_IQMP_NOT_INVERSE_OF_Q			 126
-#define RSA_R_KEY_SIZE_TOO_SMALL			 120
-#define RSA_R_LAST_OCTET_INVALID			 134
-#define RSA_R_MODULUS_TOO_LARGE				 105
-#define RSA_R_NON_FIPS_RSA_METHOD			 157
-#define RSA_R_NO_PUBLIC_EXPONENT			 140
-#define RSA_R_NULL_BEFORE_BLOCK_MISSING			 113
-#define RSA_R_N_DOES_NOT_EQUAL_P_Q			 127
-#define RSA_R_OAEP_DECODING_ERROR			 121
-#define RSA_R_OPERATION_IN_PROGRESS			 159
-#define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	 158
-#define RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 148
-#define RSA_R_PADDING_CHECK_FAILED			 114
-#define RSA_R_P_NOT_PRIME				 128
-#define RSA_R_Q_NOT_PRIME				 129
-#define RSA_R_RSA_OPERATIONS_NOT_SUPPORTED		 130
-#define RSA_R_SLEN_CHECK_FAILED				 136
-#define RSA_R_SLEN_RECOVERY_FAILED			 135
-#define RSA_R_SSLV3_ROLLBACK_ATTACK			 115
-#define RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD 116
-#define RSA_R_UNKNOWN_ALGORITHM_TYPE			 117
-#define RSA_R_UNKNOWN_MASK_DIGEST			 151
-#define RSA_R_UNKNOWN_PADDING_TYPE			 118
-#define RSA_R_UNKNOWN_PSS_DIGEST			 152
-#define RSA_R_UNSUPPORTED_MASK_ALGORITHM		 153
-#define RSA_R_UNSUPPORTED_MASK_PARAMETER		 154
-#define RSA_R_UNSUPPORTED_SIGNATURE_TYPE		 155
-#define RSA_R_VALUE_MISSING				 147
-#define RSA_R_WRONG_SIGNATURE_LENGTH			 119
+#define RSA_R_ALGORITHM_MISMATCH				100
+#define RSA_R_BAD_E_VALUE						101
+#define RSA_R_BAD_FIXED_HEADER_DECRYPT			102
+#define RSA_R_BAD_PAD_BYTE_COUNT				103
+#define RSA_R_BAD_SIGNATURE						104
+#define RSA_R_BLOCK_TYPE_IS_NOT_01				106
+#define RSA_R_BLOCK_TYPE_IS_NOT_02				107
+#define RSA_R_DATA_GREATER_THAN_MOD_LEN			108
+#define RSA_R_DATA_TOO_LARGE					109
+#define RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE		110
+#define RSA_R_DATA_TOO_LARGE_FOR_MODULUS		132
+#define RSA_R_DATA_TOO_SMALL					111
+#define RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE		122
+#define RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY		112
+#define RSA_R_DMP1_NOT_CONGRUENT_TO_D			124
+#define RSA_R_DMQ1_NOT_CONGRUENT_TO_D			125
+#define RSA_R_D_E_NOT_CONGRUENT_TO_1			123
+#define RSA_R_FIRST_OCTET_INVALID				133
+#define RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE	144
+#define RSA_R_INVALID_DIGEST_LENGTH				143
+#define RSA_R_INVALID_HEADER					137
+#define RSA_R_INVALID_KEYBITS					145
+#define RSA_R_INVALID_MESSAGE_LENGTH			131
+#define RSA_R_INVALID_MGF1_MD					156
+#define RSA_R_INVALID_PADDING					138
+#define RSA_R_INVALID_PADDING_MODE				141
+#define RSA_R_INVALID_PSS_PARAMETERS			149
+#define RSA_R_INVALID_PSS_SALTLEN				146
+#define RSA_R_INVALID_SALT_LENGTH				150
+#define RSA_R_INVALID_TRAILER					139
+#define RSA_R_INVALID_X931_DIGEST				142
+#define RSA_R_IQMP_NOT_INVERSE_OF_Q				126
+#define RSA_R_KEY_SIZE_TOO_SMALL				120
+#define RSA_R_LAST_OCTET_INVALID				134
+#define RSA_R_MODULUS_TOO_LARGE					105
+#define RSA_R_NON_FIPS_RSA_METHOD				157
+#define RSA_R_NO_PUBLIC_EXPONENT				140
+#define RSA_R_NULL_BEFORE_BLOCK_MISSING			113
+#define RSA_R_N_DOES_NOT_EQUAL_P_Q				127
+#define RSA_R_OAEP_DECODING_ERROR				121
+#define RSA_R_OPERATION_IN_PROGRESS			159 
+#define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	158
+#define RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	148
+#define RSA_R_PADDING_CHECK_FAILED				114
+#define RSA_R_P_NOT_PRIME						128
+#define RSA_R_Q_NOT_PRIME						129
+#define RSA_R_RSA_OPERATIONS_NOT_SUPPORTED		130
+#define RSA_R_SLEN_CHECK_FAILED					136
+#define RSA_R_SLEN_RECOVERY_FAILED				135
+#define RSA_R_SSLV3_ROLLBACK_ATTACK				115
+#define RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD	116
+#define RSA_R_UNKNOWN_ALGORITHM_TYPE			117
+#define RSA_R_UNKNOWN_MASK_DIGEST				151
+#define RSA_R_UNKNOWN_PADDING_TYPE				118
+#define RSA_R_UNKNOWN_PSS_DIGEST				152
+#define RSA_R_UNSUPPORTED_MASK_ALGORITHM		153
+#define RSA_R_UNSUPPORTED_MASK_PARAMETER		154
+#define RSA_R_UNSUPPORTED_SIGNATURE_TYPE		155
+#define RSA_R_VALUE_MISSING						147
+#define RSA_R_WRONG_SIGNATURE_LENGTH			119
 
 #ifdef  __cplusplus
 }
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_ameth.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_ameth.c
--- openssl-1.0.1e/crypto/rsa/rsa_ameth.c	2013-04-24 22:21:55.207799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_ameth.c	2013-04-24 22:11:07.021800020 +0800
@@ -1,4 +1,11 @@
 /* crypto/rsa/rsa_ameth.c */
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
+ *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
+ */
 /* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
  * project 2006.
  */
@@ -61,17 +68,15 @@
 #include <openssl/asn1t.h>
 #include <openssl/x509.h>
 #include <openssl/rsa.h>
-#include <openssl/bn.h>
 #ifndef OPENSSL_NO_CMS
 #include <openssl/cms.h>
 #endif
 #include "asn1_locl.h"
 
-static int rsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY *pkey)
+static int rsa_pub_encode(X509_PUBKEY *pk, const EVP_PKEY* pkey)
 	{
-	unsigned char *penc = NULL;
-	int penclen;
-	penclen = i2d_RSAPublicKey(pkey->pkey.rsa, &penc);
+	unsigned char* penc = NULL;
+	int penclen = i2d_RSAPublicKey(pkey->pkey.rsa, &penc);
 	if (penclen <= 0)
 		return 0;
 	if (X509_PUBKEY_set0_param(pk, OBJ_nid2obj(EVP_PKEY_RSA),
@@ -82,11 +87,11 @@
 	return 0;
 	}
 
-static int rsa_pub_decode(EVP_PKEY *pkey, X509_PUBKEY *pubkey)
+static int rsa_pub_decode(EVP_PKEY* pkey, X509_PUBKEY *pubkey)
 	{
-	const unsigned char *p;
+	const unsigned char* p;
 	int pklen;
-	RSA *rsa = NULL;
+	RSA* rsa = NULL;
 	if (!X509_PUBKEY_get0_param(NULL, &p, &pklen, NULL, pubkey))
 		return 0;
 	if (!(rsa = d2i_RSAPublicKey(NULL, &p, pklen)))
@@ -98,18 +103,19 @@
 	return 1;
 	}
 
-static int rsa_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
-	{
-	if (BN_cmp(b->pkey.rsa->n,a->pkey.rsa->n) != 0
-		|| BN_cmp(b->pkey.rsa->e,a->pkey.rsa->e) != 0)
-			return 0;
-	return 1;
+static int rsa_pub_cmp(const EVP_PKEY* a, const EVP_PKEY* b)
+{
+	if (mpz_cmp (b->pkey.rsa->n, a->pkey.rsa->n) ||
+		mpz_cmp (b->pkey.rsa->e,a->pkey.rsa->e)) {
+		return 0;
 	}
+	return 1;
+}
 
-static int old_rsa_priv_decode(EVP_PKEY *pkey,
-					const unsigned char **pder, int derlen)
+static int old_rsa_priv_decode(EVP_PKEY* pkey,
+					const unsigned char* *pder, int derlen)
 	{
-	RSA *rsa;
+	RSA* rsa;
 	if (!(rsa = d2i_RSAPrivateKey (NULL, pder, derlen)))
 		{
 		RSAerr(RSA_F_OLD_RSA_PRIV_DECODE, ERR_R_RSA_LIB);
@@ -119,14 +125,14 @@
 	return 1;
 	}
 
-static int old_rsa_priv_encode(const EVP_PKEY *pkey, unsigned char **pder)
+static int old_rsa_priv_encode(const EVP_PKEY* pkey, unsigned char* *pder)
 	{
 	return i2d_RSAPrivateKey(pkey->pkey.rsa, pder);
 	}
 
-static int rsa_priv_encode(PKCS8_PRIV_KEY_INFO *p8, const EVP_PKEY *pkey)
+static int rsa_priv_encode(PKCS8_PRIV_KEY_INFO* p8, const EVP_PKEY* pkey)
 	{
-	unsigned char *rk = NULL;
+	unsigned char* rk = NULL;
 	int rklen;
 	rklen = i2d_RSAPrivateKey(pkey->pkey.rsa, &rk);
 
@@ -146,120 +152,119 @@
 	return 1;
 	}
 
-static int rsa_priv_decode(EVP_PKEY *pkey, PKCS8_PRIV_KEY_INFO *p8)
-	{
-	const unsigned char *p;
+static int rsa_priv_decode( EVP_PKEY* pkey, PKCS8_PRIV_KEY_INFO* p8 )
+{
+	const unsigned char* p;
 	int pklen;
 	if (!PKCS8_pkey_get0(NULL, &p, &pklen, NULL, p8))
 		return 0;
 	return old_rsa_priv_decode(pkey, &p, pklen);
-	}
-
-static int int_rsa_size(const EVP_PKEY *pkey)
-	{
-	return RSA_size(pkey->pkey.rsa);
-	}
+}
 
-static int rsa_bits(const EVP_PKEY *pkey)
-	{
-	return BN_num_bits(pkey->pkey.rsa->n);
-	}
-
-static void int_rsa_free(EVP_PKEY *pkey)
-	{
-	RSA_free(pkey->pkey.rsa);
-	}
-
-
-static void update_buflen(const BIGNUM *b, size_t *pbuflen)
-	{
-	size_t i;
-	if (!b)
-		return;
-	if (*pbuflen < (i = (size_t)BN_num_bytes(b)))
-			*pbuflen = i;
-	}
-
-static int do_rsa_print(BIO *bp, const RSA *x, int off, int priv)
-	{
-	char *str;
-	const char *s;
-	unsigned char *m=NULL;
-	int ret=0, mod_len = 0;
-	size_t buf_len=0;
-
-	update_buflen(x->n, &buf_len);
-	update_buflen(x->e, &buf_len);
-
-	if (priv)
-		{
-		update_buflen(x->d, &buf_len);
-		update_buflen(x->p, &buf_len);
-		update_buflen(x->q, &buf_len);
-		update_buflen(x->dmp1, &buf_len);
-		update_buflen(x->dmq1, &buf_len);
-		update_buflen(x->iqmp, &buf_len);
-		}
-
-	m=(unsigned char *)OPENSSL_malloc(buf_len+10);
-	if (m == NULL)
-		{
+static int int_rsa_size( const EVP_PKEY* pkey )
+{
+	return RSA_size (pkey->pkey.rsa);
+}
+
+static int rsa_bits( const EVP_PKEY* pkey )
+{
+	return mpz_sizeinbase (pkey->pkey.rsa->n, 2);
+}
+
+static void int_rsa_free( EVP_PKEY* pkey )
+{
+	RSA_free (pkey->pkey.rsa);
+}
+
+
+static void update_buflen( const mpz_t b, size_t* pbuflen )
+{
+	size_t i = (size_t)((mpz_sizeinbase (b, 2) + 7) >> 3);
+	if (*pbuflen < i) {
+		*pbuflen = i;
+	}
+}
+
+static int do_rsa_print(BIO* bp, const RSA* x, int off, int priv )
+{
+	char* str;
+	const char* s;
+	unsigned char* m = NULL;
+	int ret = 0, mod_len = 0;
+	size_t buf_len = 0;
+
+	update_buflen (x->n, &buf_len);
+	update_buflen (x->e, &buf_len);
+/*
+	if (priv) {
+		update_buflen (x->d, &buf_len);
+		update_buflen (x->p, &buf_len);
+		update_buflen (x->q, &buf_len);
+		update_buflen (x->dmp1, &buf_len);
+		update_buflen (x->dmq1, &buf_len);
+		update_buflen (x->iqmp, &buf_len);
+	}
+*/
+	m = (unsigned char*)OPENSSL_malloc (buf_len + 10);
+	if (!m) {
 		RSAerr(RSA_F_DO_RSA_PRINT,ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
+	}
 
-	if (x->n != NULL)
-		mod_len = BN_num_bits(x->n);
+	mod_len = mpz_sizeinbase (x->n, 2);
 
-	if(!BIO_indent(bp,off,128))
+	if (!BIO_indent (bp,off,128)) {
 		goto err;
+	}
 
-	if (priv && x->d)
-		{
-		if (BIO_printf(bp,"Private-Key: (%d bit)\n", mod_len)
+	if (priv && mpz_cmp_ui (x->d, 0)) {
+		if (BIO_printf (bp, "Private-Key: (%d bit)\n", mod_len)
 			<= 0) goto err;
 		str = "modulus:";
 		s = "publicExponent:";
-		}
-	else
-		{
-		if (BIO_printf(bp,"Public-Key: (%d bit)\n", mod_len)
+	} else {
+		if (BIO_printf (bp, "Public-Key: (%d bit)\n", mod_len)
 			<= 0) goto err;
 		str = "Modulus:";
 		s= "Exponent:";
-		}
-	if (!ASN1_bn_print(bp,str,x->n,m,off)) goto err;
-	if (!ASN1_bn_print(bp,s,x->e,m,off))
+	}
+	if (!ASN1_mpz_print (bp, str, x->n, m, off)) goto err;
+	if (!ASN1_mpz_print (bp, s, x->e, m, off))
 		goto err;
-	if (priv)
-		{
-		if (!ASN1_bn_print(bp,"privateExponent:",x->d,m,off))
+	if (priv) {
+		if (!ASN1_mpz_print (bp, "privateExponent:", x->d, m, off))
 			goto err;
-		if (!ASN1_bn_print(bp,"prime1:",x->p,m,off))
+		if (!ASN1_mpz_print (bp, "prime1:", x->p, m, off))
 			goto err;
-		if (!ASN1_bn_print(bp,"prime2:",x->q,m,off))
+		if (!ASN1_mpz_print(bp,"prime2:",x->q,m,off))
 			goto err;
-		if (!ASN1_bn_print(bp,"exponent1:",x->dmp1,m,off))
+		if (!ASN1_mpz_print(bp,"exponent1:",x->dmp1,m,off))
 			goto err;
-		if (!ASN1_bn_print(bp,"exponent2:",x->dmq1,m,off))
+		if (!ASN1_mpz_print(bp,"exponent2:",x->dmq1,m,off))
 			goto err;
-		if (!ASN1_bn_print(bp,"coefficient:",x->iqmp,m,off))
+		if (!ASN1_mpz_print(bp,"coefficient:",x->iqmp,m,off))
 			goto err;
-		}
-	ret=1;
+	}
+
+	ret = 1;
+
 err:
-	if (m != NULL) OPENSSL_free(m);
-	return(ret);
+
+	if (m) {
+		OPENSSL_free (m);
 	}
 
-static int rsa_pub_print(BIO *bp, const EVP_PKEY *pkey, int indent,
+	return ret;
+}
+
+static int rsa_pub_print(BIO* bp, const EVP_PKEY* pkey, int indent,
 							ASN1_PCTX *ctx)
 	{
 	return do_rsa_print(bp, pkey->pkey.rsa, indent, 0);
 	}
 
 
-static int rsa_priv_print(BIO *bp, const EVP_PKEY *pkey, int indent,
+static int rsa_priv_print(BIO* bp, const EVP_PKEY* pkey, int indent,
 							ASN1_PCTX *ctx)
 	{
 	return do_rsa_print(bp, pkey->pkey.rsa, indent, 1);
@@ -268,7 +273,7 @@
 static RSA_PSS_PARAMS *rsa_pss_decode(const X509_ALGOR *alg,
 					X509_ALGOR **pmaskHash)
 	{
-	const unsigned char *p;
+	const unsigned char* p;
 	int plen;
 	RSA_PSS_PARAMS *pss;
 
@@ -298,7 +303,7 @@
 	return pss;
 	}
 
-static int rsa_pss_param_print(BIO *bp, RSA_PSS_PARAMS *pss, 
+static int rsa_pss_param_print(BIO* bp, RSA_PSS_PARAMS *pss, 
 				X509_ALGOR *maskHash, int indent)
 	{
 	int rv = 0;
@@ -382,7 +387,7 @@
 
 	}
 
-static int rsa_sig_print(BIO *bp, const X509_ALGOR *sigalg,
+static int rsa_sig_print(BIO* bp, const X509_ALGOR *sigalg,
 					const ASN1_STRING *sig,
 					int indent, ASN1_PCTX *pctx)
 	{
@@ -407,7 +412,7 @@
 	return 1;
 	}
 
-static int rsa_pkey_ctrl(EVP_PKEY *pkey, int op, long arg1, void *arg2)
+static int rsa_pkey_ctrl(EVP_PKEY* pkey, int op, long arg1, void *arg2)
 	{
 	X509_ALGOR *alg = NULL;
 	switch (op)
@@ -459,7 +464,7 @@
 
 static int rsa_item_verify(EVP_MD_CTX *ctx, const ASN1_ITEM *it, void *asn,
 			X509_ALGOR *sigalg, ASN1_BIT_STRING *sig,
-			EVP_PKEY *pkey)
+			EVP_PKEY* pkey)
 	{
 	int rv = -1;
 	int saltlen;
@@ -580,7 +585,7 @@
 		RSA_PSS_PARAMS *pss = NULL;
 		X509_ALGOR *mgf1alg = NULL;
 		ASN1_STRING *os1 = NULL, *os2 = NULL;
-		EVP_PKEY *pk = EVP_PKEY_CTX_get0_pkey(pkctx);
+		EVP_PKEY* pk = EVP_PKEY_CTX_get0_pkey(pkctx);
 		int saltlen, rv = 0;
 		sigmd = EVP_MD_CTX_md(ctx);
 		if (EVP_PKEY_CTX_get_rsa_mgf1_md(pkctx, &mgf1md) <= 0)
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_asn1.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_asn1.c
--- openssl-1.0.1e/crypto/rsa/rsa_asn1.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_asn1.c	2013-04-24 22:11:07.022800020 +0800
@@ -1,4 +1,11 @@
 /* rsa_asn1.c */
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
+ *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
+ */
 /* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
  * project 2000.
  */
@@ -58,27 +65,63 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/x509.h>
 #include <openssl/asn1t.h>
 
 /* Override the default free and new methods */
-static int rsa_cb(int operation, ASN1_VALUE **pval, const ASN1_ITEM *it,
-								void *exarg)
+static int rsa_cb( int operation, ASN1_VALUE** pval,
+	const ASN1_ITEM* it, void* exarg )
 {
-	if(operation == ASN1_OP_NEW_PRE) {
-		*pval = (ASN1_VALUE *)RSA_new();
-		if(*pval) return 2;
-		return 0;
+	if (operation == ASN1_OP_NEW_PRE) {
+		return (*pval = (ASN1_VALUE*)RSA_new ()) ? 2 : 0;
 	} else if(operation == ASN1_OP_FREE_PRE) {
-		RSA_free((RSA *)*pval);
-		*pval = NULL;
+		RSA_free ((RSA*)*pval), *pval = NULL;
 		return 2;
 	}
 	return 1;
 }
 
+/*
+#define DECLARE_ASN1_ITEM(name) \
+	OPENSSL_EXTERN const ASN1_ITEM name##_it;
+
+#define ASN1_SEQUENCE_cb(tname, cb) \
+	static const ASN1_AUX tname##_aux = {NULL, 0, 0, 0, cb, 0}; \
+	ASN1_SEQUENCE(tname)
+
+#define ASN1_SEQUENCE(tname) \
+	static const ASN1_TEMPLATE tname##_seq_tt[]
+
+#define ASN1_SEQUENCE_END_cb(stname, tname) ASN1_SEQUENCE_END_ref(stname, tname)
+
+#define ASN1_SEQUENCE_END_ref(stname, tname) \
+	;\
+	ASN1_ITEM_start(tname) \
+		ASN1_ITYPE_SEQUENCE,\
+		V_ASN1_SEQUENCE,\
+		tname##_seq_tt,\
+		sizeof(tname##_seq_tt) / sizeof(ASN1_TEMPLATE),\
+		&tname##_aux,\
+		sizeof(stname),\
+		#stname \
+	ASN1_ITEM_end(tname)
+
+#define ASN1_ITEM_start(itname) \
+	OPENSSL_GLOBAL const ASN1_ITEM itname##_it = {
+
+#define ASN1_SIMPLE(stname, field, type) ASN1_EX_TYPE(0,0, stname, field, type)
+
+#define ASN1_EX_TYPE(flags, tag, stname, field, type) { \
+	(flags), (tag), offsetof(stname, field),\
+	#field, ASN1_ITEM_ref(type) }
+
+#define ASN1_ITEM_end(itname) \
+		};
+
+#define ASN1_ITEM_ref(iptr) (&(iptr##_it))
+#define ASN1_ITEM_rptr(ref) (&(ref##_it))
+
 ASN1_SEQUENCE_cb(RSAPrivateKey, rsa_cb) = {
 	ASN1_SIMPLE(RSA, version, LONG),
 	ASN1_SIMPLE(RSA, n, BIGNUM),
@@ -91,10 +134,60 @@
 	ASN1_SIMPLE(RSA, iqmp, BIGNUM)
 } ASN1_SEQUENCE_END_cb(RSA, RSAPrivateKey)
 
+IMPLEMENT_ASN1_ENCODE_FUNCTIONS_const_fname(RSA, RSAPrivateKey, RSAPrivateKey)
+
+OPENSSL_EXTERN const ASN1_ITEM MPZ_it;
+
+static const ASN1_AUX RSAPrivateKey_aux = { NULL, 0, 0, 0, rsa_cb, 0 };
+static const ASN1_TEMPLATE RSAPrivateKey_seq_tt[] = {
+	{ 0, 0, offsetof(RSA, version),	"version", &LONG_it },
+	{ 0, 0, offsetof(RSA, n), "n", &MPZ_it },
+	{ 0, 0, offsetof(RSA, e), "e", &MPZ_it },
+	{ 0, 0, offsetof(RSA, d), "d", &MPZ_it },
+	{ 0, 0, offsetof(RSA, p), "p", &MPZ_it },
+	{ 0, 0, offsetof(RSA, q), "q", &MPZ_it },
+	{ 0, 0, offsetof(RSA, dmp1), "dmp1", &MPZ_it },
+	{ 0, 0, offsetof(RSA, dmq1), "dmq1", &MPZ_it },
+	{ 0, 0, offsetof(RSA, iqmp), "iqmp", &MPZ_it },
+};
+OPENSSL_GLOBAL const ASN1_ITEM RSAPrivateKey_it = {
+	ASN1_ITYPE_SEQUENCE,
+	V_ASN1_SEQUENCE,
+	RSAPrivateKey_seq_tt,
+	sizeof(RSAPrivateKey_seq_tt) / sizeof(ASN1_TEMPLATE),
+	&RSAPrivateKey_aux,
+	sizeof(RSA),
+	"RSA"
+};
+
+RSA* d2i_RSAPrivateKey( RSA** a, const unsigned char** in, long len )
+{
+	return (RSA*)ASN1_item_d2i ((ASN1_VALUE**)a, in, len, &RSAPrivateKey_it);
+}
+
+int i2d_RSAPrivateKey( const RSA* a, unsigned char** out )
+{
+	return ASN1_item_i2d ((ASN1_VALUE*)a, out, &RSAPrivateKey_it);
+}
+*/
+
+DECLARE_ASN1_ITEM(MPZ)
+
+ASN1_SEQUENCE_cb(RSAPrivateKey, rsa_cb) = {
+	ASN1_SIMPLE(RSA, version, LONG),
+	ASN1_SIMPLE(RSA, n, MPZ),
+	ASN1_SIMPLE(RSA, e, MPZ),
+	ASN1_SIMPLE(RSA, d, MPZ),
+	ASN1_SIMPLE(RSA, p, MPZ),
+	ASN1_SIMPLE(RSA, q, MPZ),
+	ASN1_SIMPLE(RSA, dmp1, MPZ),
+	ASN1_SIMPLE(RSA, dmq1, MPZ),
+	ASN1_SIMPLE(RSA, iqmp, MPZ),
+} ASN1_SEQUENCE_END_cb(RSA, RSAPrivateKey)
 
 ASN1_SEQUENCE_cb(RSAPublicKey, rsa_cb) = {
-	ASN1_SIMPLE(RSA, n, BIGNUM),
-	ASN1_SIMPLE(RSA, e, BIGNUM),
+	ASN1_SIMPLE(RSA, n, MPZ),
+	ASN1_SIMPLE(RSA, e, MPZ),
 } ASN1_SEQUENCE_END_cb(RSA, RSAPublicKey)
 
 ASN1_SEQUENCE(RSA_PSS_PARAMS) = {
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_chk.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_chk.c
--- openssl-1.0.1e/crypto/rsa/rsa_chk.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_chk.c	2013-04-24 22:11:07.022800020 +0800
@@ -1,184 +1,84 @@
-/* crypto/rsa/rsa_chk.c  -*- Mode: C; c-file-style: "eay" -*- */
-/* ====================================================================
- * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    openssl-core@OpenSSL.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
+/* crypto/rsa/rsa_chk.c */
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
+ *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
-#include <openssl/bn.h>
 #include <openssl/err.h>
 #include <openssl/rsa.h>
 
 
-int RSA_check_key(const RSA *key)
-	{
-	BIGNUM *i, *j, *k, *l, *m;
-	BN_CTX *ctx;
-	int r;
-	int ret=1;
-	
-	i = BN_new();
-	j = BN_new();
-	k = BN_new();
-	l = BN_new();
-	m = BN_new();
-	ctx = BN_CTX_new();
-	if (i == NULL || j == NULL || k == NULL || l == NULL ||
-		m == NULL || ctx == NULL)
-		{
-		ret = -1;
-		RSAerr(RSA_F_RSA_CHECK_KEY, ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-	
+int RSA_check_key( const RSA* key )
+{
+	mpz_t t1, t2, t3, t4;
+	int r, ret = 1;
+
+	mpz_inits (t1, t2, t3, t4, NULL);
+
 	/* p prime? */
-	r = BN_is_prime_ex(key->p, BN_prime_checks, NULL, NULL);
-	if (r != 1)
-		{
-		ret = r;
-		if (r != 0)
-			goto err;
+	r = mpz_probab_prime_p (key->p, 25);
+	if (!r) {
+		ret = 0;
 		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_P_NOT_PRIME);
-		}
-	
+	}
+
 	/* q prime? */
-	r = BN_is_prime_ex(key->q, BN_prime_checks, NULL, NULL);
-	if (r != 1)
-		{
-		ret = r;
-		if (r != 0)
-			goto err;
+	r = mpz_probab_prime_p (key->q, 25);
+	if (!r) {
+		ret = 0;
 		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_Q_NOT_PRIME);
-		}
-	
+	}
+
 	/* n = p*q? */
-	r = BN_mul(i, key->p, key->q, ctx);
-	if (!r) { ret = -1; goto err; }
-	
-	if (BN_cmp(i, key->n) != 0)
-		{
+	mpz_mul (t1, key->p, key->q);
+	if (mpz_cmp (t1, key->n)) {
 		ret = 0;
 		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_N_DOES_NOT_EQUAL_P_Q);
-		}
-	
-	/* d*e = 1  mod lcm(p-1,q-1)? */
-
-	r = BN_sub(i, key->p, BN_value_one());
-	if (!r) { ret = -1; goto err; }
-	r = BN_sub(j, key->q, BN_value_one());
-	if (!r) { ret = -1; goto err; }
-
-	/* now compute k = lcm(i,j) */
-	r = BN_mul(l, i, j, ctx);
-	if (!r) { ret = -1; goto err; }
-	r = BN_gcd(m, i, j, ctx);
-	if (!r) { ret = -1; goto err; }
-	r = BN_div(k, NULL, l, m, ctx); /* remainder is 0 */
-	if (!r) { ret = -1; goto err; }
-
-	r = BN_mod_mul(i, key->d, key->e, k, ctx);
-	if (!r) { ret = -1; goto err; }
+	}
 
-	if (!BN_is_one(i))
-		{
+	/* d*e = 1 mod lcm(p-1,q-1)? */
+	mpz_sub_ui (t1, key->p, 1);
+	mpz_sub_ui (t2, key->q, 1);
+	mpz_mul (t3, t1, t2);
+	mpz_gcd (t4, t1, t2);
+	mpz_divexact (t1, t3, t4);
+	mpz_mul (t2, key->d, key->e);
+	mpz_mod (t3, t2, t1);
+	if (mpz_cmp_ui (t3, 1)) {
 		ret = 0;
 		RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_D_E_NOT_CONGRUENT_TO_1);
-		}
-	
-	if (key->dmp1 != NULL && key->dmq1 != NULL && key->iqmp != NULL)
-		{
-		/* dmp1 = d mod (p-1)? */
-		r = BN_sub(i, key->p, BN_value_one());
-		if (!r) { ret = -1; goto err; }
-
-		r = BN_mod(j, key->d, i, ctx);
-		if (!r) { ret = -1; goto err; }
+	}
 
-		if (BN_cmp(j, key->dmp1) != 0)
-			{
+	if (mpz_cmp_ui (key->dmp1, 0) && mpz_cmp_ui (key->dmq1, 0)
+			&& mpz_cmp_ui (key->iqmp, 0)) {
+		/* dmp1 = d mod (p-1)? */
+		mpz_sub_ui (t1, key->p, 1);
+		mpz_mod (t2, key->d, t1);
+		if (mpz_cmp (t2, key->dmp1)) {
 			ret = 0;
-			RSAerr(RSA_F_RSA_CHECK_KEY,
-				RSA_R_DMP1_NOT_CONGRUENT_TO_D);
-			}
-	
-		/* dmq1 = d mod (q-1)? */    
-		r = BN_sub(i, key->q, BN_value_one());
-		if (!r) { ret = -1; goto err; }
-	
-		r = BN_mod(j, key->d, i, ctx);
-		if (!r) { ret = -1; goto err; }
+			RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_DMP1_NOT_CONGRUENT_TO_D);
+		}
 
-		if (BN_cmp(j, key->dmq1) != 0)
-			{
+		/* dmq1 = d mod (q-1)? */    
+		mpz_sub_ui (t1, key->q, 1);
+		mpz_mod (t2, key->d, t1);
+		if (mpz_cmp (t2, key->dmq1)) {
 			ret = 0;
-			RSAerr(RSA_F_RSA_CHECK_KEY,
-				RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
-			}
-	
-		/* iqmp = q^-1 mod p? */
-		if(!BN_mod_inverse(i, key->q, key->p, ctx))
-			{
-			ret = -1;
-			goto err;
-			}
+			RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_DMQ1_NOT_CONGRUENT_TO_D);
+		}
 
-		if (BN_cmp(i, key->iqmp) != 0)
-			{
+		/* iqmp = q^-1 mod p? */
+		mpz_invert (t1, key->q, key->p);
+		if (mpz_cmp (t1, key->iqmp)) {
 			ret = 0;
-			RSAerr(RSA_F_RSA_CHECK_KEY,
-				RSA_R_IQMP_NOT_INVERSE_OF_Q);
-			}
+			RSAerr(RSA_F_RSA_CHECK_KEY, RSA_R_IQMP_NOT_INVERSE_OF_Q);
 		}
-
- err:
-	if (i != NULL) BN_free(i);
-	if (j != NULL) BN_free(j);
-	if (k != NULL) BN_free(k);
-	if (l != NULL) BN_free(l);
-	if (m != NULL) BN_free(m);
-	if (ctx != NULL) BN_CTX_free(ctx);
-	return (ret);
 	}
+
+ 	mpz_clears (t4, t3, t2, t1, NULL);
+
+	return ret;
+}
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_crpt.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_crpt.c
--- openssl-1.0.1e/crypto/rsa/rsa_crpt.c	2013-04-24 22:22:43.724799369 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_crpt.c	2013-04-24 22:11:07.034800019 +0800
@@ -1,59 +1,10 @@
-/* crypto/rsa/rsa_lib.c */
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+/* crypto/rsa/rsa_crpt.c */
+/* Copyright (C) 2013 Huang Le
  * All rights reserved.
  *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #define CAVIUM_DEV
@@ -62,7 +13,6 @@
 #include <openssl/crypto.h>
 #include "cryptlib.h"
 #include <openssl/lhash.h>
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 #ifndef OPENSSL_NO_ENGINE
@@ -74,38 +24,36 @@
 extern CspDmaMode global_dma_mode;
 extern int g_pkpdev;
 
-int RSA_size(const RSA *r)
-	{
-	return(BN_num_bytes(r->n));
-	}
+int RSA_size( const RSA* r )
+{
+	return (mpz_sizeinbase (r->n, 2) + 7) >> 3;
+}
 
-int RSA_public_encrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
+int RSA_public_encrypt( int flen, const unsigned char* from, unsigned char* to,
+	RSA* rsa, int padding )
+{
 #ifdef OPENSSL_FIPS
-	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
-			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
+	if (FIPS_mode () && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
+			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {
 		RSAerr(RSA_F_RSA_PUBLIC_ENCRYPT, RSA_R_NON_FIPS_RSA_METHOD);
 		return -1;
-		}
-#endif
-	return(rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding));
 	}
+#endif
+	return rsa->meth->rsa_pub_enc(flen, from, to, rsa, padding);
+}
 
-int RSA_private_encrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
+int RSA_private_encrypt( int flen, const unsigned char* from, unsigned char* to,
+	RSA* rsa, int padding )
+{
 #ifdef OPENSSL_FIPS
-	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
-			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
+	if (FIPS_mode () && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
+			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {
 		RSAerr(RSA_F_RSA_PRIVATE_ENCRYPT, RSA_R_NON_FIPS_RSA_METHOD);
 		return -1;
-		}
-#endif
-	return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
 	}
+#endif
+	return rsa->meth->rsa_priv_enc (flen, from, to, rsa, padding);
+}
 
 Uint32 RSA_check_status_cavium(Uint32 req_id, Uint32* ret_len)
 {
@@ -227,11 +175,11 @@
 		return 0;
 		}
 
-	modulus_size  = BN_num_bytes(rsa->n);
+	modulus_size  = (mpz_sizeinbase(rsa->n, 2) + 7) >> 3;
 	if ((modulus_size < 17) || (modulus_size > 512))
 		goto rsa_priv_dec_cleanup;
 
-	exponent_size = BN_num_bytes(rsa->d);
+	exponent_size = (mpz_sizeinbase(rsa->d, 2) + 7) >> 3;
 
 	modulus_b = alloca(modulus_size);
 	if (!modulus_b)
@@ -257,8 +205,8 @@
 		}
 	memcpy(from_b,from,modulus_size);
 
-	BN_bn2bin(rsa->n, modulus_b);
-	BN_bn2bin(rsa->d, exponent_b);
+	mpz_export(modulus_b, NULL, 1, 1, 0, 0, rsa->n);
+	mpz_export(exponent_b, NULL, 1, 1, 0, 0, rsa->d);
 
 	q_buf = (Uint8 *)malloc(modulus_size >> 1);
 	dmq1_buf = (Uint8 *)malloc(modulus_size >> 1);
@@ -273,11 +221,11 @@
 		goto rsa_priv_dec_cleanup;
 		}
 
-	BN_bn2bin(rsa->q, q_buf);
-	BN_bn2bin(rsa->dmq1, dmq1_buf);
-	BN_bn2bin(rsa->p, p_buf);
-	BN_bn2bin(rsa->dmp1, dmp1_buf);
-	BN_bn2bin(rsa->iqmp, iqmp_buf);
+	mpz_export(q_buf, NULL, 1, 1, 0, 0, rsa->q);
+	mpz_export(dmq1_buf, NULL, 1, 1, 0, 0, rsa->dmq1);
+	mpz_export(p_buf, NULL, 1, 1, 0, 0, rsa->p);
+	mpz_export(dmp1_buf, NULL, 1, 1, 0, 0, rsa->dmp1);
+	mpz_export(iqmp_buf, NULL, 1, 1, 0, 0, rsa->iqmp);
 
 	i = CavPkcs1v15CrtDec(nonblocking ? CAVIUM_NON_BLOCKING : CAVIUM_BLOCKING, BT2,
 			(Uint16)modulus_size, q_buf, dmq1_buf, p_buf, dmp1_buf, iqmp_buf,
@@ -305,159 +253,33 @@
 	return ret;
 }
 
-int RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
+int RSA_private_decrypt( int flen, const unsigned char* from, unsigned char* to,
+	RSA* rsa, int padding )
+{
 #ifdef OPENSSL_FIPS
-	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
-			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
+	if (FIPS_mode () && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
+			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {
 		RSAerr(RSA_F_RSA_PRIVATE_DECRYPT, RSA_R_NON_FIPS_RSA_METHOD);
 		return -1;
-		}
-#endif
-//Log ("RSA_private_decrypt %p %p %p", rsa, rsa->meth, rsa->meth->rsa_priv_dec);
-	return(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));
 	}
+#endif
+	return rsa->meth->rsa_priv_dec (flen, from, to, rsa, padding);
+}
 
-int RSA_public_decrypt(int flen, const unsigned char *from, unsigned char *to,
-	     RSA *rsa, int padding)
-	{
+int RSA_public_decrypt( int flen, const unsigned char* from, unsigned char* to,
+	RSA* rsa, int padding )
+{
 #ifdef OPENSSL_FIPS
-	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
-			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
+	if (FIPS_mode () && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
+			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {
 		RSAerr(RSA_F_RSA_PUBLIC_DECRYPT, RSA_R_NON_FIPS_RSA_METHOD);
 		return -1;
-		}
-#endif
-	return(rsa->meth->rsa_pub_dec(flen, from, to, rsa, padding));
-	}
-
-int RSA_flags(const RSA *r)
-	{
-	return((r == NULL)?0:r->meth->flags);
-	}
-
-void RSA_blinding_off(RSA *rsa)
-	{
-	if (rsa->blinding != NULL)
-		{
-		BN_BLINDING_free(rsa->blinding);
-		rsa->blinding=NULL;
-		}
-	rsa->flags &= ~RSA_FLAG_BLINDING;
-	rsa->flags |= RSA_FLAG_NO_BLINDING;
 	}
-
-int RSA_blinding_on(RSA *rsa, BN_CTX *ctx)
-	{
-	int ret=0;
-
-	if (rsa->blinding != NULL)
-		RSA_blinding_off(rsa);
-
-	rsa->blinding = RSA_setup_blinding(rsa, ctx);
-	if (rsa->blinding == NULL)
-		goto err;
-
-	rsa->flags |= RSA_FLAG_BLINDING;
-	rsa->flags &= ~RSA_FLAG_NO_BLINDING;
-	ret=1;
-err:
-	return(ret);
-	}
-
-static BIGNUM *rsa_get_public_exp(const BIGNUM *d, const BIGNUM *p,
-	const BIGNUM *q, BN_CTX *ctx)
-{
-	BIGNUM *ret = NULL, *r0, *r1, *r2;
-
-	if (d == NULL || p == NULL || q == NULL)
-		return NULL;
-
-	BN_CTX_start(ctx);
-	r0 = BN_CTX_get(ctx);
-	r1 = BN_CTX_get(ctx);
-	r2 = BN_CTX_get(ctx);
-	if (r2 == NULL)
-		goto err;
-
-	if (!BN_sub(r1, p, BN_value_one())) goto err;
-	if (!BN_sub(r2, q, BN_value_one())) goto err;
-	if (!BN_mul(r0, r1, r2, ctx)) goto err;
-
-	ret = BN_mod_inverse(NULL, d, r0, ctx);
-err:
-	BN_CTX_end(ctx);
-	return ret;
+#endif
+	return rsa->meth->rsa_pub_dec (flen, from, to, rsa, padding);
 }
 
-BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *in_ctx)
+int RSA_flags( const RSA* r )
 {
-	BIGNUM local_n;
-	BIGNUM *e,*n;
-	BN_CTX *ctx;
-	BN_BLINDING *ret = NULL;
-
-	if (in_ctx == NULL)
-		{
-		if ((ctx = BN_CTX_new()) == NULL) return 0;
-		}
-	else
-		ctx = in_ctx;
-
-	BN_CTX_start(ctx);
-	e  = BN_CTX_get(ctx);
-	if (e == NULL)
-		{
-		RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
-
-	if (rsa->e == NULL)
-		{
-		e = rsa_get_public_exp(rsa->d, rsa->p, rsa->q, ctx);
-		if (e == NULL)
-			{
-			RSAerr(RSA_F_RSA_SETUP_BLINDING, RSA_R_NO_PUBLIC_EXPONENT);
-			goto err;
-			}
-		}
-	else
-		e = rsa->e;
-
-	
-	if ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)
-		{
-		/* if PRNG is not properly seeded, resort to secret
-		 * exponent as unpredictable seed */
-		RAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0.0);
-		}
-
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		/* Set BN_FLG_CONSTTIME flag */
-		n = &local_n;
-		BN_with_flags(n, rsa->n, BN_FLG_CONSTTIME);
-		}
-	else
-		n = rsa->n;
-
-	ret = BN_BLINDING_create_param(NULL, e, n, ctx,
-			rsa->meth->bn_mod_exp, rsa->_method_mod_n);
-	if (ret == NULL)
-		{
-		RSAerr(RSA_F_RSA_SETUP_BLINDING, ERR_R_BN_LIB);
-		goto err;
-		}
-	CRYPTO_THREADID_current(BN_BLINDING_thread_id(ret));
-err:
-	BN_CTX_end(ctx);
-	if (in_ctx == NULL)
-		BN_CTX_free(ctx);
-	if(rsa->e == NULL)
-		BN_free(e);
-
-	return ret;
+	return (r == NULL) ? 0 : r->meth->flags;
 }
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_depr.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_depr.c
--- openssl-1.0.1e/crypto/rsa/rsa_depr.c	2013-04-24 22:21:55.207799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_depr.c	2013-04-24 22:11:07.034800019 +0800
@@ -1,56 +1,10 @@
 /* crypto/rsa/rsa_depr.c */
-/* ====================================================================
- * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    openssl-core@openssl.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
  *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 /* NB: This file contains deprecated functions (compatibility wrappers to the
@@ -59,43 +13,27 @@
 #include <stdio.h>
 #include <time.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 
 #ifdef OPENSSL_NO_DEPRECATED
 
-static void *dummy=&dummy;
+static void* dummy = &dummy;
 
 #else
 
-RSA *RSA_generate_key(int bits, unsigned long e_value,
-	     void (*callback)(int,int,void *), void *cb_arg)
-	{
-	BN_GENCB cb;
-	int i;
-	RSA *rsa = RSA_new();
-	BIGNUM *e = BN_new();
-
-	if(!rsa || !e) goto err;
-
-	/* The problem is when building with 8, 16, or 32 BN_ULONG,
-	 * unsigned long can be larger */
-	for (i=0; i<(int)sizeof(unsigned long)*8; i++)
-		{
-		if (e_value & (1UL<<i))
-			if (BN_set_bit(e,i) == 0)
-				goto err;
+RSA* RSA_generate_key( int bits, unsigned long e_value,
+	void (*callback)( int, int, void* ), void* cb_arg )
+{
+	RSA* rsa = RSA_new ();
+	if (rsa) {
+		mpz_t e;
+		mpz_init_set_ui (e, e_value);
+		if (!RSA_generate_key_ex (rsa, bits, e)) {
+			RSA_free (rsa), rsa = NULL;
 		}
-
-	BN_GENCB_set_old(&cb, callback, cb_arg);
-
-	if(RSA_generate_key_ex(rsa, bits, e, &cb)) {
-		BN_free(e);
-		return rsa;
-	}
-err:
-	if(e) BN_free(e);
-	if(rsa) RSA_free(rsa);
-	return 0;
+		mpz_clear (e);
 	}
+
+	return rsa;
+}
 #endif
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_eay.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_eay.c
--- openssl-1.0.1e/crypto/rsa/rsa_eay.c	2013-04-24 22:22:43.723799370 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_eay.c	2013-04-24 22:11:07.035800019 +0800
@@ -1,143 +1,38 @@
 /* crypto/rsa/rsa_eay.c */
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+/* Copyright (C) 2013 Huang Le
  * All rights reserved.
  *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
- */
-/* ====================================================================
- * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    openssl-core@openssl.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
- *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #define CAVIUM_DEV
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 
 #ifndef RSA_NULL
 
-static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa, BN_CTX *ctx);
-static int RSA_eay_init(RSA *rsa);
-static int RSA_eay_finish(RSA *rsa);
-static RSA_METHOD rsa_pkcs1_eay_meth={
-	"Eric Young's PKCS#1 RSA",
+static int RSA_eay_public_encrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding);
+static int RSA_eay_private_encrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+static int RSA_eay_public_decrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+static int RSA_eay_private_decrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+static int RSA_eay_mod_exp( mpz_t r0, const mpz_t i, RSA* rsa );
+static int RSA_eay_init( RSA* rsa );
+static int RSA_eay_finish( RSA* rsa );
+static RSA_METHOD rsa_pkcs1_eay_meth = {
+	"Huang Le's PKCS#1 RSA",
 	RSA_eay_public_encrypt,
 	RSA_eay_public_decrypt, /* signature verification */
 	RSA_eay_private_encrypt, /* signing */
 	RSA_eay_private_decrypt,
-	RSA_eay_mod_exp,
-	BN_mod_exp_mont, /* XXX probably we should not use Montgomery if  e == 3 */
 	RSA_eay_init,
 	RSA_eay_finish,
 	0, /* flags */
@@ -145,7 +40,7 @@
 	0, /* rsa_sign */
 	0, /* rsa_verify */
 	NULL /* rsa_keygen */
-	};
+};
 
 //static unsigned int iLog = 0;
 
@@ -210,760 +105,352 @@
 	}
 }
 */
-const RSA_METHOD *RSA_PKCS1_SSLeay(void)
-	{
-	return(&rsa_pkcs1_eay_meth);
-	}
+const RSA_METHOD* RSA_PKCS1_SSLeay()
+{
+	return &rsa_pkcs1_eay_meth;
+}
 
-static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
-	BIGNUM *f,*ret;
-	int i,j,k,num=0,r= -1;
-	unsigned char *buf=NULL;
-	BN_CTX *ctx=NULL;
-//Log ("RSA_eay_public_encrypt %p", rsa);
-	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
-		{
+static int RSA_eay_public_encrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
+	mpz_t f, ret;
+	size_t i;
+	int j, num = mpz_sizeinbase (rsa->n, 2), r = -1;
+	unsigned char* buf;
+
+	if (num > OPENSSL_RSA_MAX_MODULUS_BITS) {
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
 		return -1;
-		}
-
-	if (BN_ucmp(rsa->n, rsa->e) <= 0)
-		{
+	}
+	if (mpz_cmp (rsa->n, rsa->e) <= 0) {
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
 		return -1;
-		}
-
+	}
 	/* for large moduli, enforce exponent limit */
-	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
-		{
-		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
-			{
-			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
-			return -1;
-			}
-		}
-	
-	if ((ctx=BN_CTX_new()) == NULL) goto err;
-	BN_CTX_start(ctx);
-	f = BN_CTX_get(ctx);
-	ret = BN_CTX_get(ctx);
-	num=BN_num_bytes(rsa->n);
-	buf = OPENSSL_malloc(num);
-	if (!f || !ret || !buf)
-		{
+	if (num > OPENSSL_RSA_SMALL_MODULUS_BITS &&
+		mpz_sizeinbase (rsa->e, 2) > OPENSSL_RSA_MAX_PUBEXP_BITS) {
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
+		return -1;
+	}
+
+	num = (num + 7) >> 3;
+	buf = OPENSSL_malloc (num);
+	if (!buf) {
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
+		return -1;
+	}
 
-	switch (padding)
-		{
+	switch (padding) {
 	case RSA_PKCS1_PADDING:
-		i=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);
+		j = RSA_padding_add_PKCS1_type_2 (buf, num, from, flen);
 		break;
 #ifndef OPENSSL_NO_SHA
 	case RSA_PKCS1_OAEP_PADDING:
-	        i=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);
+		j = RSA_padding_add_PKCS1_OAEP (buf, num, from, flen, NULL, 0);
 		break;
 #endif
 	case RSA_SSLV23_PADDING:
-		i=RSA_padding_add_SSLv23(buf,num,from,flen);
+		j = RSA_padding_add_SSLv23 (buf, num, from, flen);
 		break;
 	case RSA_NO_PADDING:
-		i=RSA_padding_add_none(buf,num,from,flen);
+		j = RSA_padding_add_none (buf, num, from, flen);
 		break;
 	default:
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
-		goto err;
-		}
-	if (i <= 0) goto err;
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
+		return -1;
+	}
+	if (j <= 0) {
+		return -1;
+	}
 
-	if (BN_bin2bn(buf,num,f) == NULL) goto err;
-	
-	if (BN_ucmp(f, rsa->n) >= 0)
-		{
+	mpz_inits (f, ret, NULL);
+
+	mpz_import (f, num, 1, 1, 0, 0, buf);
+	if (mpz_cmp (f, rsa->n) >= 0) {
 		/* usually the padding functions would catch this */
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
 		goto err;
-		}
-
-	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
-		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
-			goto err;
+	}
 
-	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
-		rsa->_method_mod_n)) goto err;
+	mpz_powm (ret, f, rsa->e, rsa->n);
 
 	/* put in leading 0 bytes if the number is less than the
 	 * length of the modulus */
-	j=BN_num_bytes(ret);
-	i=BN_bn2bin(ret,&(to[num-j]));
-	for (k=0; k<(num-i); k++)
-		to[k]=0;
+	j = (mpz_sizeinbase (ret, 2) + 7) >> 3;
+	mpz_export (to + num - j, &i, 1, 1, 0, 0, ret);
+	for (j = 0; j < num - i; to[j++] = 0);
 
-	r=num;
-err:
-	if (ctx != NULL)
-		{
-		BN_CTX_end(ctx);
-		BN_CTX_free(ctx);
-		}
-	if (buf != NULL) 
-		{
-		OPENSSL_cleanse(buf,num);
-		OPENSSL_free(buf);
-		}
-	return(r);
-	}
-
-static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
-{
-	BN_BLINDING *ret;
-	int got_write_lock = 0;
-	CRYPTO_THREADID cur;
-//Log ("rsa_get_blinding %p", rsa);
-	CRYPTO_r_lock(CRYPTO_LOCK_RSA);
+	r = num;
 
-	if (rsa->blinding == NULL)
-		{
-		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
-		CRYPTO_w_lock(CRYPTO_LOCK_RSA);
-		got_write_lock = 1;
-
-		if (rsa->blinding == NULL)
-			rsa->blinding = RSA_setup_blinding(rsa, ctx);
-		}
-
-	ret = rsa->blinding;
-	if (ret == NULL)
-		goto err;
-
-	CRYPTO_THREADID_current(&cur);
-	if (!CRYPTO_THREADID_cmp(&cur, BN_BLINDING_thread_id(ret)))
-		{
-		/* rsa->blinding is ours! */
+err:
 
-		*local = 1;
-		}
-	else
-		{
-		/* resort to rsa->mt_blinding instead */
+	mpz_clears (ret, f, NULL);
 
-		*local = 0; /* instructs rsa_blinding_convert(), rsa_blinding_invert()
-		             * that the BN_BLINDING is shared, meaning that accesses
-		             * require locks, and that the blinding factor must be
-		             * stored outside the BN_BLINDING
-		             */
-
-		if (rsa->mt_blinding == NULL)
-			{
-			if (!got_write_lock)
-				{
-				CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
-				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
-				got_write_lock = 1;
-				}
-			
-			if (rsa->mt_blinding == NULL)
-				rsa->mt_blinding = RSA_setup_blinding(rsa, ctx);
-			}
-		ret = rsa->mt_blinding;
-		}
+	OPENSSL_cleanse (buf, num);
+	OPENSSL_free (buf);
 
- err:
-	if (got_write_lock)
-		CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
-	else
-		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
-	return ret;
+	return r;
 }
 
-static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
-	BN_CTX *ctx)
-	{
-//Log ("rsa_blinding_convert");
-	if (unblind == NULL)
-		/* Local blinding: store the unblinding factor
-		 * in BN_BLINDING. */
-		return BN_BLINDING_convert_ex(f, NULL, b, ctx);
-	else
-		{
-		/* Shared blinding: store the unblinding factor
-		 * outside BN_BLINDING. */
-		int ret;
-		CRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING);
-		ret = BN_BLINDING_convert_ex(f, unblind, b, ctx);
-		CRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING);
-		return ret;
-		}
-	}
-
-static int rsa_blinding_invert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
-	BN_CTX *ctx)
-	{
-	/* For local blinding, unblind is set to NULL, and BN_BLINDING_invert_ex
-	 * will use the unblinding factor stored in BN_BLINDING.
-	 * If BN_BLINDING is shared between threads, unblind must be non-null:
-	 * BN_BLINDING_invert_ex will then use the local unblinding factor,
-	 * and will only read the modulus from BN_BLINDING.
-	 * In both cases it's safe to access the blinding without a lock.
-	 */
-//Log ("rsa_blinding_invert");
-	return BN_BLINDING_invert_ex(f, unblind, b, ctx);
+/* signing */
+static int RSA_eay_private_encrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
+	mpz_t f, ret;
+	size_t i;
+	int j, num = (mpz_sizeinbase (rsa->n, 2) + 7) >> 3, r = -1;
+	unsigned char* buf;
+
+	buf = OPENSSL_malloc (num);
+	if (!buf) {
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
+		return -1;
 	}
 
-/* signing */
-static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
-	BIGNUM *f, *ret, *res;
-	int i,j,k,num=0,r= -1;
-	unsigned char *buf=NULL;
-	BN_CTX *ctx=NULL;
-	int local_blinding = 0;
-	/* Used only if the blinding structure is shared. A non-NULL unblind
-	 * instructs rsa_blinding_convert() and rsa_blinding_invert() to store
-	 * the unblinding factor outside the blinding structure. */
-	BIGNUM *unblind = NULL;
-	BN_BLINDING *blinding = NULL;
-//Log ("RSA_eay_private_encrypt %p", rsa);
-	if ((ctx=BN_CTX_new()) == NULL) goto err;
-	BN_CTX_start(ctx);
-	f   = BN_CTX_get(ctx);
-	ret = BN_CTX_get(ctx);
-	num = BN_num_bytes(rsa->n);
-	buf = OPENSSL_malloc(num);
-	if(!f || !ret || !buf)
-		{
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
+	mpz_inits (f, ret, NULL);
 
-	switch (padding)
-		{
+	switch (padding) {
 	case RSA_PKCS1_PADDING:
-		i=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);
+		i = RSA_padding_add_PKCS1_type_1 (buf, num, from, flen);
 		break;
 	case RSA_X931_PADDING:
-		i=RSA_padding_add_X931(buf,num,from,flen);
+		i = RSA_padding_add_X931 (buf, num, from, flen);
 		break;
 	case RSA_NO_PADDING:
-		i=RSA_padding_add_none(buf,num,from,flen);
+		i = RSA_padding_add_none (buf, num, from, flen);
 		break;
 	case RSA_SSLV23_PADDING:
 	default:
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
 		goto err;
-		}
-	if (i <= 0) goto err;
-
-	if (BN_bin2bn(buf,num,f) == NULL) goto err;
+	}
+	if (i <= 0) {
+		goto err;
+	}
 
-	if (BN_ucmp(f, rsa->n) >= 0)
-		{	
+	mpz_import (f, num, 1, 1, 0, 0, buf);
+	if (mpz_cmp (f, rsa->n) >= 0) {	
 		/* usually the padding functions would catch this */
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
 		goto err;
-		}
-
-	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
-		{
-		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
-		if (blinding == NULL)
-			{
-			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		}
-	
-	if (blinding != NULL)
-		{
-		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))
-			{
-			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-		if (!rsa_blinding_convert(blinding, f, unblind, ctx))
-			goto err;
-		}
-
-	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
-		((rsa->p != NULL) &&
-		(rsa->q != NULL) &&
-		(rsa->dmp1 != NULL) &&
-		(rsa->dmq1 != NULL) &&
-		(rsa->iqmp != NULL)) )
-		{
-		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
-		}
-	else
-		{
-		BIGNUM local_d;
-		BIGNUM *d = NULL;
-		
-		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-			{
-			BN_init(&local_d);
-			d = &local_d;
-			BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
-			}
-		else
-			d= rsa->d;
-
-		if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
-			if(!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
-				goto err;
-
-		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
-				rsa->_method_mod_n)) goto err;
-		}
+	}
 
-	if (blinding)
-		if (!rsa_blinding_invert(blinding, ret, unblind, ctx))
-			goto err;
+	if ((rsa->flags & RSA_FLAG_EXT_PKEY) ||
+		(mpz_cmp_ui (rsa->p, 0) && mpz_cmp_ui (rsa->q, 0) &&
+		mpz_cmp_ui (rsa->dmp1, 0) && mpz_cmp_ui (rsa->dmq1, 0) &&
+		mpz_cmp_ui (rsa->iqmp, 0))) {
+		RSA_eay_mod_exp (ret, f, rsa);
+	} else {
+		mpz_powm (ret, f, rsa->d, rsa->n);
+	}
 
-	if (padding == RSA_X931_PADDING)
-		{
-		BN_sub(f, rsa->n, ret);
-		if (BN_cmp(ret, f))
-			res = f;
-		else
-			res = ret;
+	if (padding == RSA_X931_PADDING) {
+		mpz_sub (f, rsa->n, ret);
+		if (mpz_cmp (ret, f)) {
+			mpz_set (ret, f);
 		}
-	else
-		res = ret;
+	}
 
 	/* put in leading 0 bytes if the number is less than the
 	 * length of the modulus */
-	j=BN_num_bytes(res);
-	i=BN_bn2bin(res,&(to[num-j]));
-	for (k=0; k<(num-i); k++)
-		to[k]=0;
+	j = (mpz_sizeinbase (ret, 2) + 7) >> 3;
+	mpz_export (to + num - j, &i, 1, 1, 0, 0, ret);
+	for (j = 0; j < num - i; to[j++] = 0);
+
+	r = num;
 
-	r=num;
 err:
-	if (ctx != NULL)
-		{
-		BN_CTX_end(ctx);
-		BN_CTX_free(ctx);
-		}
-	if (buf != NULL)
-		{
-		OPENSSL_cleanse(buf,num);
-		OPENSSL_free(buf);
-		}
-	return(r);
-	}
 
-static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
-	BIGNUM *f, *ret;
-	int j,num=0,r= -1;
-	unsigned char *p;
-	unsigned char *buf=NULL;
-	BN_CTX *ctx=NULL;
-	int local_blinding = 0;
-	/* Used only if the blinding structure is shared. A non-NULL unblind
-	 * instructs rsa_blinding_convert() and rsa_blinding_invert() to store
-	 * the unblinding factor outside the blinding structure. */
-	BIGNUM *unblind = NULL;
-	BN_BLINDING *blinding = NULL;
-//Log ("RSA_eay_private_decrypt %p, %p", rsa, RSA_eay_init);
-	if((ctx = BN_CTX_new()) == NULL) goto err;
-	BN_CTX_start(ctx);
-	f   = BN_CTX_get(ctx);
-	ret = BN_CTX_get(ctx);
-	num = BN_num_bytes(rsa->n);
-	buf = OPENSSL_malloc(num);
-	if(!f || !ret || !buf)
-		{
+	mpz_clears (ret, f, NULL);
 
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
+	OPENSSL_cleanse (buf, num);
+	OPENSSL_free (buf);
+
+	return r;
+}
+
+static int RSA_eay_private_decrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
+	mpz_t f, ret;
+	size_t i;
+	int num = (mpz_sizeinbase (rsa->n, 2) + 7) >> 3, r = -1;
+	unsigned char* buf;
 
 	/* This check was for equality but PGP does evil things
 	 * and chops off the top '0' bytes */
-	if (flen > num)
-		{
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
-		goto err;
-		}
+	if (flen > num) {
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+		return -1;
+	}
 
-	/* make data into a big number */
-	if (BN_bin2bn(from,(int)flen,f) == NULL) goto err;
+	buf = OPENSSL_malloc (num);
+	if (!buf) {
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
+		return -1;
+	}
 
-	if (BN_ucmp(f, rsa->n) >= 0)
-		{
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
-		goto err;
-		}
+	mpz_inits (f, ret, NULL);
 
-	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
-		{
-		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
-		if (blinding == NULL)
-			{
-			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);
-			goto err;
-			}
-		}
-	
-	if (blinding != NULL)
-		{
-		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))
-			{
-			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
-			goto err;
-			}
-		if (!rsa_blinding_convert(blinding, f, unblind, ctx))
-			goto err;
-		}
+	/* make data into a big number */
+	mpz_import (f, flen, 1, 1, 0, 0, from);
+	if (mpz_cmp (f, rsa->n) >= 0) {
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+	}
 
 	/* do the decrypt */
-	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
-		((rsa->p != NULL) &&
-		(rsa->q != NULL) &&
-		(rsa->dmp1 != NULL) &&
-		(rsa->dmq1 != NULL) &&
-		(rsa->iqmp != NULL)) )
-		{
-//Log ("RSA_eay_private_decrypt CRT");
-		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
-		}
-	else
-		{
-//Log ("RSA_eay_private_decrypt OLD");
-		BIGNUM local_d;
-		BIGNUM *d = NULL;
-		
-		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-			{
-			d = &local_d;
-			BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
-			}
-		else
-			d = rsa->d;
-
-		if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
-			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
-				goto err;
-		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
-				rsa->_method_mod_n))
-		  goto err;
-		}
-
-	if (blinding)
-		if (!rsa_blinding_invert(blinding, ret, unblind, ctx))
-			goto err;
+	if ((rsa->flags & RSA_FLAG_EXT_PKEY) ||
+		(mpz_cmp_ui (rsa->p, 0) && mpz_cmp_ui (rsa->q, 0) &&
+		mpz_cmp_ui (rsa->dmp1, 0) && mpz_cmp_ui (rsa->dmq1, 0) &&
+		mpz_cmp_ui (rsa->iqmp, 0))) {
+		RSA_eay_mod_exp (ret, f, rsa);
+	} else {
+		mpz_powm (ret, f, rsa->d, rsa->n);
+	}
 
-	p=buf;
-	j=BN_bn2bin(ret,p); /* j is only used with no-padding mode */
+	mpz_export (buf, &i, 1, 1, 0, 0, ret);
 
-	switch (padding)
-		{
+	switch (padding) {
 	case RSA_PKCS1_PADDING:
-		r=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);
+		r = RSA_padding_check_PKCS1_type_2 (to, num, buf, i, num);
 		break;
 #ifndef OPENSSL_NO_SHA
-        case RSA_PKCS1_OAEP_PADDING:
-	        r=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);
-                break;
+	case RSA_PKCS1_OAEP_PADDING:
+		r = RSA_padding_check_PKCS1_OAEP (to, num, buf, i, num, NULL, 0);
+		break;
 #endif
  	case RSA_SSLV23_PADDING:
-		r=RSA_padding_check_SSLv23(to,num,buf,j,num);
+		r = RSA_padding_check_SSLv23 (to, num, buf, i, num);
 		break;
 	case RSA_NO_PADDING:
-		r=RSA_padding_check_none(to,num,buf,j,num);
+		r = RSA_padding_check_none (to, num, buf, i, num);
 		break;
 	default:
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
 		goto err;
-		}
-	if (r < 0)
-		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
+	}
+	if (r < 0) {
+		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
+	}
 
 err:
-	if (ctx != NULL)
-		{
-		BN_CTX_end(ctx);
-		BN_CTX_free(ctx);
-		}
-	if (buf != NULL)
-		{
-		OPENSSL_cleanse(buf,num);
-		OPENSSL_free(buf);
-		}
-	return(r);
-	}
+
+	mpz_clears (ret, f, NULL);
+
+	OPENSSL_cleanse (buf, num);
+	OPENSSL_free (buf);
+
+	return r;
+}
 
 /* signature verification */
-static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
-	BIGNUM *f,*ret;
-	int i,num=0,r= -1;
-	unsigned char *p;
-	unsigned char *buf=NULL;
-	BN_CTX *ctx=NULL;
-//Log ("RSA_eay_public_decrypt %p", rsa);
-	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
-		{
+static int RSA_eay_public_decrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
+	mpz_t f, ret;
+	size_t i;
+	int num = mpz_sizeinbase (rsa->n, 2), r = -1;
+	unsigned char* buf;
+
+	if (num > OPENSSL_RSA_MAX_MODULUS_BITS) {
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
 		return -1;
-		}
-
-	if (BN_ucmp(rsa->n, rsa->e) <= 0)
-		{
+	}
+	if (mpz_cmp (rsa->n, rsa->e) <= 0) {
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
 		return -1;
-		}
+	}
 
 	/* for large moduli, enforce exponent limit */
-	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
-		{
-		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
-			{
-			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
-			return -1;
-			}
-		}
-	
-	if((ctx = BN_CTX_new()) == NULL) goto err;
-	BN_CTX_start(ctx);
-	f = BN_CTX_get(ctx);
-	ret = BN_CTX_get(ctx);
-	num=BN_num_bytes(rsa->n);
-	buf = OPENSSL_malloc(num);
-	if(!f || !ret || !buf)
-		{
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);
-		goto err;
-		}
+	if (num > OPENSSL_RSA_SMALL_MODULUS_BITS &&
+		mpz_sizeinbase (rsa->e, 2) > OPENSSL_RSA_MAX_PUBEXP_BITS) {
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
+		return -1;
+	}
 
 	/* This check was for equality but PGP does evil things
 	 * and chops off the top '0' bytes */
-	if (flen > num)
-		{
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
-		goto err;
-		}
-
-	if (BN_bin2bn(from,flen,f) == NULL) goto err;
+	num = (num + 7) >> 3;
+	if (flen > num) {
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_DATA_GREATER_THAN_MOD_LEN);
+		return -1;
+	}
 
-	if (BN_ucmp(f, rsa->n) >= 0)
-		{
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
-		goto err;
-		}
+	buf = OPENSSL_malloc (num);
+	if (!buf) {
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, ERR_R_MALLOC_FAILURE);
+		return -1;
+	}
 
-	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
-		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
-			goto err;
+	mpz_inits (f, ret, NULL);
 
-	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
-		rsa->_method_mod_n)) goto err;
+	mpz_import (f, flen, 1, 1, 0, 0, from);
+	if (mpz_cmp (f, rsa->n) >= 0) {
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
+		goto err;
+	}
 
-	if ((padding == RSA_X931_PADDING) && ((ret->d[0] & 0xf) != 12))
-		if (!BN_sub(ret, rsa->n, ret)) goto err;
+	mpz_powm (ret, f, rsa->e, rsa->n);
 
-	p=buf;
-	i=BN_bn2bin(ret,p);
+	if ((padding == RSA_X931_PADDING) && (mpz_fdiv_ui (ret, 16) != 12)) {
+		mpz_sub (ret, rsa->n, ret);
+	}
+	mpz_export (buf, &i, 1, 1, 0, 0, ret);
 
-	switch (padding)
-		{
+	switch (padding) {
 	case RSA_PKCS1_PADDING:
-		r=RSA_padding_check_PKCS1_type_1(to,num,buf,i,num);
+		r = RSA_padding_check_PKCS1_type_1 (to, num, buf, i, num);
 		break;
 	case RSA_X931_PADDING:
-		r=RSA_padding_check_X931(to,num,buf,i,num);
+		r = RSA_padding_check_X931 (to, num, buf, i, num);
 		break;
 	case RSA_NO_PADDING:
-		r=RSA_padding_check_none(to,num,buf,i,num);
+		r = RSA_padding_check_none (to, num, buf, i, num);
 		break;
 	default:
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_UNKNOWN_PADDING_TYPE);
 		goto err;
-		}
-	if (r < 0)
-		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
-
-err:
-	if (ctx != NULL)
-		{
-		BN_CTX_end(ctx);
-		BN_CTX_free(ctx);
-		}
-	if (buf != NULL)
-		{
-		OPENSSL_cleanse(buf,num);
-		OPENSSL_free(buf);
-		}
-	return(r);
+	}
+	if (r < 0) {
+		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_PADDING_CHECK_FAILED);
 	}
 
-static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
-	{
-	BIGNUM *r1,*m1,*vrfy;
-	BIGNUM local_dmp1,local_dmq1,local_c,local_r1;
-	BIGNUM *dmp1,*dmq1,*c,*pr1;
-	int ret=0;
-//Log ("RSA_eay_mod_exp %p", rsa);
-	BN_CTX_start(ctx);
-	r1 = BN_CTX_get(ctx);
-	m1 = BN_CTX_get(ctx);
-	vrfy = BN_CTX_get(ctx);
-
-	{
-		BIGNUM local_p, local_q;
-		BIGNUM *p = NULL, *q = NULL;
-
-		/* Make sure BN_mod_inverse in Montgomery intialization uses the
-		 * BN_FLG_CONSTTIME flag (unless RSA_FLAG_NO_CONSTTIME is set)
-		 */
-		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-			{
-			BN_init(&local_p);
-			p = &local_p;
-			BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);
-
-			BN_init(&local_q);
-			q = &local_q;
-			BN_with_flags(q, rsa->q, BN_FLG_CONSTTIME);
-			}
-		else
-			{
-			p = rsa->p;
-			q = rsa->q;
-			}
+err:
 
-		if (rsa->flags & RSA_FLAG_CACHE_PRIVATE)
-			{
-			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p, CRYPTO_LOCK_RSA, p, ctx))
-				goto err;
-			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q, CRYPTO_LOCK_RSA, q, ctx))
-				goto err;
-			}
-	}
+	mpz_clears (ret, f, NULL);
 
-	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
-		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
-			goto err;
+	OPENSSL_cleanse (buf, num);
+	OPENSSL_free (buf);
 
-	/* compute I mod q */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		c = &local_c;
-		BN_with_flags(c, I, BN_FLG_CONSTTIME);
-		if (!BN_mod(r1,c,rsa->q,ctx)) goto err;
-		}
-	else
-		{
-		if (!BN_mod(r1,I,rsa->q,ctx)) goto err;
-		}
+	return r;
+}
 
-	/* compute r1^dmq1 mod q */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		dmq1 = &local_dmq1;
-		BN_with_flags(dmq1, rsa->dmq1, BN_FLG_CONSTTIME);
-		}
-	else
-		dmq1 = rsa->dmq1;
-	if (!rsa->meth->bn_mod_exp(m1,r1,dmq1,rsa->q,ctx,
-		rsa->_method_mod_q)) goto err;
+static int RSA_eay_mod_exp( mpz_t ret, const mpz_t f, RSA* rsa )
+{
+	mpz_t o, pr, qr;
 
-	/* compute I mod p */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		c = &local_c;
-		BN_with_flags(c, I, BN_FLG_CONSTTIME);
-		if (!BN_mod(r1,c,rsa->p,ctx)) goto err;
-		}
-	else
-		{
-		if (!BN_mod(r1,I,rsa->p,ctx)) goto err;
-		}
+	mpz_inits (o, pr, qr, NULL);
 
-	/* compute r1^dmp1 mod p */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		dmp1 = &local_dmp1;
-		BN_with_flags(dmp1, rsa->dmp1, BN_FLG_CONSTTIME);
-		}
-	else
-		dmp1 = rsa->dmp1;
-	if (!rsa->meth->bn_mod_exp(r0,r1,dmp1,rsa->p,ctx,
-		rsa->_method_mod_p)) goto err;
-
-	if (!BN_sub(r0,r0,m1)) goto err;
-	/* This will help stop the size of r0 increasing, which does
-	 * affect the multiply if it optimised for a power of 2 size */
-	if (BN_is_negative(r0))
-		if (!BN_add(r0,r0,rsa->p)) goto err;
+	if (!rsa->swdmp1) {
+		mpz_create_swt (&rsa->swdmp1, rsa->dmp1);
+	}
+	mpz_powm_swt (pr, f, rsa->swdmp1, rsa->p);
+	if (!rsa->swdmq1) {
+		mpz_create_swt (&rsa->swdmq1, rsa->dmq1);
+	}
+	mpz_powm_swt (qr, f, rsa->swdmq1, rsa->q);
 
-	if (!BN_mul(r1,r0,rsa->iqmp,ctx)) goto err;
+	mpz_sub (o, pr, qr);
+	mpz_mul (pr, o, rsa->iqmp);
+	mpz_mod (o, pr, rsa->p);
+	mpz_mul (pr, o, rsa->q);
+	mpz_add (ret, qr, pr);
 
-	/* Turn BN_FLG_CONSTTIME flag on before division operation */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		pr1 = &local_r1;
-		BN_with_flags(pr1, r1, BN_FLG_CONSTTIME);
-		}
-	else
-		pr1 = r1;
-	if (!BN_mod(r0,pr1,rsa->p,ctx)) goto err;
-
-	/* If p < q it is occasionally possible for the correction of
-	 * adding 'p' if r0 is negative above to leave the result still
-	 * negative. This can break the private key operations: the following
-	 * second correction should *always* correct this rare occurrence.
-	 * This will *never* happen with OpenSSL generated keys because
-	 * they ensure p > q [steve]
-	 */
-	if (BN_is_negative(r0))
-		if (!BN_add(r0,r0,rsa->p)) goto err;
-	if (!BN_mul(r1,r0,rsa->q,ctx)) goto err;
-	if (!BN_add(r0,r1,m1)) goto err;
+	mpz_clears (qr, pr, o, NULL);
 
-	if (rsa->e && rsa->n)
-		{
-		if (!rsa->meth->bn_mod_exp(vrfy,r0,rsa->e,rsa->n,ctx,rsa->_method_mod_n)) goto err;
-		/* If 'I' was greater than (or equal to) rsa->n, the operation
-		 * will be equivalent to using 'I mod n'. However, the result of
-		 * the verify will *always* be less than 'n' so we don't check
-		 * for absolute equality, just congruency. */
-		if (!BN_sub(vrfy, vrfy, I)) goto err;
-		if (!BN_mod(vrfy, vrfy, rsa->n, ctx)) goto err;
-		if (BN_is_negative(vrfy))
-			if (!BN_add(vrfy, vrfy, rsa->n)) goto err;
-		if (!BN_is_zero(vrfy))
-			{
-			/* 'I' and 'vrfy' aren't congruent mod n. Don't leak
-			 * miscalculated CRT output, just do a raw (slower)
-			 * mod_exp and return that instead. */
-
-			BIGNUM local_d;
-			BIGNUM *d = NULL;
-		
-			if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-				{
-				d = &local_d;
-				BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
-				}
-			else
-				d = rsa->d;
-			if (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,
-						   rsa->_method_mod_n)) goto err;
-			}
-		}
-	ret=1;
-err:
-	BN_CTX_end(ctx);
-	return(ret);
-	}
+	return 1;
+}
 
 Uint32 CavInitialize(CspDmaMode dma_mode)
 	{
@@ -1008,13 +495,6 @@
 static int RSA_eay_finish(RSA *rsa)
 	{
 //Log ("RSA_eay_finish %p", rsa);
-	if (rsa->_method_mod_n != NULL)
-		BN_MONT_CTX_free(rsa->_method_mod_n);
-	if (rsa->_method_mod_p != NULL)
-		BN_MONT_CTX_free(rsa->_method_mod_p);
-	if (rsa->_method_mod_q != NULL)
-		BN_MONT_CTX_free(rsa->_method_mod_q);
-
 	CavShutdown();
 
 	return(1);
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_err.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_err.c
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_gen.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_gen.c
--- openssl-1.0.1e/crypto/rsa/rsa_gen.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_gen.c	2013-04-24 22:11:07.035800019 +0800
@@ -1,234 +1,161 @@
 /* crypto/rsa/rsa_gen.c */
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+/* Copyright (C) 2013 Huang Le
  * All rights reserved.
  *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 
-/* NB: these functions have been "upgraded", the deprecated versions (which are
- * compatibility wrappers using these functions) are in rsa_depr.c.
- * - Geoff
- */
-
 #include <stdio.h>
-#include <time.h>
+#include <fcntl.h>
+#include <sys/time.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #ifdef OPENSSL_FIPS
 #include <openssl/fips.h>
 #endif
 
-static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb);
+static int rsa_builtin_keygen( RSA* rsa, int bits, mpz_t e );
 
 /* NB: this wrapper would normally be placed in rsa_lib.c and the static
  * implementation would probably be in rsa_eay.c. Nonetheless, is kept here so
  * that we don't introduce a new linker dependency. Eg. any application that
  * wasn't previously linking object code related to key-generation won't have to
  * now just because key-generation is part of RSA_METHOD. */
-int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)
-	{
+int RSA_generate_key_ex( RSA* rsa, int bits, mpz_t e )
+{
 #ifdef OPENSSL_FIPS
+
 	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
-			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
-		{
+			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)) {
 		RSAerr(RSA_F_RSA_GENERATE_KEY_EX, RSA_R_NON_FIPS_RSA_METHOD);
 		return 0;
-		}
+	}
+
 #endif
-	if(rsa->meth->rsa_keygen)
-		return rsa->meth->rsa_keygen(rsa, bits, e_value, cb);
+
+	if(rsa->meth->rsa_keygen) {
+		return rsa->meth->rsa_keygen (rsa, bits, e);
+	}
+
 #ifdef OPENSSL_FIPS
-	if (FIPS_mode())
-		return FIPS_rsa_generate_key_ex(rsa, bits, e_value, cb);
-#endif
-	return rsa_builtin_keygen(rsa, bits, e_value, cb);
+
+	if (FIPS_mode()) {
+		return FIPS_rsa_generate_key_ex (rsa, bits, e, cb);
 	}
 
-static int rsa_builtin_keygen(RSA *rsa, int bits, BIGNUM *e_value, BN_GENCB *cb)
-	{
-	BIGNUM *r0=NULL,*r1=NULL,*r2=NULL,*r3=NULL,*tmp;
-	BIGNUM local_r0,local_d,local_p;
-	BIGNUM *pr0,*d,*p;
-	int bitsp,bitsq,ok= -1,n=0;
-	BN_CTX *ctx=NULL;
-
-	ctx=BN_CTX_new();
-	if (ctx == NULL) goto err;
-	BN_CTX_start(ctx);
-	r0 = BN_CTX_get(ctx);
-	r1 = BN_CTX_get(ctx);
-	r2 = BN_CTX_get(ctx);
-	r3 = BN_CTX_get(ctx);
-	if (r3 == NULL) goto err;
-
-	bitsp=(bits+1)/2;
-	bitsq=bits-bitsp;
-
-	/* We need the RSA components non-NULL */
-	if(!rsa->n && ((rsa->n=BN_new()) == NULL)) goto err;
-	if(!rsa->d && ((rsa->d=BN_new()) == NULL)) goto err;
-	if(!rsa->e && ((rsa->e=BN_new()) == NULL)) goto err;
-	if(!rsa->p && ((rsa->p=BN_new()) == NULL)) goto err;
-	if(!rsa->q && ((rsa->q=BN_new()) == NULL)) goto err;
-	if(!rsa->dmp1 && ((rsa->dmp1=BN_new()) == NULL)) goto err;
-	if(!rsa->dmq1 && ((rsa->dmq1=BN_new()) == NULL)) goto err;
-	if(!rsa->iqmp && ((rsa->iqmp=BN_new()) == NULL)) goto err;
-
-	BN_copy(rsa->e, e_value);
-
-	/* generate p and q */
-	for (;;)
-		{
-		if(!BN_generate_prime_ex(rsa->p, bitsp, 0, NULL, NULL, cb))
-			goto err;
-		if (!BN_sub(r2,rsa->p,BN_value_one())) goto err;
-		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
-		if (BN_is_one(r1)) break;
-		if(!BN_GENCB_call(cb, 2, n++))
-			goto err;
+#endif
+
+	return rsa_builtin_keygen (rsa, bits, e);
+}
+
+static void rsa_randinit( gmp_randstate_t rs )
+{
+	struct timeval tv;
+	unsigned int seed = getpid ();
+	int fd;
+
+	gettimeofday (&tv, NULL);
+	seed += tv.tv_sec / seed + tv.tv_usec * seed;
+
+	if (0 <= (fd = open ("/dev/urandom", O_RDONLY))) {
+		int i;
+		unsigned int t;
+		for (i = 0; i < 256; ++i) {
+			read (fd, &t, sizeof(t));
+			seed += t;
 		}
-	if(!BN_GENCB_call(cb, 3, 0))
-		goto err;
-	for (;;)
-		{
+		close (fd);
+	}
+
+	gmp_randinit_default (rs);
+	gmp_randseed_ui (rs, seed);
+}
+
+static int rsa_builtin_keygen( RSA* rsa, int bits, mpz_t e )
+{
+	gmp_randstate_t rs;
+	mpz_t r1, r2, r3;
+	int bitsp, bitsq, ok = -1;
+
+	mpz_inits (r1, r2, r3, rsa->n, rsa->d, rsa->e,
+		rsa->p, rsa->q, rsa->dmp1, rsa->dmq1, rsa->iqmp, NULL);
+	mpz_set (rsa->e, e);
+
+	rsa_randinit (rs);
+
+	// generate p
+	bitsp = (bits + 1) / 2;
+	do {
+		mpz_urandomb (r2, rs, bitsp);
+		mpz_setbit (r2, bitsp - 1);
+		mpz_nextprime (rsa->p, r2);
+		mpz_sub_ui (r2, rsa->p, 1);
+		mpz_gcd (r1, r2, rsa->e);
+	} while (mpz_cmp_ui (r1, 1));
+
+	// generate q
+	bitsq = bits - mpz_sizeinbase (rsa->p, 2);
+	do {
 		/* When generating ridiculously small keys, we can get stuck
 		 * continually regenerating the same prime values. Check for
 		 * this and bail if it happens 3 times. */
 		unsigned int degenerate = 0;
-		do
-			{
-			if(!BN_generate_prime_ex(rsa->q, bitsq, 0, NULL, NULL, cb))
-				goto err;
-			} while((BN_cmp(rsa->p, rsa->q) == 0) && (++degenerate < 3));
-		if(degenerate == 3)
-			{
+		do {
+			mpz_urandomb (r3, rs, bitsq);
+			mpz_setbit (r3, bitsq - 1);
+			mpz_nextprime (rsa->q, r3);
+		} while (!mpz_cmp (rsa->p, rsa->q) && (++degenerate < 3));
+		if (degenerate == 3) {
 			ok = 0; /* we set our own err */
-			RSAerr(RSA_F_RSA_BUILTIN_KEYGEN,RSA_R_KEY_SIZE_TOO_SMALL);
-			goto err;
-			}
-		if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;
-		if (!BN_gcd(r1,r2,rsa->e,ctx)) goto err;
-		if (BN_is_one(r1))
-			break;
-		if(!BN_GENCB_call(cb, 2, n++))
+			RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, RSA_R_KEY_SIZE_TOO_SMALL);
 			goto err;
 		}
-	if(!BN_GENCB_call(cb, 3, 1))
-		goto err;
-	if (BN_cmp(rsa->p,rsa->q) < 0)
-		{
-		tmp=rsa->p;
-		rsa->p=rsa->q;
-		rsa->q=tmp;
-		}
 
-	/* calculate n */
-	if (!BN_mul(rsa->n,rsa->p,rsa->q,ctx)) goto err;
+		mpz_sub_ui (r3, rsa->q, 1);
+		mpz_gcd (r1, r3, rsa->e);
+	} while (mpz_cmp_ui (r1, 1));
+
+	if (mpz_cmp (rsa->p, rsa->q) < 0) {
+		mpz_set (r1, rsa->p), mpz_set (rsa->p, rsa->q), mpz_set (rsa->q, r1);
+		mpz_set (r1, r2), mpz_set (r2, r3), mpz_set (r3, r1);
+	}
 
-	/* calculate d */
-	if (!BN_sub(r1,rsa->p,BN_value_one())) goto err;	/* p-1 */
-	if (!BN_sub(r2,rsa->q,BN_value_one())) goto err;	/* q-1 */
-	if (!BN_mul(r0,r1,r2,ctx)) goto err;	/* (p-1)(q-1) */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		  pr0 = &local_r0;
-		  BN_with_flags(pr0, r0, BN_FLG_CONSTTIME);
-		}
-	else
-	  pr0 = r0;
-	if (!BN_mod_inverse(rsa->d,rsa->e,pr0,ctx)) goto err;	/* d */
-
-	/* set up d for correct BN_FLG_CONSTTIME flag */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		d = &local_d;
-		BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
-		}
-	else
-		d = rsa->d;
+	// calculate n
+	mpz_mul (rsa->n, rsa->p, rsa->q);
 
-	/* calculate d mod (p-1) */
-	if (!BN_mod(rsa->dmp1,d,r1,ctx)) goto err;
+	// calculate d
+	mpz_mul (r1, r2, r3);
+	mpz_invert (rsa->d, rsa->e, r1);
 
-	/* calculate d mod (q-1) */
-	if (!BN_mod(rsa->dmq1,d,r2,ctx)) goto err;
+	// calculate d mod (p-1)
+	mpz_mod (rsa->dmp1, rsa->d, r2);
 
-	/* calculate inverse of q mod p */
-	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
-		{
-		p = &local_p;
-		BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);
-		}
-	else
-		p = rsa->p;
-	if (!BN_mod_inverse(rsa->iqmp,rsa->q,p,ctx)) goto err;
+	// calculate d mod (q-1)
+	mpz_mod (rsa->dmq1, rsa->d, r3);
+
+	// calculate inverse of q mod p
+	mpz_invert (rsa->iqmp, rsa->q, rsa->p);
+
+	ok = 1;
 
-	ok=1;
 err:
-	if (ok == -1)
-		{
-		RSAerr(RSA_F_RSA_BUILTIN_KEYGEN,ERR_LIB_BN);
-		ok=0;
-		}
-	if (ctx != NULL)
-		{
-		BN_CTX_end(ctx);
-		BN_CTX_free(ctx);
-		}
 
-	return ok;
+	gmp_randclear (rs);
+
+	if (ok == -1) {
+		RSAerr(RSA_F_RSA_BUILTIN_KEYGEN, ERR_LIB_BN);
+		ok = 0;
 	}
 
+	if (ok != 1) {
+		mpz_clears (rsa->iqmp, rsa->dmq1, rsa->dmp1,
+			rsa->q, rsa->p, rsa->e, rsa->d, rsa->n, NULL);
+	}
+
+	mpz_clears (r3, r2, r1, NULL);
+
+	return ok;
+}
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_lib.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_lib.c
--- openssl-1.0.1e/crypto/rsa/rsa_lib.c	2013-04-24 22:22:43.722799372 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_lib.c	2013-04-24 22:11:07.035800020 +0800
@@ -1,66 +1,16 @@
 /* crypto/rsa/rsa_lib.c */
-/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+/* Copyright (C) 2013 Huang Le
  * All rights reserved.
  *
- * This package is an SSL implementation written
- * by Eric Young (eay@cryptsoft.com).
- * The implementation was written so as to conform with Netscapes SSL.
- * 
- * This library is free for commercial and non-commercial use as long as
- * the following conditions are aheared to.  The following conditions
- * apply to all code found in this distribution, be it the RC4, RSA,
- * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
- * included with this distribution is covered by the same copyright terms
- * except that the holder is Tim Hudson (tjh@cryptsoft.com).
- * 
- * Copyright remains Eric Young's, and as such any Copyright notices in
- * the code are not to be removed.
- * If this package is used in a product, Eric Young should be given attribution
- * as the author of the parts of the library used.
- * This can be in the form of a textual message at program startup or
- * in documentation (online or textual) provided with the package.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *    "This product includes cryptographic software written by
- *     Eric Young (eay@cryptsoft.com)"
- *    The word 'cryptographic' can be left out if the rouines from the library
- *    being used are not cryptographic related :-).
- * 4. If you include any Windows specific code (or a derivative thereof) from 
- *    the apps directory (application code) you must include an acknowledgement:
- *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
- * 
- * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- * 
- * The licence and distribution terms for any publically available version or
- * derivative of this code cannot be changed.  i.e. this code cannot simply be
- * copied and put under another distribution licence
- * [including the GNU Public Licence.]
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #include <stdio.h>
 #include <openssl/crypto.h>
 #include "cryptlib.h"
 #include <openssl/lhash.h>
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 #ifndef OPENSSL_NO_ENGINE
@@ -73,259 +23,209 @@
 
 const char RSA_version[]="RSA" OPENSSL_VERSION_PTEXT;
 
-static const RSA_METHOD *default_RSA_meth=NULL;
+static const RSA_METHOD* default_RSA_meth = NULL;
 
-RSA *RSA_new(void)
-	{
-	RSA *r=RSA_new_method(NULL);
+RSA* RSA_new()
+{
+	return RSA_new_method (NULL);
+}
 
-	return r;
-	}
-
-void RSA_set_default_method(const RSA_METHOD *meth)
-	{
+void RSA_set_default_method( const RSA_METHOD* meth )
+{
 	default_RSA_meth = meth;
-	}
+}
 
-const RSA_METHOD *RSA_get_default_method(void)
-	{
-	if (default_RSA_meth == NULL)
-		{
+const RSA_METHOD* RSA_get_default_method()
+{
+	if (default_RSA_meth == NULL) {
 #ifdef OPENSSL_FIPS
 		if (FIPS_mode())
-			return FIPS_rsa_pkcs1_ssleay();
+			return FIPS_rsa_pkcs1_ssleay ();
 		else
-			return RSA_PKCS1_SSLeay();
+			return RSA_PKCS1_SSLeay ();
 #else
 #ifdef RSA_NULL
-		default_RSA_meth=RSA_null_method();
+		default_RSA_meth = RSA_null_method ();
 #else
-		default_RSA_meth=RSA_PKCS1_SSLeay();
+		default_RSA_meth = RSA_PKCS1_SSLeay ();
 #endif
 #endif
-		}
+	}
 
 	return default_RSA_meth;
-	}
+}
 
-const RSA_METHOD *RSA_get_method(const RSA *rsa)
-	{
+const RSA_METHOD* RSA_get_method( const RSA* rsa )
+{
 	return rsa->meth;
-	}
+}
 
-int RSA_set_method(RSA *rsa, const RSA_METHOD *meth)
-	{
+int RSA_set_method( RSA* rsa, const RSA_METHOD* meth )
+{
 	/* NB: The caller is specifically setting a method, so it's not up to us
 	 * to deal with which ENGINE it comes from. */
-	const RSA_METHOD *mtmp;
-	mtmp = rsa->meth;
-	if (mtmp->finish) mtmp->finish(rsa);
+	const RSA_METHOD* mtmp = rsa->meth;
+	if (mtmp->finish) {
+		mtmp->finish (rsa);
+	}
+
 #ifndef OPENSSL_NO_ENGINE
-	if (rsa->engine)
-		{
-		ENGINE_finish(rsa->engine);
+	if (rsa->engine) {
+		ENGINE_finish (rsa->engine);
 		rsa->engine = NULL;
-		}
+	}
 #endif
+
 	rsa->meth = meth;
-	if (meth->init) meth->init(rsa);
-	return 1;
+	if (meth->init) {
+		meth->init (rsa);
 	}
 
-RSA *RSA_new_method(ENGINE *engine)
-	{
-	RSA *ret=(RSA *)OPENSSL_malloc(sizeof(RSA));
-	if (ret == NULL)
-		{
-		RSAerr(RSA_F_RSA_NEW_METHOD,ERR_R_MALLOC_FAILURE);
+	return 1;
+}
+
+RSA* RSA_new_method( ENGINE* engine )
+{
+	RSA* ret = (RSA*)OPENSSL_malloc (sizeof(RSA));
+	if (ret == NULL) {
+		RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_MALLOC_FAILURE);
 		return NULL;
-		}
+	}
 
-	ret->meth = RSA_get_default_method();
-//Log ("1 RSA_new_method(%p)=%p,%p,%p,RSA_PKCS1_SSLeay()=%p",
-//	engine, ret, ret->meth, ret->meth->init, RSA_PKCS1_SSLeay());
+	ret->meth = RSA_get_default_method ();
 #ifndef OPENSSL_NO_ENGINE
-	if (engine)
-		{
-		if (!ENGINE_init(engine))
-			{
+	if (engine) {
+		if (!ENGINE_init (engine)) {
 			RSAerr(RSA_F_RSA_NEW_METHOD, ERR_R_ENGINE_LIB);
-			OPENSSL_free(ret);
+			OPENSSL_free (ret);
 			return NULL;
-			}
+		}
 		ret->engine = engine;
-		ret->meth = ENGINE_get_RSA(engine);
-		if(!ret->meth)
-			{
+	} else {
+		ret->engine = ENGINE_get_default_RSA ();
+	}
+	if(ret->engine) {
+		ret->meth = ENGINE_get_RSA (ret->engine);
+		if (!ret->meth) {
 			RSAerr(RSA_F_RSA_NEW_METHOD,
 				ERR_R_ENGINE_LIB);
-			ENGINE_finish(engine);
-			OPENSSL_free(ret);
+			ENGINE_finish (ret->engine);
+			OPENSSL_free (ret);
 			return NULL;
-			}
 		}
-	else
-		ret->engine = ENGINE_get_default_RSA();
+	}
 #endif
 
-	ret->pad=0;
-	ret->version=0;
-	ret->n=NULL;
-	ret->e=NULL;
-	ret->d=NULL;
-	ret->p=NULL;
-	ret->q=NULL;
-	ret->dmp1=NULL;
-	ret->dmq1=NULL;
-	ret->iqmp=NULL;
-	ret->references=1;
-	ret->_method_mod_n=NULL;
-	ret->_method_mod_p=NULL;
-	ret->_method_mod_q=NULL;
-	ret->blinding=NULL;
-	ret->mt_blinding=NULL;
-	ret->bignum_data=NULL;
-	ret->flags=ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW;
-	if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data))
-		{
+	ret->pad = 0;
+	ret->version = 0;
+	mpz_inits (ret->n, ret->e, ret->d, ret->p, ret->q,
+		ret->dmp1, ret->dmq1, ret->iqmp, NULL);
+	ret->swdmp1 = ret->swdmq1 = NULL;
+	ret->references = 1;
+	ret->flags = ret->meth->flags & ~RSA_FLAG_NON_FIPS_ALLOW;
+	if (!CRYPTO_new_ex_data (CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data)) {
 #ifndef OPENSSL_NO_ENGINE
-	if (ret->engine)
-		ENGINE_finish(ret->engine);
-#endif
-		OPENSSL_free(ret);
-		return(NULL);
+		if (ret->engine) {
+			ENGINE_finish (ret->engine);
 		}
-//Log ("2 RSA_new_method(%p)=%p,%p,%p,RSA_PKCS1_SSLeay()=%p",
-//	engine, ret, ret->meth, ret->meth->init, RSA_PKCS1_SSLeay());
-	if ((ret->meth->init) && !ret->meth->init(ret))
-		{
-#ifndef OPENSSL_NO_ENGINE
-		if (ret->engine)
-			ENGINE_finish(ret->engine);
 #endif
-		CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);
-		OPENSSL_free(ret);
-		ret=NULL;
+		OPENSSL_free (ret);
+		return NULL;
+	}
+
+	if (ret->meth->init && !ret->meth->init (ret)) {
+#ifndef OPENSSL_NO_ENGINE
+		if (ret->engine) {
+			ENGINE_finish (ret->engine);
 		}
-	return(ret);
+#endif
+		CRYPTO_free_ex_data (CRYPTO_EX_INDEX_RSA, ret, &ret->ex_data);
+		OPENSSL_free (ret);
+		ret = NULL;
 	}
+	return ret;
+}
 
-void RSA_free(RSA *r)
-	{
+void RSA_free( RSA* r )
+{
 	int i;
 
-	if (r == NULL) return;
+	if (!r) {
+		return;
+	}
 
-	i=CRYPTO_add(&r->references,-1,CRYPTO_LOCK_RSA);
+	i = CRYPTO_add (&r->references, -1, CRYPTO_LOCK_RSA);
 #ifdef REF_PRINT
-	REF_PRINT("RSA",r);
+	REF_PRINT("RSA", r);
 #endif
-	if (i > 0) return;
+	if (i > 0) {
+		return;
+	}
 #ifdef REF_CHECK
-	if (i < 0)
-		{
-		fprintf(stderr,"RSA_free, bad reference count\n");
-		abort();
-		}
+	if (i < 0) {
+		fprintf (stderr, "RSA_free, bad reference count\n");
+		abort ();
+	}
 #endif
 
-	if (r->meth->finish)
-		r->meth->finish(r);
+	if (r->meth->finish) {
+		r->meth->finish (r);
+	}
+
 #ifndef OPENSSL_NO_ENGINE
-	if (r->engine)
-		ENGINE_finish(r->engine);
+	if (r->engine) {
+		ENGINE_finish (r->engine);
+	}
 #endif
 
-	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_RSA, r, &r->ex_data);
+	CRYPTO_free_ex_data (CRYPTO_EX_INDEX_RSA, r, &r->ex_data);
 
-	if (r->n != NULL) BN_clear_free(r->n);
-	if (r->e != NULL) BN_clear_free(r->e);
-	if (r->d != NULL) BN_clear_free(r->d);
-	if (r->p != NULL) BN_clear_free(r->p);
-	if (r->q != NULL) BN_clear_free(r->q);
-	if (r->dmp1 != NULL) BN_clear_free(r->dmp1);
-	if (r->dmq1 != NULL) BN_clear_free(r->dmq1);
-	if (r->iqmp != NULL) BN_clear_free(r->iqmp);
-	if (r->blinding != NULL) BN_BLINDING_free(r->blinding);
-	if (r->mt_blinding != NULL) BN_BLINDING_free(r->mt_blinding);
-	if (r->bignum_data != NULL) OPENSSL_free_locked(r->bignum_data);
-	OPENSSL_free(r);
-	}
-
-int RSA_up_ref(RSA *r)
-	{
-	int i = CRYPTO_add(&r->references, 1, CRYPTO_LOCK_RSA);
+	if (r->swdmq1) {
+		mpz_destroy_swt (r->swdmq1);
+	}
+	if (r->swdmp1) {
+		mpz_destroy_swt (r->swdmp1);
+	}
+
+	mpz_clears (r->iqmp, r->dmq1, r->dmp1, r->q, r->p,
+		r->d, r->e, r->n, NULL);
+
+	OPENSSL_free (r);
+}
+
+int RSA_up_ref( RSA* r )
+{
+	int i = CRYPTO_add (&r->references, 1, CRYPTO_LOCK_RSA);
 #ifdef REF_PRINT
-	REF_PRINT("RSA",r);
+	REF_PRINT("RSA", r);
 #endif
 #ifdef REF_CHECK
-	if (i < 2)
-		{
-		fprintf(stderr, "RSA_up_ref, bad reference count\n");
-		abort();
-		}
-#endif
-	return ((i > 1) ? 1 : 0);
-	}
+	if (i < 2) {
+		fprintf (stderr, "RSA_up_ref, bad reference count\n");
+		abort ();
+	}
+#endif
+	return (i > 1) ? 1 : 0;
+}
+
+int RSA_get_ex_new_index( long argl, void* argp, CRYPTO_EX_new* new_func,
+	CRYPTO_EX_dup* dup_func, CRYPTO_EX_free* free_func )
+{
+	return CRYPTO_get_ex_new_index (CRYPTO_EX_INDEX_RSA, argl, argp,
+			new_func, dup_func, free_func);
+}
+
+int RSA_set_ex_data( RSA* r, int idx, void* arg )
+{
+	return CRYPTO_set_ex_data (&r->ex_data, idx, arg);
+}
+
+void* RSA_get_ex_data( const RSA* r, int idx )
+{
+	return CRYPTO_get_ex_data (&r->ex_data, idx);
+}
 
-int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
-	     CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func)
-        {
-	return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, argl, argp,
-				new_func, dup_func, free_func);
-        }
-
-int RSA_set_ex_data(RSA *r, int idx, void *arg)
-	{
-	return(CRYPTO_set_ex_data(&r->ex_data,idx,arg));
-	}
-
-void *RSA_get_ex_data(const RSA *r, int idx)
-	{
-	return(CRYPTO_get_ex_data(&r->ex_data,idx));
-	}
-
-int RSA_memory_lock(RSA *r)
-	{
-	int i,j,k,off;
-	char *p;
-	BIGNUM *bn,**t[6],*b;
-	BN_ULONG *ul;
-
-	if (r->d == NULL) return(1);
-	t[0]= &r->d;
-	t[1]= &r->p;
-	t[2]= &r->q;
-	t[3]= &r->dmp1;
-	t[4]= &r->dmq1;
-	t[5]= &r->iqmp;
-	k=sizeof(BIGNUM)*6;
-	off=k/sizeof(BN_ULONG)+1;
-	j=1;
-	for (i=0; i<6; i++)
-		j+= (*t[i])->top;
-	if ((p=OPENSSL_malloc_locked((off+j)*sizeof(BN_ULONG))) == NULL)
-		{
-		RSAerr(RSA_F_RSA_MEMORY_LOCK,ERR_R_MALLOC_FAILURE);
-		return(0);
-		}
-	bn=(BIGNUM *)p;
-	ul=(BN_ULONG *)&(p[off]);
-	for (i=0; i<6; i++)
-		{
-		b= *(t[i]);
-		*(t[i])= &(bn[i]);
-		memcpy((char *)&(bn[i]),(char *)b,sizeof(BIGNUM));
-		bn[i].flags=BN_FLG_STATIC_DATA;
-		bn[i].d=ul;
-		memcpy((char *)ul,b->d,sizeof(BN_ULONG)*b->top);
-		ul+=b->top;
-		BN_clear_free(b);
-		}
-	
-	/* I should fix this so it can still be done */
-	r->flags&= ~(RSA_FLAG_CACHE_PRIVATE|RSA_FLAG_CACHE_PUBLIC);
-
-	r->bignum_data=p;
-	return(1);
-	}
+int RSA_memory_lock( RSA* r )
+{
+	return 1;
+}
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_locl.h sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_locl.h
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_none.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_none.c
--- openssl-1.0.1e/crypto/rsa/rsa_none.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_none.c	2013-04-24 22:11:07.035800020 +0800
@@ -58,7 +58,6 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_null.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_null.c
--- openssl-1.0.1e/crypto/rsa/rsa_null.c	2013-04-24 22:21:55.209799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_null.c	2013-04-24 22:11:07.035800020 +0800
@@ -1,64 +1,14 @@
 /* rsa_null.c */
-/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
- * project 1999.
- */
-/* ====================================================================
- * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    licensing@OpenSSL.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
  *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 
@@ -69,27 +19,22 @@
  * operations (like storing RSA keys) are permitted.
  */
 
-static int RSA_null_public_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_null_private_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_null_public_decrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-static int RSA_null_private_decrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
-#if 0 /* not currently used */
-static int RSA_null_mod_exp(const BIGNUM *r0, const BIGNUM *i, RSA *rsa);
-#endif
-static int RSA_null_init(RSA *rsa);
-static int RSA_null_finish(RSA *rsa);
-static RSA_METHOD rsa_null_meth={
+static int RSA_null_public_encrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+static int RSA_null_private_encrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+static int RSA_null_public_decrypt(int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding);
+static int RSA_null_private_decrypt( int flen, const unsigned char* from,
+		unsigned char* to, RSA* rsa, int padding );
+static int RSA_null_init( RSA* rsa );
+static int RSA_null_finish( RSA* rsa );
+static RSA_METHOD rsa_null_meth = {
 	"Null RSA",
 	RSA_null_public_encrypt,
 	RSA_null_public_decrypt,
 	RSA_null_private_encrypt,
 	RSA_null_private_decrypt,
-	NULL,
-	NULL,
 	RSA_null_init,
 	RSA_null_finish,
 	0,
@@ -97,55 +42,47 @@
 	NULL,
 	NULL,
 	NULL
-	};
+};
 
-const RSA_METHOD *RSA_null_method(void)
-	{
-	return(&rsa_null_meth);
-	}
-
-static int RSA_null_public_encrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
+const RSA_METHOD* RSA_null_method()
+{
+	return &rsa_null_meth;
+}
+
+static int RSA_null_public_encrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
 	RSAerr(RSA_F_RSA_NULL_PUBLIC_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
 	return -1;
-	}
+}
 
-static int RSA_null_private_encrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
+static int RSA_null_private_encrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
 	RSAerr(RSA_F_RSA_NULL_PRIVATE_ENCRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
 	return -1;
-	}
+}
 
-static int RSA_null_private_decrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
+static int RSA_null_private_decrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
 	RSAerr(RSA_F_RSA_NULL_PRIVATE_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
 	return -1;
-	}
+}
 
-static int RSA_null_public_decrypt(int flen, const unsigned char *from,
-	     unsigned char *to, RSA *rsa, int padding)
-	{
+static int RSA_null_public_decrypt( int flen, const unsigned char* from,
+	unsigned char* to, RSA* rsa, int padding )
+{
 	RSAerr(RSA_F_RSA_NULL_PUBLIC_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
 	return -1;
-	}
-
-#if 0 /* not currently used */
-static int RSA_null_mod_exp(BIGNUM *r0, BIGNUM *I, RSA *rsa)
-	{
-	...err(RSA_F_RSA_NULL_MOD_EXP, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
-	return -1;
-	}
-#endif
+}
 
-static int RSA_null_init(RSA *rsa)
-	{
-	return(1);
-	}
-
-static int RSA_null_finish(RSA *rsa)
-	{
-	return(1);
-	}
+static int RSA_null_init( RSA* rsa )
+{
+	return 1;
+}
+
+static int RSA_null_finish( RSA* rsa )
+{
+	return 1;
+}
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_oaep.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_oaep.c
--- openssl-1.0.1e/crypto/rsa/rsa_oaep.c	2013-04-24 22:21:55.209799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_oaep.c	2013-04-24 22:11:07.037800019 +0800
@@ -22,7 +22,6 @@
 #if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/evp.h>
 #include <openssl/rand.h>
@@ -149,7 +148,7 @@
 	if (!EVP_Digest((void *)param, plen, phash, NULL, EVP_sha1(), NULL))
 		return -1;
 
-	if (CRYPTO_memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
+	if (memcmp(db, phash, SHA_DIGEST_LENGTH) != 0 || bad)
 		goto decoding_err;
 	else
 		{
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_pk1.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_pk1.c
--- openssl-1.0.1e/crypto/rsa/rsa_pk1.c	2013-04-24 22:21:55.207799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_pk1.c	2013-04-24 22:11:07.037800019 +0800
@@ -58,7 +58,6 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_pmeth.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_pmeth.c
--- openssl-1.0.1e/crypto/rsa/rsa_pmeth.c	2013-04-24 22:21:55.209799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_pmeth.c	2013-04-24 22:11:07.038800019 +0800
@@ -1,59 +1,10 @@
 /* crypto/rsa/rsa_pmeth.c */
-/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
- * project 2006.
- */
-/* ====================================================================
- * Copyright (c) 2006 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    licensing@OpenSSL.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
  *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #include <stdio.h>
@@ -61,7 +12,6 @@
 #include <openssl/asn1t.h>
 #include <openssl/x509.h>
 #include <openssl/rsa.h>
-#include <openssl/bn.h>
 #include <openssl/evp.h>
 #ifndef OPENSSL_NO_CMS
 #include <openssl/cms.h>
@@ -74,33 +24,33 @@
 
 /* RSA pkey context structure */
 
-typedef struct
-	{
+typedef struct {
 	/* Key gen parameters */
 	int nbits;
-	BIGNUM *pub_exp;
+	mpz_t pub_exp;
 	/* Keygen callback info */
 	int gentmp[2];
 	/* RSA padding mode */
 	int pad_mode;
 	/* message digest */
-	const EVP_MD *md;
+	const EVP_MD* md;
 	/* message digest for MGF1 */
-	const EVP_MD *mgf1md;
+	const EVP_MD* mgf1md;
 	/* PSS/OAEP salt length */
 	int saltlen;
 	/* Temp buffer */
-	unsigned char *tbuf;
-	} RSA_PKEY_CTX;
+	unsigned char* tbuf;
+} RSA_PKEY_CTX, *PRSA_PKEY_CTX;
 
-static int pkey_rsa_init(EVP_PKEY_CTX *ctx)
-	{
-	RSA_PKEY_CTX *rctx;
-	rctx = OPENSSL_malloc(sizeof(RSA_PKEY_CTX));
-	if (!rctx)
+static int pkey_rsa_init( EVP_PKEY_CTX* ctx )
+{
+	PRSA_PKEY_CTX rctx;
+	rctx = OPENSSL_malloc (sizeof(RSA_PKEY_CTX));
+	if (!rctx) {
 		return 0;
+	}
 	rctx->nbits = 1024;
-	rctx->pub_exp = NULL;
+	mpz_init (rctx->pub_exp);
 	rctx->pad_mode = RSA_PKCS1_PADDING;
 	rctx->md = NULL;
 	rctx->mgf1md = NULL;
@@ -111,51 +61,50 @@
 	ctx->data = rctx;
 	ctx->keygen_info = rctx->gentmp;
 	ctx->keygen_info_count = 2;
-	
+
 	return 1;
-	}
+}
 
-static int pkey_rsa_copy(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src)
-	{
-	RSA_PKEY_CTX *dctx, *sctx;
-	if (!pkey_rsa_init(dst))
+static int pkey_rsa_copy( EVP_PKEY_CTX* dst, EVP_PKEY_CTX* src )
+{
+	PRSA_PKEY_CTX dctx, sctx;
+	if (!pkey_rsa_init (dst)) {
 		return 0;
-       	sctx = src->data;
+	}
+
+	sctx = src->data;
 	dctx = dst->data;
 	dctx->nbits = sctx->nbits;
-	if (sctx->pub_exp)
-		{
-		dctx->pub_exp = BN_dup(sctx->pub_exp);
-		if (!dctx->pub_exp)
-			return 0;
-		}
+	mpz_set (dctx->pub_exp, sctx->pub_exp);
 	dctx->pad_mode = sctx->pad_mode;
 	dctx->md = sctx->md;
-	return 1;
-	}
 
-static int setup_tbuf(RSA_PKEY_CTX *ctx, EVP_PKEY_CTX *pk)
-	{
-	if (ctx->tbuf)
-		return 1;
-	ctx->tbuf = OPENSSL_malloc(EVP_PKEY_size(pk->pkey));
-	if (!ctx->tbuf)
-		return 0;
 	return 1;
+}
+
+static int setup_tbuf( PRSA_PKEY_CTX ctx, EVP_PKEY_CTX* pk )
+{
+	if (!ctx->tbuf) {
+		ctx->tbuf = OPENSSL_malloc (EVP_PKEY_size (pk->pkey));
+		if (!ctx->tbuf) {
+			return 0;
+		}
 	}
+	return 1;
+}
 
-static void pkey_rsa_cleanup(EVP_PKEY_CTX *ctx)
-	{
-	RSA_PKEY_CTX *rctx = ctx->data;
-	if (rctx)
-		{
-		if (rctx->pub_exp)
-			BN_free(rctx->pub_exp);
-		if (rctx->tbuf)
-			OPENSSL_free(rctx->tbuf);
-		OPENSSL_free(rctx);
+static void pkey_rsa_cleanup( EVP_PKEY_CTX* ctx )
+{
+	PRSA_PKEY_CTX rctx = ctx->data;
+	if (rctx) {
+		mpz_clear (rctx->pub_exp);
+		if (rctx->tbuf) {
+			OPENSSL_free (rctx->tbuf);
 		}
+		OPENSSL_free(rctx);
 	}
+}
+
 #ifdef OPENSSL_FIPS
 /* FIP checker. Return value indicates status of context parameters:
  * 1  : redirect to FIPS.
@@ -163,561 +112,506 @@
  * -1 : illegal operation in FIPS mode.
  */
 
-static int pkey_fips_check_ctx(EVP_PKEY_CTX *ctx)
-	{
-	RSA_PKEY_CTX *rctx = ctx->data;
-	RSA *rsa = ctx->pkey->pkey.rsa;
+static int pkey_fips_check_ctx( EVP_PKEY_CTX* ctx )
+{
+	PRSA_PKEY_CTX rctx = ctx->data;
+	RSA* rsa = ctx->pkey->pkey.rsa;
 	int rv = -1;
-	if (!FIPS_mode())
+	if (!FIPS_mode()) {
 		return 0;
-	if (rsa->flags & RSA_FLAG_NON_FIPS_ALLOW)
+	}
+	if (rsa->flags & RSA_FLAG_NON_FIPS_ALLOW) {
 		rv = 0;
-	if (!(rsa->meth->flags & RSA_FLAG_FIPS_METHOD) && rv)
+	}
+	if (!(rsa->meth->flags & RSA_FLAG_FIPS_METHOD) && rv) {
 		return -1;
-	if (rctx->md && !(rctx->md->flags & EVP_MD_FLAG_FIPS))
+	}
+	if (rctx->md && !(rctx->md->flags & EVP_MD_FLAG_FIPS)) {
 		return rv;
-	if (rctx->mgf1md && !(rctx->mgf1md->flags & EVP_MD_FLAG_FIPS))
+	}
+	if (rctx->mgf1md && !(rctx->mgf1md->flags & EVP_MD_FLAG_FIPS)) {
 		return rv;
-	return 1;
 	}
+	return 1;
+}
 #endif
 
-static int pkey_rsa_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
-					const unsigned char *tbs, size_t tbslen)
-	{
+static int pkey_rsa_sign( EVP_PKEY_CTX* ctx, unsigned char* sig, size_t* siglen,
+	const unsigned char* tbs, size_t tbslen )
+{
 	int ret;
-	RSA_PKEY_CTX *rctx = ctx->data;
-	RSA *rsa = ctx->pkey->pkey.rsa;
+	PRSA_PKEY_CTX rctx = ctx->data;
+	RSA* rsa = ctx->pkey->pkey.rsa;
 
 #ifdef OPENSSL_FIPS
-	ret = pkey_fips_check_ctx(ctx);
-	if (ret < 0)
-		{
+	ret = pkey_fips_check_ctx (ctx);
+	if (ret < 0) {
 		RSAerr(RSA_F_PKEY_RSA_SIGN, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
 		return -1;
-		}
+	}
 #endif
 
-	if (rctx->md)
-		{
-		if (tbslen != (size_t)EVP_MD_size(rctx->md))
-			{
-			RSAerr(RSA_F_PKEY_RSA_SIGN,
-					RSA_R_INVALID_DIGEST_LENGTH);
+	if (rctx->md) {
+		if (tbslen != (size_t)EVP_MD_size (rctx->md)) {
+			RSAerr(RSA_F_PKEY_RSA_SIGN,	RSA_R_INVALID_DIGEST_LENGTH);
 			return -1;
-			}
+		}
 #ifdef OPENSSL_FIPS
-		if (ret > 0)
-			{
+		if (ret > 0) {
 			unsigned int slen;
-			ret = FIPS_rsa_sign_digest(rsa, tbs, tbslen, rctx->md,
-							rctx->pad_mode,
-							rctx->saltlen,
-							rctx->mgf1md,
-							sig, &slen);
-			if (ret > 0)
+			ret = FIPS_rsa_sign_digest (rsa, tbs, tbslen, rctx->md,
+					rctx->pad_mode, rctx->saltlen, rctx->mgf1md,
+					sig, &slen);
+			if (ret > 0) {
 				*siglen = slen;
-			else
+			} else {
 				*siglen = 0;
-			return ret;
 			}
+			return ret;
+		}
 #endif
 
-		if (EVP_MD_type(rctx->md) == NID_mdc2)
-			{
+		if (EVP_MD_type(rctx->md) == NID_mdc2) {
 			unsigned int sltmp;
-			if (rctx->pad_mode != RSA_PKCS1_PADDING)
+			if (rctx->pad_mode != RSA_PKCS1_PADDING) {
 				return -1;
-			ret = RSA_sign_ASN1_OCTET_STRING(NID_mdc2,
-						tbs, tbslen, sig, &sltmp, rsa);
-
-			if (ret <= 0)
+			}
+			ret = RSA_sign_ASN1_OCTET_STRING (NID_mdc2,
+					tbs, tbslen, sig, &sltmp, rsa);
+			if (ret <= 0) {
 				return ret;
-			ret = sltmp;
 			}
-		else if (rctx->pad_mode == RSA_X931_PADDING)
-			{
-			if (!setup_tbuf(rctx, ctx))
+			ret = sltmp;
+		} else if (rctx->pad_mode == RSA_X931_PADDING) {
+			if (!setup_tbuf (rctx, ctx)) {
 				return -1;
-			memcpy(rctx->tbuf, tbs, tbslen);
-			rctx->tbuf[tbslen] =
-				RSA_X931_hash_id(EVP_MD_type(rctx->md));
-			ret = RSA_private_encrypt(tbslen + 1, rctx->tbuf,
-						sig, rsa, RSA_X931_PADDING);
 			}
-		else if (rctx->pad_mode == RSA_PKCS1_PADDING)
-			{
+			memcpy (rctx->tbuf, tbs, tbslen);
+			rctx->tbuf[tbslen] = RSA_X931_hash_id (
+					EVP_MD_type(rctx->md));
+			ret = RSA_private_encrypt (tbslen + 1, rctx->tbuf,
+					sig, rsa, RSA_X931_PADDING);
+		} else if (rctx->pad_mode == RSA_PKCS1_PADDING) {
 			unsigned int sltmp;
-			ret = RSA_sign(EVP_MD_type(rctx->md),
-						tbs, tbslen, sig, &sltmp, rsa);
-			if (ret <= 0)
+			ret = RSA_sign (EVP_MD_type (rctx->md),
+					tbs, tbslen, sig, &sltmp, rsa);
+			if (ret <= 0) {
 				return ret;
-			ret = sltmp;
 			}
-		else if (rctx->pad_mode == RSA_PKCS1_PSS_PADDING)
-			{
-			if (!setup_tbuf(rctx, ctx))
+			ret = sltmp;
+		} else if (rctx->pad_mode == RSA_PKCS1_PSS_PADDING) {
+			if (!setup_tbuf (rctx, ctx)) {
 				return -1;
-			if (!RSA_padding_add_PKCS1_PSS_mgf1(rsa,
-						rctx->tbuf, tbs,
-						rctx->md, rctx->mgf1md,
-						rctx->saltlen))
+			}
+			if (!RSA_padding_add_PKCS1_PSS_mgf1 (rsa,
+					rctx->tbuf, tbs, rctx->md, rctx->mgf1md,
+					rctx->saltlen)) {
 				return -1;
-			ret = RSA_private_encrypt(RSA_size(rsa), rctx->tbuf,
-						sig, rsa, RSA_NO_PADDING);
 			}
-		else
+			ret = RSA_private_encrypt (RSA_size (rsa), rctx->tbuf,
+					sig, rsa, RSA_NO_PADDING);
+		} else {
 			return -1;
 		}
-	else
-		ret = RSA_private_encrypt(tbslen, tbs, sig, ctx->pkey->pkey.rsa,
-							rctx->pad_mode);
-	if (ret < 0)
+	} else {
+		ret = RSA_private_encrypt (tbslen, tbs, sig, ctx->pkey->pkey.rsa,
+				rctx->pad_mode);
+	}
+	if (ret < 0) {
 		return ret;
+	}
 	*siglen = ret;
 	return 1;
-	}
+}
 
-
-static int pkey_rsa_verifyrecover(EVP_PKEY_CTX *ctx,
-					unsigned char *rout, size_t *routlen,
-					const unsigned char *sig, size_t siglen)
-	{
+static int pkey_rsa_verifyrecover( EVP_PKEY_CTX* ctx,
+	unsigned char* rout, size_t* routlen,
+	const unsigned char* sig, size_t siglen )
+{
 	int ret;
-	RSA_PKEY_CTX *rctx = ctx->data;
+	PRSA_PKEY_CTX rctx = ctx->data;
 
-	if (rctx->md)
-		{
-		if (rctx->pad_mode == RSA_X931_PADDING)
-			{
-			if (!setup_tbuf(rctx, ctx))
+	if (rctx->md) {
+		if (rctx->pad_mode == RSA_X931_PADDING) {
+			if (!setup_tbuf (rctx, ctx)) {
 				return -1;
-			ret = RSA_public_decrypt(siglen, sig,
-						rctx->tbuf, ctx->pkey->pkey.rsa,
-						RSA_X931_PADDING);
-			if (ret < 1)
+			}
+			ret = RSA_public_decrypt (siglen, sig,
+					rctx->tbuf, ctx->pkey->pkey.rsa,
+					RSA_X931_PADDING);
+			if (ret-- < 1) {
 				return 0;
-			ret--;
-			if (rctx->tbuf[ret] !=
-				RSA_X931_hash_id(EVP_MD_type(rctx->md)))
-				{
+			}
+			if (rctx->tbuf[ret] != RSA_X931_hash_id (
+					EVP_MD_type(rctx->md))) {
 				RSAerr(RSA_F_PKEY_RSA_VERIFYRECOVER,
-						RSA_R_ALGORITHM_MISMATCH);
+					RSA_R_ALGORITHM_MISMATCH);
 				return 0;
-				}
-			if (ret != EVP_MD_size(rctx->md))
-				{
+			}
+			if (ret != EVP_MD_size (rctx->md)) {
 				RSAerr(RSA_F_PKEY_RSA_VERIFYRECOVER,
 					RSA_R_INVALID_DIGEST_LENGTH);
 				return 0;
-				}
-			if (rout)
-				memcpy(rout, rctx->tbuf, ret);
 			}
-		else if (rctx->pad_mode == RSA_PKCS1_PADDING)
-			{
+			if (rout) {
+				memcpy (rout, rctx->tbuf, ret);
+			}
+		} else if (rctx->pad_mode == RSA_PKCS1_PADDING) {
 			size_t sltmp;
-			ret = int_rsa_verify(EVP_MD_type(rctx->md),
-						NULL, 0, rout, &sltmp,
+			ret = int_rsa_verify (EVP_MD_type (rctx->md),
+					NULL, 0, rout, &sltmp,
 					sig, siglen, ctx->pkey->pkey.rsa);
-			if (ret <= 0)
+			if (ret <= 0) {
 				return 0;
-			ret = sltmp;
 			}
-		else
+			ret = sltmp;
+		} else {
 			return -1;
 		}
-	else
-		ret = RSA_public_decrypt(siglen, sig, rout, ctx->pkey->pkey.rsa,
-							rctx->pad_mode);
-	if (ret < 0)
+	} else {
+		ret = RSA_public_decrypt (siglen, sig, rout,
+				ctx->pkey->pkey.rsa, rctx->pad_mode);
+	}
+	if (ret < 0) {
 		return ret;
+	}
 	*routlen = ret;
 	return 1;
-	}
+}
 
-static int pkey_rsa_verify(EVP_PKEY_CTX *ctx,
-					const unsigned char *sig, size_t siglen,
-					const unsigned char *tbs, size_t tbslen)
-	{
-	RSA_PKEY_CTX *rctx = ctx->data;
-	RSA *rsa = ctx->pkey->pkey.rsa;
+static int pkey_rsa_verify( EVP_PKEY_CTX* ctx,
+	const unsigned char* sig, size_t siglen,
+	const unsigned char* tbs, size_t tbslen )
+{
+	PRSA_PKEY_CTX rctx = ctx->data;
+	RSA* rsa = ctx->pkey->pkey.rsa;
 	size_t rslen;
 #ifdef OPENSSL_FIPS
-	int rv;
-	rv = pkey_fips_check_ctx(ctx);
-	if (rv < 0)
-		{
+	int rv = pkey_fips_check_ctx (ctx);
+	if (rv < 0) {
 		RSAerr(RSA_F_PKEY_RSA_VERIFY, RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE);
 		return -1;
-		}
+	}
 #endif
-	if (rctx->md)
-		{
+	if (rctx->md) {
 #ifdef OPENSSL_FIPS
-		if (rv > 0)
-			{
-			return FIPS_rsa_verify_digest(rsa,
-							tbs, tbslen,
-							rctx->md,
-							rctx->pad_mode,
-							rctx->saltlen,
-							rctx->mgf1md,
-							sig, siglen);
-							
-			}
+		if (rv > 0) {
+			return FIPS_rsa_verify_digest (rsa, tbs, tbslen, rctx->md,
+				rctx->pad_mode, rctx->saltlen, rctx->mgf1md, sig, siglen);
+		}
 #endif
-		if (rctx->pad_mode == RSA_PKCS1_PADDING)
-			return RSA_verify(EVP_MD_type(rctx->md), tbs, tbslen,
-					sig, siglen, rsa);
-		if (rctx->pad_mode == RSA_X931_PADDING)
-			{
-			if (pkey_rsa_verifyrecover(ctx, NULL, &rslen,
-					sig, siglen) <= 0)
+		if (rctx->pad_mode == RSA_PKCS1_PADDING) {
+			return RSA_verify (EVP_MD_type (rctx->md), tbs, tbslen,
+				sig, siglen, rsa);
+		}
+		if (rctx->pad_mode == RSA_X931_PADDING) {
+			if (pkey_rsa_verifyrecover (ctx, NULL, &rslen,
+					sig, siglen) <= 0) {
 				return 0;
 			}
-		else if (rctx->pad_mode == RSA_PKCS1_PSS_PADDING)
-			{
+		} else if (rctx->pad_mode == RSA_PKCS1_PSS_PADDING) {
 			int ret;
-			if (!setup_tbuf(rctx, ctx))
+			if (!setup_tbuf (rctx, ctx)) {
 				return -1;
-			ret = RSA_public_decrypt(siglen, sig, rctx->tbuf,
-							rsa, RSA_NO_PADDING);
-			if (ret <= 0)
+			}
+			ret = RSA_public_decrypt (siglen, sig, rctx->tbuf,
+					rsa, RSA_NO_PADDING);
+			if (ret <= 0) {
 				return 0;
-			ret = RSA_verify_PKCS1_PSS_mgf1(rsa, tbs,
-						rctx->md, rctx->mgf1md,
-						rctx->tbuf, rctx->saltlen);
-			if (ret <= 0)
+			}
+			ret = RSA_verify_PKCS1_PSS_mgf1 (rsa, tbs, rctx->md,
+					rctx->mgf1md, rctx->tbuf, rctx->saltlen);
+			if (ret <= 0) {
 				return 0;
-			return 1;
 			}
-		else
+			return 1;
+		} else {
 			return -1;
 		}
-	else
-		{
-		if (!setup_tbuf(rctx, ctx))
+	} else {
+		if (!setup_tbuf (rctx, ctx)) {
 			return -1;
-		rslen = RSA_public_decrypt(siglen, sig, rctx->tbuf,
-						rsa, rctx->pad_mode);
-		if (rslen == 0)
+		}
+		rslen = RSA_public_decrypt (siglen, sig, rctx->tbuf,
+					rsa, rctx->pad_mode);
+		if (rslen == 0) {
 			return 0;
 		}
+	}
 
-	if ((rslen != tbslen) || memcmp(tbs, rctx->tbuf, rslen))
+	if ((rslen != tbslen) || memcmp (tbs, rctx->tbuf, rslen)) {
 		return 0;
+	}
 
 	return 1;
-			
-	}
-	
+}
 
-static int pkey_rsa_encrypt(EVP_PKEY_CTX *ctx,
-					unsigned char *out, size_t *outlen,
-					const unsigned char *in, size_t inlen)
-	{
-	int ret;
-	RSA_PKEY_CTX *rctx = ctx->data;
-	ret = RSA_public_encrypt(inlen, in, out, ctx->pkey->pkey.rsa,
-							rctx->pad_mode);
-	if (ret < 0)
+static int pkey_rsa_encrypt( EVP_PKEY_CTX* ctx,
+	unsigned char* out, size_t* outlen,
+	const unsigned char* in, size_t inlen )
+{
+	PRSA_PKEY_CTX rctx = ctx->data;
+	int ret = RSA_public_encrypt (inlen, in, out,
+				ctx->pkey->pkey.rsa, rctx->pad_mode);
+	if (ret < 0) {
 		return ret;
+	}
 	*outlen = ret;
 	return 1;
-	}
+}
 
-static int pkey_rsa_decrypt(EVP_PKEY_CTX *ctx,
-					unsigned char *out, size_t *outlen,
-					const unsigned char *in, size_t inlen)
-	{
-	int ret;
-	RSA_PKEY_CTX *rctx = ctx->data;
-	ret = RSA_private_decrypt(inlen, in, out, ctx->pkey->pkey.rsa,
-							rctx->pad_mode);
-	if (ret < 0)
+static int pkey_rsa_decrypt( EVP_PKEY_CTX* ctx,
+	unsigned char* out, size_t* outlen,
+	const unsigned char* in, size_t inlen )
+{
+	PRSA_PKEY_CTX rctx = ctx->data;
+	int ret = RSA_private_decrypt (inlen, in, out,
+				ctx->pkey->pkey.rsa, rctx->pad_mode);
+	if (ret < 0) {
 		return ret;
+	}
 	*outlen = ret;
 	return 1;
-	}
+}
 
-static int check_padding_md(const EVP_MD *md, int padding)
-	{
-	if (!md)
+static int check_padding_md( const EVP_MD* md, int padding )
+{
+	if (!md) {
 		return 1;
+	}
 
-	if (padding == RSA_NO_PADDING)
-		{
+	if (padding == RSA_NO_PADDING) {
 		RSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_PADDING_MODE);
 		return 0;
-		}
+	}
 
-	if (padding == RSA_X931_PADDING)
-		{
-		if (RSA_X931_hash_id(EVP_MD_type(md)) == -1)
-			{
-			RSAerr(RSA_F_CHECK_PADDING_MD,
-						RSA_R_INVALID_X931_DIGEST);
+	if (padding == RSA_X931_PADDING) {
+		if (RSA_X931_hash_id (EVP_MD_type (md)) == -1) {
+			RSAerr(RSA_F_CHECK_PADDING_MD, RSA_R_INVALID_X931_DIGEST);
 			return 0;
-			}
-		return 1;
 		}
+	}
 
 	return 1;
-	}
+}
 			
 
-static int pkey_rsa_ctrl(EVP_PKEY_CTX *ctx, int type, int p1, void *p2)
-	{
-	RSA_PKEY_CTX *rctx = ctx->data;
-	switch (type)
-		{
-		case EVP_PKEY_CTRL_RSA_PADDING:
-		if ((p1 >= RSA_PKCS1_PADDING) && (p1 <= RSA_PKCS1_PSS_PADDING))
-			{
-			if (!check_padding_md(rctx->md, p1))
+static int pkey_rsa_ctrl( EVP_PKEY_CTX* ctx, int type, int p1, void* p2 )
+{
+	PRSA_PKEY_CTX rctx = ctx->data;
+	switch (type) {
+	case EVP_PKEY_CTRL_RSA_PADDING:
+		if ((p1 >= RSA_PKCS1_PADDING) && (p1 <= RSA_PKCS1_PSS_PADDING)) {
+			if (!check_padding_md (rctx->md, p1)) {
 				return 0;
-			if (p1 == RSA_PKCS1_PSS_PADDING) 
-				{
+			}
+			if (p1 == RSA_PKCS1_PSS_PADDING) {
 				if (!(ctx->operation &
-				     (EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY)))
+				     (EVP_PKEY_OP_SIGN | EVP_PKEY_OP_VERIFY))) {
 					goto bad_pad;
-				if (!rctx->md)
-					rctx->md = EVP_sha1();
 				}
-			if (p1 == RSA_PKCS1_OAEP_PADDING) 
-				{
-				if (!(ctx->operation & EVP_PKEY_OP_TYPE_CRYPT))
+				if (!rctx->md) {
+					rctx->md = EVP_sha1 ();
+				}
+			}
+			if (p1 == RSA_PKCS1_OAEP_PADDING) {
+				if (!(ctx->operation & EVP_PKEY_OP_TYPE_CRYPT)) {
 					goto bad_pad;
-				if (!rctx->md)
-					rctx->md = EVP_sha1();
 				}
+				if (!rctx->md) {
+					rctx->md = EVP_sha1 ();
+				}
+			}
 			rctx->pad_mode = p1;
 			return 1;
-			}
-		bad_pad:
+		}
+bad_pad:
 		RSAerr(RSA_F_PKEY_RSA_CTRL,
-				RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);
+			RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE);
 		return -2;
 
-		case EVP_PKEY_CTRL_GET_RSA_PADDING:
-		*(int *)p2 = rctx->pad_mode;
+	case EVP_PKEY_CTRL_GET_RSA_PADDING:
+		*(int*)p2 = rctx->pad_mode;
 		return 1;
 
-		case EVP_PKEY_CTRL_RSA_PSS_SALTLEN:
-		case EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN:
-		if (rctx->pad_mode != RSA_PKCS1_PSS_PADDING)
-			{
+	case EVP_PKEY_CTRL_RSA_PSS_SALTLEN:
+	case EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN:
+		if (rctx->pad_mode != RSA_PKCS1_PSS_PADDING) {
 			RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_PSS_SALTLEN);
 			return -2;
-			}
-		if (type == EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN)
-			*(int *)p2 = rctx->saltlen;
-		else
-			{
-			if (p1 < -2)
+		}
+		if (type == EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN) {
+			*(int*)p2 = rctx->saltlen;
+		} else {
+			if (p1 < -2) {
 				return -2;
-			rctx->saltlen = p1;
 			}
+			rctx->saltlen = p1;
+		}
 		return 1;
 
-		case EVP_PKEY_CTRL_RSA_KEYGEN_BITS:
-		if (p1 < 256)
-			{
+	case EVP_PKEY_CTRL_RSA_KEYGEN_BITS:
+		if (p1 < 256) {
 			RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_KEYBITS);
 			return -2;
-			}
+		}
 		rctx->nbits = p1;
 		return 1;
 
-		case EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP:
-		if (!p2)
+	case EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP:
+		if (!p2) {
 			return -2;
-		rctx->pub_exp = p2;
+		}
+		mpz_set_str (rctx->pub_exp, p2, 10);
 		return 1;
 
-		case EVP_PKEY_CTRL_MD:
-		if (!check_padding_md(p2, rctx->pad_mode))
+	case EVP_PKEY_CTRL_MD:
+		if (!check_padding_md (p2, rctx->pad_mode)) {
 			return 0;
+		}
 		rctx->md = p2;
 		return 1;
 
-		case EVP_PKEY_CTRL_RSA_MGF1_MD:
-		case EVP_PKEY_CTRL_GET_RSA_MGF1_MD:
-		if (rctx->pad_mode != RSA_PKCS1_PSS_PADDING)
-			{
+	case EVP_PKEY_CTRL_RSA_MGF1_MD:
+	case EVP_PKEY_CTRL_GET_RSA_MGF1_MD:
+		if (rctx->pad_mode != RSA_PKCS1_PSS_PADDING) {
 			RSAerr(RSA_F_PKEY_RSA_CTRL, RSA_R_INVALID_MGF1_MD);
 			return -2;
+		}
+		if (type == EVP_PKEY_CTRL_GET_RSA_MGF1_MD) {
+			if (rctx->mgf1md) {
+				*(const EVP_MD**)p2 = rctx->mgf1md;
+			} else {
+				*(const EVP_MD**)p2 = rctx->md;
 			}
-		if (type == EVP_PKEY_CTRL_GET_RSA_MGF1_MD)
-			{
-			if (rctx->mgf1md)
-				*(const EVP_MD **)p2 = rctx->mgf1md;
-			else
-				*(const EVP_MD **)p2 = rctx->md;
-			}
-		else
+		} else {
 			rctx->mgf1md = p2;
+		}
 		return 1;
 
-		case EVP_PKEY_CTRL_DIGESTINIT:
-		case EVP_PKEY_CTRL_PKCS7_ENCRYPT:
-		case EVP_PKEY_CTRL_PKCS7_DECRYPT:
-		case EVP_PKEY_CTRL_PKCS7_SIGN:
+	case EVP_PKEY_CTRL_DIGESTINIT:
+	case EVP_PKEY_CTRL_PKCS7_ENCRYPT:
+	case EVP_PKEY_CTRL_PKCS7_DECRYPT:
+	case EVP_PKEY_CTRL_PKCS7_SIGN:
 		return 1;
+
 #ifndef OPENSSL_NO_CMS
-		case EVP_PKEY_CTRL_CMS_DECRYPT:
-		{
-		X509_ALGOR *alg = NULL;
-		ASN1_OBJECT *encalg = NULL;
-		if (p2)
-			CMS_RecipientInfo_ktri_get0_algs(p2, NULL, NULL, &alg);
-		if (alg)
-			X509_ALGOR_get0(&encalg, NULL, NULL, alg);
-		if (encalg && OBJ_obj2nid(encalg) == NID_rsaesOaep)
+	case EVP_PKEY_CTRL_CMS_DECRYPT:
+	{
+		X509_ALGOR* alg = NULL;
+		ASN1_OBJECT* encalg = NULL;
+		if (p2) {
+			CMS_RecipientInfo_ktri_get0_algs (p2, NULL, NULL, &alg);
+		}
+		if (alg) {
+			X509_ALGOR_get0 (&encalg, NULL, NULL, alg);
+		}
+		if (encalg && OBJ_obj2nid (encalg) == NID_rsaesOaep) {
 			rctx->pad_mode = RSA_PKCS1_OAEP_PADDING;
 		}
-		case EVP_PKEY_CTRL_CMS_ENCRYPT:
-		case EVP_PKEY_CTRL_CMS_SIGN:
+	}
+	case EVP_PKEY_CTRL_CMS_ENCRYPT:
+	case EVP_PKEY_CTRL_CMS_SIGN:
 		return 1;
 #endif
-		case EVP_PKEY_CTRL_PEER_KEY:
-			RSAerr(RSA_F_PKEY_RSA_CTRL,
+
+	case EVP_PKEY_CTRL_PEER_KEY:
+		RSAerr(RSA_F_PKEY_RSA_CTRL,
 			RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);
-			return -2;	
+		return -2;	
 
-		default:
+	default:
 		return -2;
-
-		}
 	}
+}
 			
-static int pkey_rsa_ctrl_str(EVP_PKEY_CTX *ctx,
-			const char *type, const char *value)
-	{
-	if (!value)
-		{
+static int pkey_rsa_ctrl_str( EVP_PKEY_CTX* ctx,
+			const char* type, const char* value )
+{
+	if (!value) {
 		RSAerr(RSA_F_PKEY_RSA_CTRL_STR, RSA_R_VALUE_MISSING);
 		return 0;
-		}
-	if (!strcmp(type, "rsa_padding_mode"))
-		{
+	}
+
+	if (!strcmp (type, "rsa_padding_mode")) {
 		int pm;
-		if (!strcmp(value, "pkcs1"))
+		if (!strcmp (value, "pkcs1")) {
 			pm = RSA_PKCS1_PADDING;
-		else if (!strcmp(value, "sslv23"))
+		} else if (!strcmp (value, "sslv23")) {
 			pm = RSA_SSLV23_PADDING;
-		else if (!strcmp(value, "none"))
+		} else if (!strcmp (value, "none")) {
 			pm = RSA_NO_PADDING;
-		else if (!strcmp(value, "oeap"))
+		} else if (!strcmp (value, "oeap")) {
 			pm = RSA_PKCS1_OAEP_PADDING;
-		else if (!strcmp(value, "x931"))
+		} else if (!strcmp (value, "x931")) {
 			pm = RSA_X931_PADDING;
-		else if (!strcmp(value, "pss"))
+		} else if (!strcmp (value, "pss")) {
 			pm = RSA_PKCS1_PSS_PADDING;
-		else
-			{
+		} else {
 			RSAerr(RSA_F_PKEY_RSA_CTRL_STR,
-						RSA_R_UNKNOWN_PADDING_TYPE);
+				RSA_R_UNKNOWN_PADDING_TYPE);
 			return -2;
-			}
-		return EVP_PKEY_CTX_set_rsa_padding(ctx, pm);
 		}
+		return EVP_PKEY_CTX_set_rsa_padding (ctx, pm);
+	}
 
-	if (!strcmp(type, "rsa_pss_saltlen"))
-		{
-		int saltlen;
-		saltlen = atoi(value);
-		return EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, saltlen);
-		}
+	if (!strcmp (type, "rsa_pss_saltlen")) {
+		return EVP_PKEY_CTX_set_rsa_pss_saltlen (ctx, atoi (value));
+	}
 
-	if (!strcmp(type, "rsa_keygen_bits"))
-		{
-		int nbits;
-		nbits = atoi(value);
-		return EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, nbits);
-		}
+	if (!strcmp (type, "rsa_keygen_bits")) {
+		return EVP_PKEY_CTX_set_rsa_keygen_bits (ctx, atoi (value));
+	}
 
-	if (!strcmp(type, "rsa_keygen_pubexp"))
-		{
-		int ret;
-		BIGNUM *pubexp = NULL;
-		if (!BN_asc2bn(&pubexp, value))
-			return 0;
-		ret = EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp);
-		if (ret <= 0)
-			BN_free(pubexp);
-		return ret;
-		}
+	if (!strcmp (type, "rsa_keygen_pubexp")) {
+		return EVP_PKEY_CTX_set_rsa_keygen_pubexp (ctx, (char*)value);
+	}
 
 	return -2;
-	}
+}
 
-static int pkey_rsa_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey)
-	{
-	RSA *rsa = NULL;
-	RSA_PKEY_CTX *rctx = ctx->data;
-	BN_GENCB *pcb, cb;
+static int pkey_rsa_keygen( EVP_PKEY_CTX* ctx, EVP_PKEY* pkey )
+{
+	RSA* rsa;
+	PRSA_PKEY_CTX rctx = ctx->data;
 	int ret;
-	if (!rctx->pub_exp)
-		{
-		rctx->pub_exp = BN_new();
-		if (!rctx->pub_exp || !BN_set_word(rctx->pub_exp, RSA_F4))
-			return 0;
-		}
-	rsa = RSA_new();
-	if (!rsa)
+	if (!mpz_cmp_ui (rctx->pub_exp, 0)) {
+		mpz_set_ui (rctx->pub_exp, RSA_F4);
+	}
+	rsa = RSA_new ();
+	if (!rsa) {
 		return 0;
-	if (ctx->pkey_gencb)
-		{
-		pcb = &cb;
-		evp_pkey_set_cb_translate(pcb, ctx);
-		}
-	else
-		pcb = NULL;
-	ret = RSA_generate_key_ex(rsa, rctx->nbits, rctx->pub_exp, pcb);
+	}
+	ret = RSA_generate_key_ex (rsa, rctx->nbits, rctx->pub_exp);
 	if (ret > 0)
-		EVP_PKEY_assign_RSA(pkey, rsa);
+		EVP_PKEY_assign_RSA (pkey, rsa);
 	else
-		RSA_free(rsa);
+		RSA_free (rsa);
+
 	return ret;
-	}
+}
 
-const EVP_PKEY_METHOD rsa_pkey_meth = 
-	{
+const EVP_PKEY_METHOD rsa_pkey_meth = {
 	EVP_PKEY_RSA,
 	EVP_PKEY_FLAG_AUTOARGLEN,
 	pkey_rsa_init,
 	pkey_rsa_copy,
 	pkey_rsa_cleanup,
-
 	0,0,
-
 	0,
 	pkey_rsa_keygen,
-
 	0,
 	pkey_rsa_sign,
-
 	0,
 	pkey_rsa_verify,
-
 	0,
 	pkey_rsa_verifyrecover,
-
-
 	0,0,0,0,
-
 	0,
 	pkey_rsa_encrypt,
-
 	0,
 	pkey_rsa_decrypt,
-
 	0,0,
-
 	pkey_rsa_ctrl,
 	pkey_rsa_ctrl_str
-
-
-	};
+};
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_prn.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_prn.c
--- openssl-1.0.1e/crypto/rsa/rsa_prn.c	2013-04-24 22:21:55.207799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_prn.c	2013-04-24 22:11:07.039800019 +0800
@@ -91,3 +91,13 @@
 	return ret;
 	}
 
+int MPZ_print( BIO* bp, const mpz_t r )
+{
+	char buf[2048];
+	int len = mpz_sizeinbase (r, 16) + (mpz_cmp_si (r, 0) < 0 ? 1 : 0);
+	if ((len <= sizeof(buf) - 1) &&
+		(BIO_write (bp, mpz_get_str (buf, -16, r), len) == len)) {
+		return 1;
+	}
+	return 0;
+}
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_pss.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_pss.c
--- openssl-1.0.1e/crypto/rsa/rsa_pss.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_pss.c	2013-04-24 22:11:07.039800019 +0800
@@ -1,93 +1,43 @@
 /* rsa_pss.c */
-/* Written by Dr Stephen N Henson (steve@openssl.org) for the OpenSSL
- * project 2005.
- */
-/* ====================================================================
- * Copyright (c) 2005 The OpenSSL Project.  All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer. 
- *
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * 3. All advertising materials mentioning features or use of this
- *    software must display the following acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
- *
- * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
- *    endorse or promote products derived from this software without
- *    prior written permission. For written permission, please contact
- *    licensing@OpenSSL.org.
- *
- * 5. Products derived from this software may not be called "OpenSSL"
- *    nor may "OpenSSL" appear in their names without prior written
- *    permission of the OpenSSL Project.
- *
- * 6. Redistributions of any form whatsoever must retain the following
- *    acknowledgment:
- *    "This product includes software developed by the OpenSSL Project
- *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
- *
- * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
- * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- * OF THE POSSIBILITY OF SUCH DAMAGE.
- * ====================================================================
- *
- * This product includes cryptographic software written by Eric Young
- * (eay@cryptsoft.com).  This product includes software written by Tim
- * Hudson (tjh@cryptsoft.com).
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
  *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
  */
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/evp.h>
 #include <openssl/rand.h>
 #include <openssl/sha.h>
 
-static const unsigned char zeroes[] = {0,0,0,0,0,0,0,0};
+static const unsigned char zeroes[] = { 0,0,0,0,0,0,0,0 };
 
 #if defined(_MSC_VER) && defined(_ARM_)
 #pragma optimize("g", off)
 #endif
 
-int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
-			const EVP_MD *Hash, const unsigned char *EM, int sLen)
-	{
-	return RSA_verify_PKCS1_PSS_mgf1(rsa, mHash, Hash, NULL, EM, sLen);
-	}
-
-int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
-			const EVP_MD *Hash, const EVP_MD *mgf1Hash,
-			const unsigned char *EM, int sLen)
-	{
-	int i;
+int RSA_verify_PKCS1_PSS( RSA* rsa, const unsigned char* mHash,
+	const EVP_MD* Hash, const unsigned char* EM, int sLen )
+{
+	return RSA_verify_PKCS1_PSS_mgf1 (rsa, mHash, Hash, NULL, EM, sLen);
+}
+
+int RSA_verify_PKCS1_PSS_mgf1( RSA* rsa, const unsigned char* mHash,
+	const EVP_MD* Hash, const EVP_MD* mgf1Hash,
+	const unsigned char* EM, int sLen )
+{
 	int ret = 0;
-	int hLen, maskedDBLen, MSBits, emLen;
-	const unsigned char *H;
-	unsigned char *DB = NULL;
+	int i, hLen, maskedDBLen, MSBits, emLen;
+	const unsigned char* H;
+	unsigned char* DB = NULL;
 	EVP_MD_CTX ctx;
 	unsigned char H_[EVP_MAX_MD_SIZE];
-	EVP_MD_CTX_init(&ctx);
+
+	EVP_MD_CTX_init (&ctx);
 
 	if (mgf1Hash == NULL)
 		mgf1Hash = Hash;
@@ -109,7 +59,7 @@
 		goto err;
 		}
 
-	MSBits = (BN_num_bits(rsa->n) - 1) & 0x7;
+	MSBits = (mpz_sizeinbase (rsa->n, 2) - 1) & 0x7;
 	emLen = RSA_size(rsa);
 	if (EM[0] & (0xFF << MSBits))
 		{
@@ -184,21 +134,21 @@
 
 	}
 
-int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
-			const unsigned char *mHash,
-			const EVP_MD *Hash, int sLen)
+int RSA_padding_add_PKCS1_PSS( RSA* rsa, unsigned char* EM,
+			const unsigned char* mHash,
+			const EVP_MD* Hash, int sLen )
 	{
 	return RSA_padding_add_PKCS1_PSS_mgf1(rsa, EM, mHash, Hash, NULL, sLen);
 	}
 
-int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
-			const unsigned char *mHash,
-			const EVP_MD *Hash, const EVP_MD *mgf1Hash, int sLen)
+int RSA_padding_add_PKCS1_PSS_mgf1( RSA* rsa, unsigned char* EM,
+			const unsigned char* mHash,
+			const EVP_MD* Hash, const EVP_MD* mgf1Hash, int sLen )
 	{
 	int i;
 	int ret = 0;
 	int hLen, maskedDBLen, MSBits, emLen;
-	unsigned char *H, *salt = NULL, *p;
+	unsigned char* H, *salt = NULL, *p;
 	EVP_MD_CTX ctx;
 
 	if (mgf1Hash == NULL)
@@ -221,7 +171,7 @@
 		goto err;
 		}
 
-	MSBits = (BN_num_bits(rsa->n) - 1) & 0x7;
+	MSBits = (mpz_sizeinbase (rsa->n, 2) - 1) & 0x7;
 	emLen = RSA_size(rsa);
 	if (MSBits == 0)
 		{
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_saos.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_saos.c
--- openssl-1.0.1e/crypto/rsa/rsa_saos.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_saos.c	2013-04-24 22:11:07.039800019 +0800
@@ -58,7 +58,6 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/objects.h>
 #include <openssl/x509.h>
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_sign.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_sign.c
--- openssl-1.0.1e/crypto/rsa/rsa_sign.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_sign.c	2013-04-24 22:11:07.040800019 +0800
@@ -58,7 +58,6 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/objects.h>
 #include <openssl/x509.h>
@@ -67,16 +66,17 @@
 /* Size of an SSL signature: MD5+SHA1 */
 #define SSL_SIG_LENGTH	36
 
-int RSA_sign(int type, const unsigned char *m, unsigned int m_len,
-	     unsigned char *sigret, unsigned int *siglen, RSA *rsa)
+int RSA_sign(int type, const unsigned char* m, unsigned int m_len,
+	     unsigned char* sigret, unsigned int *siglen, RSA* rsa)
 	{
 	X509_SIG sig;
 	ASN1_TYPE parameter;
 	int i,j,ret=1;
-	unsigned char *p, *tmps = NULL;
-	const unsigned char *s = NULL;
+	unsigned char* p, *tmps = NULL;
+	const unsigned char* s = NULL;
 	X509_ALGOR algor;
 	ASN1_OCTET_STRING digest;
+//printf ("IN rsa->meth=%p ", rsa->meth);
 #ifdef OPENSSL_FIPS
 	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
 			&& !(rsa->flags & RSA_FLAG_NON_FIPS_ALLOW))
@@ -116,7 +116,7 @@
 		sig.algor->parameter= &parameter;
 
 		sig.digest= &digest;
-		sig.digest->data=(unsigned char *)m; /* TMP UGLY CAST */
+		sig.digest->data=(unsigned char*)m; /* TMP UGLY CAST */
 		sig.digest->length=m_len;
 
 		i=i2d_X509_SIG(&sig,NULL);
@@ -128,7 +128,7 @@
 		return(0);
 		}
 	if(type != NID_md5_sha1) {
-		tmps=(unsigned char *)OPENSSL_malloc((unsigned int)j+1);
+		tmps=(unsigned char*)OPENSSL_malloc((unsigned int)j+1);
 		if (tmps == NULL)
 			{
 			RSAerr(RSA_F_RSA_SIGN,ERR_R_MALLOC_FAILURE);
@@ -138,6 +138,7 @@
 		i2d_X509_SIG(&sig,&p);
 		s=tmps;
 	}
+//printf ("rsa->meth(%p)->rsa_priv_enc=%p ", rsa->meth, rsa->meth->rsa_priv_enc);
 	i=RSA_private_encrypt(i,s,sigret,rsa,RSA_PKCS1_PADDING);
 	if (i <= 0)
 		ret=0;
@@ -151,15 +152,15 @@
 	return(ret);
 	}
 
-int int_rsa_verify(int dtype, const unsigned char *m,
-			  unsigned int m_len,
-			  unsigned char *rm, size_t *prm_len,
-			  const unsigned char *sigbuf, size_t siglen,
-			  RSA *rsa)
-	{
-	int i,ret=0,sigtype;
-	unsigned char *s;
-	X509_SIG *sig=NULL;
+int int_rsa_verify( int dtype,
+	const unsigned char* m, unsigned int m_len,
+	unsigned char* rm, size_t* prm_len,
+	const unsigned char* sigbuf, size_t siglen,
+	RSA* rsa )
+{
+	int i, ret = 0, sigtype;
+	unsigned char* s;
+	X509_SIG* sig = NULL;
 
 #ifdef OPENSSL_FIPS
 	if (FIPS_mode() && !(rsa->meth->flags & RSA_FLAG_FIPS_METHOD)
@@ -186,19 +187,19 @@
 		return 1;
 		}
 
-	s=(unsigned char *)OPENSSL_malloc((unsigned int)siglen);
-	if (s == NULL)
-		{
+	s = (unsigned char*)OPENSSL_malloc((unsigned int)siglen);
+	if (s == NULL) {
 		RSAerr(RSA_F_INT_RSA_VERIFY,ERR_R_MALLOC_FAILURE);
 		goto err;
-		}
-	if((dtype == NID_md5_sha1) && (m_len != SSL_SIG_LENGTH) ) {
-			RSAerr(RSA_F_INT_RSA_VERIFY,RSA_R_INVALID_MESSAGE_LENGTH);
-			goto err;
 	}
-	i=RSA_public_decrypt((int)siglen,sigbuf,s,rsa,RSA_PKCS1_PADDING);
+	if ((dtype == NID_md5_sha1) && (m_len != SSL_SIG_LENGTH) ) {
+		RSAerr(RSA_F_INT_RSA_VERIFY,RSA_R_INVALID_MESSAGE_LENGTH);
+		goto err;
+	}
 
+	i = RSA_public_decrypt ((int)siglen, sigbuf, s, rsa, RSA_PKCS1_PADDING);
 	if (i <= 0) goto err;
+
 	/* Oddball MDC2 case: signature can be OCTET STRING.
 	 * check for correct tag and length octets.
 	 */
@@ -222,7 +223,7 @@
 				RSAerr(RSA_F_INT_RSA_VERIFY,RSA_R_BAD_SIGNATURE);
 		else ret = 1;
 	} else {
-		const unsigned char *p=s;
+		const unsigned char* p=s;
 		sig=d2i_X509_SIG(NULL,&p,(long)i);
 
 		if (sig == NULL) goto err;
@@ -245,7 +246,6 @@
 
 		sigtype=OBJ_obj2nid(sig->algor->algorithm);
 
-
 	#ifdef RSA_DEBUG
 		/* put a backward compatibility flag in EAY */
 		fprintf(stderr,"in(%s) expect(%s)\n",OBJ_nid2ln(sigtype),
@@ -270,6 +270,7 @@
 				goto err;
 				}
 			}
+
 		if (rm)
 			{
 			const EVP_MD *md;
@@ -293,7 +294,9 @@
 		else
 			ret=1;
 	}
+
 err:
+
 	if (sig != NULL) X509_SIG_free(sig);
 	if (s != NULL)
 		{
@@ -303,16 +306,15 @@
 	return(ret);
 	}
 
-int RSA_verify(int dtype, const unsigned char *m, unsigned int m_len,
-		const unsigned char *sigbuf, unsigned int siglen,
-		RSA *rsa)
-	{
-
-	if((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_verify)
-		{
+int RSA_verify( int dtype,
+	const unsigned char* m, unsigned int m_len,
+	const unsigned char* sigbuf, unsigned int siglen,
+	RSA* rsa )
+{
+	if ((rsa->flags & RSA_FLAG_SIGN_VER) && rsa->meth->rsa_verify) {
 		return rsa->meth->rsa_verify(dtype, m, m_len,
 			sigbuf, siglen, rsa);
-		}
+	}
 
 	return int_rsa_verify(dtype, m, m_len, NULL, NULL, sigbuf, siglen, rsa);
-	}
+}
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_ssl.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_ssl.c
--- openssl-1.0.1e/crypto/rsa/rsa_ssl.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_ssl.c	2013-04-24 22:11:07.040800019 +0800
@@ -58,7 +58,6 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_test.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_test.c
--- openssl-1.0.1e/crypto/rsa/rsa_test.c	2013-04-24 22:22:43.725799367 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_test.c	2013-04-24 22:11:07.040800020 +0800
@@ -1,4 +1,11 @@
 /* test vectors from p1ovect1.txt */
+/* Copyright (C) 2013 Huang Le
+ * All rights reserved.
+ *
+ * This package is an RSA implementation written
+ * by Huang Le (Eric, DaZe@alipay, le.hl@alipay.com, 4tarhl@gmail.com)
+ * to be compatiable with orignal OpenSSL RSA implementation.
+ */
 
 #include <stdio.h>
 #include <string.h>
@@ -8,125 +15,130 @@
 #include <openssl/crypto.h>
 #include <openssl/err.h>
 #include <openssl/rand.h>
-#include <openssl/bn.h>
+
 #ifdef OPENSSL_NO_RSA
+
 int main(int argc, char *argv[])
 {
-    printf("No RSA support\n");
-    return(0);
+	printf("No RSA support\n");
+	return(0);
 }
+
 #else
+
 #include <openssl/rsa.h>
 
+#define SetMpz(r,s) mpz_import (r, sizeof(s) - 1, 1, 1, 0, 0, s)
+#define SetMpzSwt(r,s,w) \
+	mpz_import (r, sizeof(s) - 1, 1, 1, 0, 0, s),	\
+	mpz_create_swt (&(w), r);
+
 #define SetKey \
-  key->n = BN_bin2bn(n, sizeof(n)-1, key->n); \
-  key->e = BN_bin2bn(e, sizeof(e)-1, key->e); \
-  key->d = BN_bin2bn(d, sizeof(d)-1, key->d); \
-  key->p = BN_bin2bn(p, sizeof(p)-1, key->p); \
-  key->q = BN_bin2bn(q, sizeof(q)-1, key->q); \
-  key->dmp1 = BN_bin2bn(dmp1, sizeof(dmp1)-1, key->dmp1); \
-  key->dmq1 = BN_bin2bn(dmq1, sizeof(dmq1)-1, key->dmq1); \
-  key->iqmp = BN_bin2bn(iqmp, sizeof(iqmp)-1, key->iqmp); \
-  memcpy(c, ctext_ex, sizeof(ctext_ex) - 1); \
-  return (sizeof(ctext_ex) - 1);
+	SetMpz(key->n, n), SetMpz(key->e, e), SetMpz(key->d, d);	\
+	SetMpz(key->p, p), SetMpz(key->q, q);						\
+	SetMpzSwt(key->dmp1, dmp1, key->swdmp1);					\
+	SetMpzSwt(key->dmq1, dmq1, key->swdmq1);					\
+	SetMpz(key->iqmp, iqmp);									\
+	memcpy (c, ctext_ex, sizeof(ctext_ex) - 1);					\
+	return sizeof(ctext_ex) - 1;
 
 static int key1(RSA *key, unsigned char *c)
-    {
-    static unsigned char n[] =
+	{
+	static unsigned char n[] =
 "\x00\xAA\x36\xAB\xCE\x88\xAC\xFD\xFF\x55\x52\x3C\x7F\xC4\x52\x3F"
 "\x90\xEF\xA0\x0D\xF3\x77\x4A\x25\x9F\x2E\x62\xB4\xC5\xD9\x9C\xB5"
 "\xAD\xB3\x00\xA0\x28\x5E\x53\x01\x93\x0E\x0C\x70\xFB\x68\x76\x93"
 "\x9C\xE6\x16\xCE\x62\x4A\x11\xE0\x08\x6D\x34\x1E\xBC\xAC\xA0\xA1"
 "\xF5";
 
-    static unsigned char e[] = "\x11";
+	static unsigned char e[] = "\x11";
 
-    static unsigned char d[] =
+	static unsigned char d[] =
 "\x0A\x03\x37\x48\x62\x64\x87\x69\x5F\x5F\x30\xBC\x38\xB9\x8B\x44"
 "\xC2\xCD\x2D\xFF\x43\x40\x98\xCD\x20\xD8\xA1\x38\xD0\x90\xBF\x64"
 "\x79\x7C\x3F\xA7\xA2\xCD\xCB\x3C\xD1\xE0\xBD\xBA\x26\x54\xB4\xF9"
 "\xDF\x8E\x8A\xE5\x9D\x73\x3D\x9F\x33\xB3\x01\x62\x4A\xFD\x1D\x51";
 
-    static unsigned char p[] =
+	static unsigned char p[] =
 "\x00\xD8\x40\xB4\x16\x66\xB4\x2E\x92\xEA\x0D\xA3\xB4\x32\x04\xB5"
 "\xCF\xCE\x33\x52\x52\x4D\x04\x16\xA5\xA4\x41\xE7\x00\xAF\x46\x12"
 "\x0D";
-    
-    static unsigned char q[] =
+	
+	static unsigned char q[] =
 "\x00\xC9\x7F\xB1\xF0\x27\xF4\x53\xF6\x34\x12\x33\xEA\xAA\xD1\xD9"
 "\x35\x3F\x6C\x42\xD0\x88\x66\xB1\xD0\x5A\x0F\x20\x35\x02\x8B\x9D"
 "\x89";
 
-    static unsigned char dmp1[] =
+	static unsigned char dmp1[] =
 "\x59\x0B\x95\x72\xA2\xC2\xA9\xC4\x06\x05\x9D\xC2\xAB\x2F\x1D\xAF"
 "\xEB\x7E\x8B\x4F\x10\xA7\x54\x9E\x8E\xED\xF5\xB4\xFC\xE0\x9E\x05";
 
-    static unsigned char dmq1[] =
+	static unsigned char dmq1[] =
 "\x00\x8E\x3C\x05\x21\xFE\x15\xE0\xEA\x06\xA3\x6F\xF0\xF1\x0C\x99"
 "\x52\xC3\x5B\x7A\x75\x14\xFD\x32\x38\xB8\x0A\xAD\x52\x98\x62\x8D"
 "\x51";
 
-    static unsigned char iqmp[] =
+	static unsigned char iqmp[] =
 "\x36\x3F\xF7\x18\x9D\xA8\xE9\x0B\x1D\x34\x1F\x71\xD0\x9B\x76\xA8"
 "\xA9\x43\xE1\x1D\x10\xB2\x4D\x24\x9F\x2D\xEA\xFE\xF8\x0C\x18\x26";
 
-    static unsigned char ctext_ex[] =
+	static unsigned char ctext_ex[] =
 "\x1b\x8f\x05\xf9\xca\x1a\x79\x52\x6e\x53\xf3\xcc\x51\x4f\xdb\x89"
 "\x2b\xfb\x91\x93\x23\x1e\x78\xb9\x92\xe6\x8d\x50\xa4\x80\xcb\x52"
 "\x33\x89\x5c\x74\x95\x8d\x5d\x02\xab\x8c\x0f\xd0\x40\xeb\x58\x44"
 "\xb0\x05\xc3\x9e\xd8\x27\x4a\x9d\xbf\xa8\x06\x71\x40\x94\x39\xd2";
 
-    SetKey;
-    }
+	SetKey;
+	}
 
 static int key2(RSA *key, unsigned char *c)
-    {
-    static unsigned char n[] =
+	{
+	static unsigned char n[] =
 "\x00\xA3\x07\x9A\x90\xDF\x0D\xFD\x72\xAC\x09\x0C\xCC\x2A\x78\xB8"
 "\x74\x13\x13\x3E\x40\x75\x9C\x98\xFA\xF8\x20\x4F\x35\x8A\x0B\x26"
 "\x3C\x67\x70\xE7\x83\xA9\x3B\x69\x71\xB7\x37\x79\xD2\x71\x7B\xE8"
 "\x34\x77\xCF";
 
-    static unsigned char e[] = "\x3";
+	static unsigned char e[] = "\x3";
 
-    static unsigned char d[] =
+	static unsigned char d[] =
 "\x6C\xAF\xBC\x60\x94\xB3\xFE\x4C\x72\xB0\xB3\x32\xC6\xFB\x25\xA2"
 "\xB7\x62\x29\x80\x4E\x68\x65\xFC\xA4\x5A\x74\xDF\x0F\x8F\xB8\x41"
 "\x3B\x52\xC0\xD0\xE5\x3D\x9B\x59\x0F\xF1\x9B\xE7\x9F\x49\xDD\x21"
 "\xE5\xEB";
 
-    static unsigned char p[] =
+	static unsigned char p[] =
 "\x00\xCF\x20\x35\x02\x8B\x9D\x86\x98\x40\xB4\x16\x66\xB4\x2E\x92"
 "\xEA\x0D\xA3\xB4\x32\x04\xB5\xCF\xCE\x91";
 
-    static unsigned char q[] =
+	static unsigned char q[] =
 "\x00\xC9\x7F\xB1\xF0\x27\xF4\x53\xF6\x34\x12\x33\xEA\xAA\xD1\xD9"
 "\x35\x3F\x6C\x42\xD0\x88\x66\xB1\xD0\x5F";
-    
-    static unsigned char dmp1[] =
+	
+	static unsigned char dmp1[] =
 "\x00\x8A\x15\x78\xAC\x5D\x13\xAF\x10\x2B\x22\xB9\x99\xCD\x74\x61"
 "\xF1\x5E\x6D\x22\xCC\x03\x23\xDF\xDF\x0B";
 
-    static unsigned char dmq1[] =
+	static unsigned char dmq1[] =
 "\x00\x86\x55\x21\x4A\xC5\x4D\x8D\x4E\xCD\x61\x77\xF1\xC7\x36\x90"
 "\xCE\x2A\x48\x2C\x8B\x05\x99\xCB\xE0\x3F";
 
-    static unsigned char iqmp[] =
+	static unsigned char iqmp[] =
 "\x00\x83\xEF\xEF\xB8\xA9\xA4\x0D\x1D\xB6\xED\x98\xAD\x84\xED\x13"
 "\x35\xDC\xC1\x08\xF3\x22\xD0\x57\xCF\x8D";
 
-    static unsigned char ctext_ex[] =
+	static unsigned char ctext_ex[] =
 "\x14\xbd\xdd\x28\xc9\x83\x35\x19\x23\x80\xe8\xe5\x49\xb1\x58\x2a"
 "\x8b\x40\xb4\x48\x6d\x03\xa6\xa5\x31\x1f\x1f\xd5\xf0\xa1\x80\xe4"
 "\x17\x53\x03\x29\xa9\x34\x90\x74\xb1\x52\x13\x54\x29\x08\x24\x52"
 "\x62\x51";
 
-    SetKey;
-    }
+	SetKey;
+	}
 
 static int key3(RSA *key, unsigned char *c)
-    {
-    static unsigned char n[] =
+	{
+	static unsigned char n[] =
 "\x00\xBB\xF8\x2F\x09\x06\x82\xCE\x9C\x23\x38\xAC\x2B\x9D\xA8\x71"
 "\xF7\x36\x8D\x07\xEE\xD4\x10\x43\xA4\x40\xD6\xB6\xF0\x74\x54\xF5"
 "\x1F\xB8\xDF\xBA\xAF\x03\x5C\x02\xAB\x61\xEA\x48\xCE\xEB\x6F\xCD"
@@ -137,9 +149,9 @@
 "\x7F\xE2\x53\x72\x98\xCA\x2A\x8F\x59\x46\xF8\xE5\xFD\x09\x1D\xBD"
 "\xCB";
 
-    static unsigned char e[] = "\x11";
+	static unsigned char e[] = "\x11";
 
-    static unsigned char d[] =
+	static unsigned char d[] =
 "\x00\xA5\xDA\xFC\x53\x41\xFA\xF2\x89\xC4\xB9\x88\xDB\x30\xC1\xCD"
 "\xF8\x3F\x31\x25\x1E\x06\x68\xB4\x27\x84\x81\x38\x01\x57\x96\x41"
 "\xB2\x94\x10\xB3\xC7\x99\x8D\x6B\xC4\x65\x74\x5E\x5C\x39\x26\x69"
@@ -150,40 +162,40 @@
 "\xAF\x94\x28\xC2\xB7\xB8\x88\x3F\xE4\x46\x3A\x4B\xC8\x5B\x1C\xB3"
 "\xC1";
 
-    static unsigned char p[] =
+	static unsigned char p[] =
 "\x00\xEE\xCF\xAE\x81\xB1\xB9\xB3\xC9\x08\x81\x0B\x10\xA1\xB5\x60"
 "\x01\x99\xEB\x9F\x44\xAE\xF4\xFD\xA4\x93\xB8\x1A\x9E\x3D\x84\xF6"
 "\x32\x12\x4E\xF0\x23\x6E\x5D\x1E\x3B\x7E\x28\xFA\xE7\xAA\x04\x0A"
 "\x2D\x5B\x25\x21\x76\x45\x9D\x1F\x39\x75\x41\xBA\x2A\x58\xFB\x65"
 "\x99";
 
-    static unsigned char q[] =
+	static unsigned char q[] =
 "\x00\xC9\x7F\xB1\xF0\x27\xF4\x53\xF6\x34\x12\x33\xEA\xAA\xD1\xD9"
 "\x35\x3F\x6C\x42\xD0\x88\x66\xB1\xD0\x5A\x0F\x20\x35\x02\x8B\x9D"
 "\x86\x98\x40\xB4\x16\x66\xB4\x2E\x92\xEA\x0D\xA3\xB4\x32\x04\xB5"
 "\xCF\xCE\x33\x52\x52\x4D\x04\x16\xA5\xA4\x41\xE7\x00\xAF\x46\x15"
 "\x03";
 
-    static unsigned char dmp1[] =
+	static unsigned char dmp1[] =
 "\x54\x49\x4C\xA6\x3E\xBA\x03\x37\xE4\xE2\x40\x23\xFC\xD6\x9A\x5A"
 "\xEB\x07\xDD\xDC\x01\x83\xA4\xD0\xAC\x9B\x54\xB0\x51\xF2\xB1\x3E"
 "\xD9\x49\x09\x75\xEA\xB7\x74\x14\xFF\x59\xC1\xF7\x69\x2E\x9A\x2E"
 "\x20\x2B\x38\xFC\x91\x0A\x47\x41\x74\xAD\xC9\x3C\x1F\x67\xC9\x81";
 
-    static unsigned char dmq1[] =
+	static unsigned char dmq1[] =
 "\x47\x1E\x02\x90\xFF\x0A\xF0\x75\x03\x51\xB7\xF8\x78\x86\x4C\xA9"
 "\x61\xAD\xBD\x3A\x8A\x7E\x99\x1C\x5C\x05\x56\xA9\x4C\x31\x46\xA7"
 "\xF9\x80\x3F\x8F\x6F\x8A\xE3\x42\xE9\x31\xFD\x8A\xE4\x7A\x22\x0D"
 "\x1B\x99\xA4\x95\x84\x98\x07\xFE\x39\xF9\x24\x5A\x98\x36\xDA\x3D";
-    
-    static unsigned char iqmp[] =
+	
+	static unsigned char iqmp[] =
 "\x00\xB0\x6C\x4F\xDA\xBB\x63\x01\x19\x8D\x26\x5B\xDB\xAE\x94\x23"
 "\xB3\x80\xF2\x71\xF7\x34\x53\x88\x50\x93\x07\x7F\xCD\x39\xE2\x11"
 "\x9F\xC9\x86\x32\x15\x4F\x58\x83\xB1\x67\xA9\x67\xBF\x40\x2B\x4E"
 "\x9E\x2E\x0F\x96\x56\xE6\x98\xEA\x36\x66\xED\xFB\x25\x79\x80\x39"
 "\xF7";
 
-    static unsigned char ctext_ex[] =
+	static unsigned char ctext_ex[] =
 "\xb8\x24\x6b\x56\xa6\xed\x58\x81\xae\xb5\x85\xd9\xa2\x5b\x2a\xd7"
 "\x90\xc4\x17\xe0\x80\x68\x1b\xf1\xac\x2b\xc3\xde\xb6\x9d\x8b\xce"
 "\xf0\xc4\x36\x6f\xec\x40\x0a\xf0\x52\xa7\x2e\x9b\x0e\xff\xb5\xb3"
@@ -193,36 +205,36 @@
 "\x74\xb2\x6f\x7c\x48\xb4\x2e\xe6\x8e\x1f\x57\x2a\x1f\xc4\x02\x6a"
 "\xc4\x56\xb4\xf5\x9f\x7b\x62\x1e\xa1\xb9\xd8\x8f\x64\x20\x2f\xb1";
 
-    SetKey;
-    }
+	SetKey;
+	}
 
 static int pad_unknown(void)
 {
-    unsigned long l;
-    while ((l = ERR_get_error()) != 0)
-      if (ERR_GET_REASON(l) == RSA_R_UNKNOWN_PADDING_TYPE)
-	return(1);
-    return(0);
+	unsigned long l;
+	while ((l = ERR_get_error()) != 0)
+		if (ERR_GET_REASON(l) == RSA_R_UNKNOWN_PADDING_TYPE)
+			return(1);
+	return(0);
 }
 
 static const char rnd_seed[] = "string to make the random number generator think it has entropy";
 
 int main(int argc, char *argv[])
-    {
-    int v, num, n, t, plen, clen = 0, err = 0;
-    RSA *key;
-    unsigned char ptext[256], ttext[256], ctext[256], ctext_ex[256];
-    static unsigned char ptext_ex[] = "\x54\x85\x9b\x34\x2c\x49\xea\x2a";
+	{
+	int v, num, n, t, plen, clen = 0, err = 0;
+	RSA *key;
+	unsigned char ptext[256], ttext[256], ctext[256], ctext_ex[256];
+	static unsigned char ptext_ex[] = "\x54\x85\x9b\x34\x2c\x49\xea\x2a";
 
-    CRYPTO_malloc_debug_init();
-    CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
-    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
+	CRYPTO_malloc_debug_init();
+	CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
+	CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);
 
-    RAND_seed(rnd_seed, sizeof rnd_seed); /* or OAEP may fail */
+	RAND_seed(rnd_seed, sizeof rnd_seed); /* or OAEP may fail */
 
-    plen = sizeof(ptext_ex) - 1;
+	plen = sizeof(ptext_ex) - 1;
 
-    for (v = 0; v < 6; v++)
+	for (v = 0; v < 6; v++)
 		{
 		key = RSA_new();
 		switch (v%3)
@@ -263,9 +275,9 @@
 						break;
 						}
 					else
-						printf("RSA_private_decrypt_cavium %d done in @%dus\n", BN_num_bits(key->n), t);
+						printf("RSA_private_decrypt_cavium %ld done in @%dus\n", mpz_sizeinbase(key->n, 2), t);
 
-					if (BN_num_bits(key->n) > 512)
+					if (mpz_sizeinbase(key->n, 2) > 512)
 						{
 						int i, c, t0 = t, bm[100];
 						memset (bm, 0, sizeof(bm));
@@ -305,7 +317,7 @@
 		else
 			printf("PKCS #1 v1.5 encryption/decryption ok\n");
 
-    oaep:
+	oaep:
 		ERR_clear_error();
 		num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
 					 RSA_PKCS1_OAEP_PADDING);
@@ -330,7 +342,7 @@
 			}
 		else if (memcmp(ctext, ctext_ex, num) == 0)
 			printf("OAEP test vector %d passed!\n", v);
-		
+
 		/* Different ciphertexts (rsa_oaep.c without -DPKCS_TESTVECT).
 		   Try decrypting ctext_ex */
 
@@ -366,18 +378,19 @@
 			if (err)
 				break;
 			}
-    next:
+
+	next:
 		RSA_free(key);
 		}
 
-		CRYPTO_cleanup_all_ex_data();
-		ERR_remove_thread_state(NULL);
+	CRYPTO_cleanup_all_ex_data();
+	ERR_remove_thread_state(NULL);
 
-		CRYPTO_mem_leaks_fp(stderr);
+	CRYPTO_mem_leaks_fp(stderr);
 
 #ifdef OPENSSL_SYS_NETWARE
-		if (err) printf("ERROR: %d\n", err);
+	if (err) printf("ERROR: %d\n", err);
 #endif
-		return err;
-    }
+	return err;
+	}
 #endif
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_x931.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_x931.c
--- openssl-1.0.1e/crypto/rsa/rsa_x931.c	2013-04-24 22:21:55.208799414 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_x931.c	2013-04-24 22:11:07.040800020 +0800
@@ -58,7 +58,6 @@
 
 #include <stdio.h>
 #include "cryptlib.h"
-#include <openssl/bn.h>
 #include <openssl/rsa.h>
 #include <openssl/rand.h>
 #include <openssl/objects.h>
diff -Nur openssl-1.0.1e/ssl/s3_clnt.c sp-120/libs/openssl-1.0.1e/ssl/s3_clnt.c
--- openssl-1.0.1e/ssl/s3_clnt.c	2013-04-24 22:21:56.381799413 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/s3_clnt.c	2013-04-24 22:11:07.042800019 +0800
@@ -1488,11 +1488,7 @@
 			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_MODULUS_LENGTH);
 			goto f_err;
 			}
-		if (!(rsa->n=BN_bin2bn(p,i,rsa->n)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
+		mpz_import (rsa->n, i, 1, 1, 0, 0, p);
 		p+=i;
 
 		n2s(p,i);
@@ -1503,11 +1499,7 @@
 			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,SSL_R_BAD_RSA_E_LENGTH);
 			goto f_err;
 			}
-		if (!(rsa->e=BN_bin2bn(p,i,rsa->e)))
-			{
-			SSLerr(SSL_F_SSL3_GET_KEY_EXCHANGE,ERR_R_BN_LIB);
-			goto err;
-			}
+		mpz_import (rsa->e, i, 1, 1, 0, 0, p);
 		p+=i;
 		n-=param_len;
 
diff -Nur openssl-1.0.1e/ssl/s3_srvr.c sp-120/libs/openssl-1.0.1e/ssl/s3_srvr.c
--- openssl-1.0.1e/ssl/s3_srvr.c	2013-04-24 22:22:43.731799368 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/s3_srvr.c	2013-04-24 22:15:04.790801396 +0800
@@ -1595,7 +1595,7 @@
 	unsigned long type;
 	int n;
 	CERT *cert;
-	BIGNUM *r[4];
+	void* r[4];
 	int nr[4],kn;
 	BUF_MEM *buf;
 	EVP_MD_CTX md_ctx;
@@ -1608,7 +1608,7 @@
 
 		buf=s->init_buf;
 
-		r[0]=r[1]=r[2]=r[3]=NULL;
+		r[0] = r[1] = r[2] = r[3] = NULL;
 		n=0;
 #ifndef OPENSSL_NO_RSA
 		if (type & SSL_kRSA)
@@ -1634,8 +1634,8 @@
 				SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);
 				goto f_err;
 				}
-			r[0]=rsa->n;
-			r[1]=rsa->e;
+			r[0] = &rsa->n;
+			r[1] = &rsa->e;
 			s->s3->tmp.use_rsa_tmp=1;
 			}
 		else
@@ -1815,10 +1815,7 @@
 			/* We'll generate the serverKeyExchange message
 			 * explicitly so we can set these to NULLs
 			 */
-			r[0]=NULL;
-			r[1]=NULL;
-			r[2]=NULL;
-			r[3]=NULL;
+			r[0] = r[1] = r[2] = r[3] = NULL;
 			}
 		else 
 #endif /* !OPENSSL_NO_ECDH */
@@ -1853,9 +1850,12 @@
 			SSLerr(SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
 			goto f_err;
 			}
-		for (i=0; r[i] != NULL && i<4; i++)
-			{
-			nr[i]=BN_num_bytes(r[i]);
+		for (i = 0; i < 4 && r[i]; i++) {
+			if (type & SSL_kRSA) {
+				nr[i] = (mpz_sizeinbase (*(mpz_t*)r[i], 2) + 7) >> 3;
+			} else {
+				nr[i] = BN_num_bytes ((BIGNUM*)r[i]);
+			}
 #ifndef OPENSSL_NO_SRP
 			if ((i == 2) && (type & SSL_kSRP))
 				n+=1+nr[i];
@@ -1889,7 +1889,7 @@
 		d=(unsigned char *)s->init_buf->data;
 		p= &(d[4]);
 
-		for (i=0; r[i] != NULL && i<4; i++)
+		for (i = 0; i < 4 && r[i]; ++i)
 			{
 #ifndef OPENSSL_NO_SRP
 			if ((i == 2) && (type & SSL_kSRP))
@@ -1900,7 +1900,10 @@
 			else
 #endif
 			s2n(nr[i],p);
-			BN_bn2bin(r[i],p);
+			if (type & SSL_kRSA)
+				mpz_export (p, NULL, 1, 1, 0, 0, *(mpz_t*)r[i]);
+			else
+				BN_bn2bin ((BIGNUM*)r[i], p);
 			p+=nr[i];
 			}
 
diff -Nur openssl-1.0.1e/ssl/d1_srvr.c sp-120/libs/openssl-1.0.1e/ssl/d1_srvr.c
--- openssl-1.0.1e/ssl/d1_srvr.c	2013-04-24 22:21:56.382799413 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/d1_srvr.c	2013-04-24 22:11:07.044800019 +0800
@@ -1044,7 +1044,7 @@
 	unsigned long type;
 	int n;
 	CERT *cert;
-	BIGNUM *r[4];
+	void* r[4];
 	int nr[4],kn;
 	BUF_MEM *buf;
 	EVP_MD_CTX md_ctx;
@@ -1057,7 +1057,7 @@
 
 		buf=s->init_buf;
 
-		r[0]=r[1]=r[2]=r[3]=NULL;
+		r[0] = r[1] = r[2] = r[3] = NULL;
 		n=0;
 #ifndef OPENSSL_NO_RSA
 		if (type & SSL_kRSA)
@@ -1083,8 +1083,8 @@
 				SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_KEY);
 				goto f_err;
 				}
-			r[0]=rsa->n;
-			r[1]=rsa->e;
+			r[0] = &rsa->n;
+			r[1] = &rsa->e;
 			s->s3->tmp.use_rsa_tmp=1;
 			}
 		else
@@ -1266,10 +1266,7 @@
 			/* We'll generate the serverKeyExchange message
 			 * explicitly so we can set these to NULLs
 			 */
-			r[0]=NULL;
-			r[1]=NULL;
-			r[2]=NULL;
-			r[3]=NULL;
+			r[0] = r[1] = r[2] = r[3] = NULL;
 			}
 		else 
 #endif /* !OPENSSL_NO_ECDH */
@@ -1286,10 +1283,13 @@
 			SSLerr(SSL_F_DTLS1_SEND_SERVER_KEY_EXCHANGE,SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE);
 			goto f_err;
 			}
-		for (i=0; r[i] != NULL; i++)
+		for (i = 0; i < 4 && r[i]; ++i)
 			{
-			nr[i]=BN_num_bytes(r[i]);
-			n+=2+nr[i];
+			if (type & SSL_kRSA)
+				nr[i] = (mpz_sizeinbase (*(mpz_t*)r[i], 2) + 7) >> 3;
+			else
+				nr[i] = BN_num_bytes ((BIGNUM*)r[i]);
+			n += 2 + nr[i];
 			}
 
 		if (!(s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL)
@@ -1317,11 +1317,14 @@
 		d=(unsigned char *)s->init_buf->data;
 		p= &(d[DTLS1_HM_HEADER_LENGTH]);
 
-		for (i=0; r[i] != NULL; i++)
+		for (i = 0; i < 4 && r[i]; ++i)
 			{
-			s2n(nr[i],p);
-			BN_bn2bin(r[i],p);
-			p+=nr[i];
+			s2n (nr[i], p);
+			if (type & SSL_kRSA)
+				mpz_export (p, NULL, 1, 1, 0, 0, *(mpz_t*)r[i]);
+			else
+				BN_bn2bin ((BIGNUM*)r[i], p);
+			p += nr[i];
 			}
 
 #ifndef OPENSSL_NO_ECDH
diff -Nur openssl-1.0.1e/ssl/ssltest.c sp-120/libs/openssl-1.0.1e/ssl/ssltest.c
--- openssl-1.0.1e/ssl/ssltest.c	2013-04-24 22:21:56.384799413 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/ssltest.c	2013-04-24 22:11:07.044800020 +0800
@@ -395,7 +395,7 @@
 				&& pkey->pkey.rsa->n != NULL)
 				{
 				BIO_printf(bio_stdout, ", %d bit RSA",
-					BN_num_bits(pkey->pkey.rsa->n));
+					(int)mpz_sizeinbase (pkey->pkey.rsa->n, 2));
 				}
 #endif
 #ifndef OPENSSL_NO_DSA
@@ -2322,19 +2322,19 @@
 
 static RSA MS_CALLBACK *tmp_rsa_cb(SSL *s, int is_export, int keylength)
 	{
-	BIGNUM *bn = NULL;
+	mpz_t bn;
 	if (rsa_tmp == NULL)
 		{
-		bn = BN_new();
+		mpz_init_set_ui (bn, RSA_F4);
 		rsa_tmp = RSA_new();
-		if(!bn || !rsa_tmp || !BN_set_word(bn, RSA_F4))
+		if(!rsa_tmp)
 			{
 			BIO_printf(bio_err, "Memory error...");
 			goto end;
 			}
 		BIO_printf(bio_err,"Generating temp (%d bit) RSA key...",keylength);
 		(void)BIO_flush(bio_err);
-		if(!RSA_generate_key_ex(rsa_tmp,keylength,bn,NULL))
+		if(!RSA_generate_key_ex(rsa_tmp,keylength,bn))
 			{
 			BIO_printf(bio_err, "Error generating key.");
 			RSA_free(rsa_tmp);
@@ -2344,7 +2344,7 @@
 		BIO_printf(bio_err,"\n");
 		(void)BIO_flush(bio_err);
 		}
-	if(bn) BN_free(bn);
+	mpz_clear (bn);;
 	return(rsa_tmp);
 	}
 
