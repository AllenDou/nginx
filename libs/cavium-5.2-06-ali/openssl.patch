diff -Nur openssl-1.0.1e/crypto/rsa/rsa.h sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa.h
--- openssl-1.0.1e/crypto/rsa/rsa.h	2013-04-24 22:07:11.246800238 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa.h	2013-04-24 21:35:36.105802001 +0800
@@ -61,6 +61,10 @@
 
 #include <openssl/asn1.h>
 
+#ifdef CAVIUM_DEV
+#include <cavium_common.h>
+#endif
+
 #ifndef OPENSSL_NO_BIO
 #include <openssl/bio.h>
 #endif
@@ -174,7 +178,9 @@
 #define RSA_3	0x3L
 #define RSA_F4	0x10001L
 
-#define RSA_METHOD_FLAG_NO_CHECK	0x0001 /* don't check pub/private match */
+#define RSA_METHOD_FLAG_NO_CHECK			0x0001 /* don't check pub/private match */
+#define RSA_METHOD_FLAG_ALLOW_OFFLOADING	0x0200 /* Allow RSA operation to be offloaded to external engine */
+
 
 #define RSA_FLAG_CACHE_PUBLIC		0x0002
 #define RSA_FLAG_CACHE_PRIVATE		0x0004
@@ -217,7 +223,6 @@
                                                 */
 #endif
 
-
 #define EVP_PKEY_CTX_set_rsa_padding(ctx, pad) \
 	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, EVP_PKEY_CTRL_RSA_PADDING, \
 				pad, NULL)
@@ -288,19 +293,24 @@
 		(*callback)(int,int,void *),void *cb_arg);
 #endif /* !defined(OPENSSL_NO_DEPRECATED) */
 
+/* Cavium routine */
+int RSA_private_decrypt_cavium(int flen, const unsigned char *from,
+		unsigned char *to, RSA *rsa, int nonblocking, unsigned int *req_id);
+unsigned int RSA_check_status_cavium(unsigned int req_id, unsigned int* ret_len);
+
 /* New version */
 int	RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
 
 int	RSA_check_key(const RSA *);
 	/* next 4 return -1 on error */
 int	RSA_public_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
+		unsigned char *to, RSA *rsa, int padding);
 int	RSA_private_encrypt(int flen, const unsigned char *from,
-		unsigned char *to, RSA *rsa,int padding);
+		unsigned char *to, RSA *rsa, int padding);
 int	RSA_public_decrypt(int flen, const unsigned char *from, 
-		unsigned char *to, RSA *rsa,int padding);
+		unsigned char *to, RSA *rsa, int padding);
 int	RSA_private_decrypt(int flen, const unsigned char *from, 
-		unsigned char *to, RSA *rsa,int padding);
+		unsigned char *to, RSA *rsa, int padding);
 void	RSA_free (RSA *r);
 /* "up" the RSA object's reference count */
 int	RSA_up_ref(RSA *r);
@@ -556,6 +566,7 @@
 #define RSA_R_NULL_BEFORE_BLOCK_MISSING			 113
 #define RSA_R_N_DOES_NOT_EQUAL_P_Q			 127
 #define RSA_R_OAEP_DECODING_ERROR			 121
+#define RSA_R_OPERATION_IN_PROGRESS			 159
 #define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	 158
 #define RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 148
 #define RSA_R_PADDING_CHECK_FAILED			 114
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_lib.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_lib.c
--- openssl-1.0.1e/crypto/rsa/rsa_lib.c	2013-04-24 22:07:11.245800238 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_lib.c	2013-04-24 21:35:36.106802000 +0800
@@ -134,9 +134,7 @@
 
 RSA *RSA_new_method(ENGINE *engine)
 	{
-	RSA *ret;
-
-	ret=(RSA *)OPENSSL_malloc(sizeof(RSA));
+	RSA *ret=(RSA *)OPENSSL_malloc(sizeof(RSA));
 	if (ret == NULL)
 		{
 		RSAerr(RSA_F_RSA_NEW_METHOD,ERR_R_MALLOC_FAILURE);
@@ -144,6 +142,8 @@
 		}
 
 	ret->meth = RSA_get_default_method();
+//Log ("1 RSA_new_method(%p)=%p,%p,%p,RSA_PKCS1_SSLeay()=%p",
+//	engine, ret, ret->meth, ret->meth->init, RSA_PKCS1_SSLeay());
 #ifndef OPENSSL_NO_ENGINE
 	if (engine)
 		{
@@ -154,21 +154,18 @@
 			return NULL;
 			}
 		ret->engine = engine;
-		}
-	else
-		ret->engine = ENGINE_get_default_RSA();
-	if(ret->engine)
-		{
-		ret->meth = ENGINE_get_RSA(ret->engine);
+		ret->meth = ENGINE_get_RSA(engine);
 		if(!ret->meth)
 			{
 			RSAerr(RSA_F_RSA_NEW_METHOD,
 				ERR_R_ENGINE_LIB);
-			ENGINE_finish(ret->engine);
+			ENGINE_finish(engine);
 			OPENSSL_free(ret);
 			return NULL;
 			}
 		}
+	else
+		ret->engine = ENGINE_get_default_RSA();
 #endif
 
 	ret->pad=0;
@@ -198,8 +195,9 @@
 		OPENSSL_free(ret);
 		return(NULL);
 		}
-
-	if ((ret->meth->init != NULL) && !ret->meth->init(ret))
+//Log ("2 RSA_new_method(%p)=%p,%p,%p,RSA_PKCS1_SSLeay()=%p",
+//	engine, ret, ret->meth, ret->meth->init, RSA_PKCS1_SSLeay());
+	if ((ret->meth->init) && !ret->meth->init(ret))
 		{
 #ifndef OPENSSL_NO_ENGINE
 		if (ret->engine)
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_eay.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_eay.c
--- openssl-1.0.1e/crypto/rsa/rsa_eay.c	2013-04-24 22:07:11.246800238 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_eay.c	2013-04-24 21:35:36.107802005 +0800
@@ -109,6 +109,8 @@
  *
  */
 
+#define CAVIUM_DEV
+
 #include <stdio.h>
 #include "cryptlib.h"
 #include <openssl/bn.h>
@@ -145,6 +147,69 @@
 	NULL /* rsa_keygen */
 	};
 
+//static unsigned int iLog = 0;
+
+CspDmaMode global_dma_mode = CAVIUM_DIRECT; /* default mode */
+
+int g_pkpdev = -1, g_pkpdev_count = 0;
+
+/*
+void LogHex( const char* s, const unsigned char* p, unsigned int len, ... )
+{
+	FILE* f = fopen ("/dev/shm/no.log", "at");
+	if (f) {
+		char buf[512];
+		va_list argptr;
+		struct timeval tv;
+		unsigned int i = 0;
+
+		gettimeofday (&tv, NULL);
+		strftime (buf, sizeof(buf), "%H:%M:%S", gmtime (&tv.tv_sec));
+		sprintf (buf + 8, ".%06u ", (unsigned int)tv.tv_usec);
+
+		va_start (argptr, len);
+		vsprintf (buf + 16, s, argptr);
+		va_end (argptr);
+
+		fprintf (f, "%3d %u/%u %s\n", ++iLog, (unsigned int)getpid(), (unsigned int)pthread_self(), buf);
+	
+		while (i < len) {
+			fprintf (f, " %02X", p[i++]);
+			if (i < len && i % 8 == 0) {
+				if (i % 16 == 0) {
+					fprintf (f, "\n");
+				} else {
+					fprintf (f, " -");
+				}
+			}
+		}
+		fprintf (f, "\n");
+
+		fclose (f);
+	}
+}
+
+void Log( const char* s, ... )
+{
+	FILE* f = fopen ("/dev/shm/no.log", "at");
+	if (f) {
+		char buf[512];
+		va_list argptr;
+		struct timeval tv;
+
+		gettimeofday (&tv, NULL);
+		strftime (buf, sizeof(buf), "%H:%M:%S", gmtime (&tv.tv_sec));
+		sprintf (buf + 8, ".%06u ", (unsigned int)tv.tv_usec);
+
+		va_start (argptr, s);
+		vsprintf (buf + 16, s, argptr);
+		va_end (argptr);
+
+		fprintf (f, "%3d %u/%u %s\n", ++iLog, (unsigned int)getpid(), (unsigned int)pthread_self(), buf);
+		fclose (f);
+	}
+}
+*/
 const RSA_METHOD *RSA_PKCS1_SSLeay(void)
 	{
 	return(&rsa_pkcs1_eay_meth);
@@ -157,7 +222,7 @@
 	int i,j,k,num=0,r= -1;
 	unsigned char *buf=NULL;
 	BN_CTX *ctx=NULL;
-
+//Log ("RSA_eay_public_encrypt %p", rsa);
 	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
 		{
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
@@ -257,7 +322,7 @@
 	BN_BLINDING *ret;
 	int got_write_lock = 0;
 	CRYPTO_THREADID cur;
-
+//Log ("rsa_get_blinding %p", rsa);
 	CRYPTO_r_lock(CRYPTO_LOCK_RSA);
 
 	if (rsa->blinding == NULL)
@@ -317,6 +382,7 @@
 static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
 	BN_CTX *ctx)
 	{
+//Log ("rsa_blinding_convert");
 	if (unblind == NULL)
 		/* Local blinding: store the unblinding factor
 		 * in BN_BLINDING. */
@@ -343,6 +409,7 @@
 	 * and will only read the modulus from BN_BLINDING.
 	 * In both cases it's safe to access the blinding without a lock.
 	 */
+//Log ("rsa_blinding_invert");
 	return BN_BLINDING_invert_ex(f, unblind, b, ctx);
 	}
 
@@ -360,7 +427,7 @@
 	 * the unblinding factor outside the blinding structure. */
 	BIGNUM *unblind = NULL;
 	BN_BLINDING *blinding = NULL;
-
+//Log ("RSA_eay_private_encrypt %p", rsa);
 	if ((ctx=BN_CTX_new()) == NULL) goto err;
 	BN_CTX_start(ctx);
 	f   = BN_CTX_get(ctx);
@@ -392,7 +459,7 @@
 	if (i <= 0) goto err;
 
 	if (BN_bin2bn(buf,num,f) == NULL) goto err;
-	
+
 	if (BN_ucmp(f, rsa->n) >= 0)
 		{	
 		/* usually the padding functions would catch this */
@@ -427,7 +494,7 @@
 		(rsa->dmp1 != NULL) &&
 		(rsa->dmq1 != NULL) &&
 		(rsa->iqmp != NULL)) )
-		{ 
+		{
 		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
 		}
 	else
@@ -503,7 +570,7 @@
 	 * the unblinding factor outside the blinding structure. */
 	BIGNUM *unblind = NULL;
 	BN_BLINDING *blinding = NULL;
-
+//Log ("RSA_eay_private_decrypt %p, %p", rsa, RSA_eay_init);
 	if((ctx = BN_CTX_new()) == NULL) goto err;
 	BN_CTX_start(ctx);
 	f   = BN_CTX_get(ctx);
@@ -512,6 +579,7 @@
 	buf = OPENSSL_malloc(num);
 	if(!f || !ret || !buf)
 		{
+
 		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
 		goto err;
 		}
@@ -562,10 +630,12 @@
 		(rsa->dmq1 != NULL) &&
 		(rsa->iqmp != NULL)) )
 		{
+//Log ("RSA_eay_private_decrypt CRT");
 		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
 		}
 	else
 		{
+//Log ("RSA_eay_private_decrypt OLD");
 		BIGNUM local_d;
 		BIGNUM *d = NULL;
 		
@@ -638,7 +708,7 @@
 	unsigned char *p;
 	unsigned char *buf=NULL;
 	BN_CTX *ctx=NULL;
-
+//Log ("RSA_eay_public_decrypt %p", rsa);
 	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
 		{
 		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
@@ -740,7 +810,7 @@
 	BIGNUM local_dmp1,local_dmq1,local_c,local_r1;
 	BIGNUM *dmp1,*dmq1,*c,*pr1;
 	int ret=0;
-
+//Log ("RSA_eay_mod_exp %p", rsa);
 	BN_CTX_start(ctx);
 	r1 = BN_CTX_get(ctx);
 	m1 = BN_CTX_get(ctx);
@@ -895,20 +965,58 @@
 	return(ret);
 	}
 
+Uint32 CavInitialize(CspDmaMode dma_mode)
+	{
+//Log ("CavInitialize %d/%d", g_pkpdev, g_pkpdev_count);
+	++g_pkpdev_count;
+
+	if (g_pkpdev < 0)
+		{
+		g_pkpdev = open("/dev/pkp_dev", O_RDWR | O_CLOEXEC);
+		if (g_pkpdev < 0)
+			return errno;
+		}
+
+	return 0;
+	}
+
+Uint32 CavShutdown()
+	{
+//Log ("CavShutdown %d", g_pkpdev);
+	--g_pkpdev_count;
+
+	if (!g_pkpdev_count && g_pkpdev >= 0)
+		{
+		close(g_pkpdev);
+		g_pkpdev = -1;
+		}
+
+	return 0;
+	}
+
 static int RSA_eay_init(RSA *rsa)
 	{
+	CavInitialize(global_dma_mode);
+
+//	Log ("CavInitialize result: rsa(%p) g_pkpdev=%d, errno=%d",
+//		rsa, g_pkpdev, errno);
+
 	rsa->flags|=RSA_FLAG_CACHE_PUBLIC|RSA_FLAG_CACHE_PRIVATE;
 	return(1);
 	}
 
 static int RSA_eay_finish(RSA *rsa)
 	{
+//Log ("RSA_eay_finish %p", rsa);
 	if (rsa->_method_mod_n != NULL)
 		BN_MONT_CTX_free(rsa->_method_mod_n);
 	if (rsa->_method_mod_p != NULL)
 		BN_MONT_CTX_free(rsa->_method_mod_p);
 	if (rsa->_method_mod_q != NULL)
 		BN_MONT_CTX_free(rsa->_method_mod_q);
+
+	CavShutdown();
+
 	return(1);
 	}
 
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_crpt.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_crpt.c
--- openssl-1.0.1e/crypto/rsa/rsa_crpt.c	2013-04-24 22:07:11.245800238 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_crpt.c	2013-04-24 21:35:36.108802010 +0800
@@ -56,6 +56,8 @@
  * [including the GNU Public Licence.]
  */
 
+#define CAVIUM_DEV
+
 #include <stdio.h>
 #include <openssl/crypto.h>
 #include "cryptlib.h"
@@ -67,6 +69,11 @@
 #include <openssl/engine.h>
 #endif
 
+#include "linux_ioctl.h"
+
+extern CspDmaMode global_dma_mode;
+extern int g_pkpdev;
+
 int RSA_size(const RSA *r)
 	{
 	return(BN_num_bytes(r->n));
@@ -100,6 +107,204 @@
 	return(rsa->meth->rsa_priv_enc(flen, from, to, rsa, padding));
 	}
 
+Uint32 RSA_check_status_cavium(Uint32 req_id, Uint32* ret_len)
+{
+	Uint32 ret_val;
+	CspRequestStatusBuffer reqStatus;
+
+	reqStatus.request_id = req_id;
+	reqStatus.status = 0;
+	ret_val = ioctl(g_pkpdev, IOCTL_N1_POLL_CODE, &reqStatus);
+	if (!ret_val) {
+		ret_val = reqStatus.status;/*return status of request:'0' or 'EAGAIN'*/
+		if (ret_val == EAGAIN) {
+//Log ("RSA_check_status_cavium %d return EAGAIN", req_id);
+			RSAerr(RSA_F_RSA_PRIVATE_DECRYPT, RSA_R_OPERATION_IN_PROGRESS);
+		}
+	}
+
+	if (ret_len)
+		*ret_len = 0;
+
+	return ret_val;
+}
+
+Uint32 CavPkcs1v15CrtDec(n1_request_type request_type,
+	RsaBlockType block_type, Uint16 modlength,
+	Uint8 *Q, Uint8 *Eq, Uint8 *P, Uint8 *Ep, Uint8 *iqmp,
+	Uint8 *data, Uint16 *out_length, Uint8 *result,
+	Uint32 *request_id)
+{
+	CspOperationBuffer buffer;
+	Uint32 ret_val;
+
+	memset(&buffer, 0, sizeof(CspOperationBuffer));
+
+	buffer.group = CAVIUM_SSL_GRP;
+
+	buffer.ctx_ptr = 0;
+	buffer.dlen = (Uint16) ((2.5 * modlength) + modlength);
+	buffer.size = modlength;
+	buffer.param = block_type;
+	buffer.rlen = 2 + modlength;
+
+	if (!(modlength & 1)) {
+		if (modlength >= 34 && modlength <= 128) {
+			buffer.opcode = (0x2 << 8) | (global_dma_mode << 7) | MAJOR_OP_ME_PKCS;
+		} else if (modlength > 128 && modlength <= 512) {
+			buffer.opcode = (0x2 << 8) | (global_dma_mode << 7) | MAJOR_OP_ME_PKCS_LARGE;
+		}
+	}
+
+	buffer.incnt = 6;
+	buffer.inptr[0] = CAST_TO_X_PTR(Q);
+	buffer.insize[0] = modlength >> 1;
+	buffer.inoffset[0] = modlength >> 1;
+	buffer.inunit[0] = UNIT_8_BIT;
+	buffer.inptr[1] = CAST_TO_X_PTR(Eq);
+	buffer.insize[1] = modlength >> 1;
+	buffer.inoffset[1] = modlength >> 1;
+	buffer.inunit[1] = UNIT_8_BIT;
+	buffer.inptr[2] = CAST_TO_X_PTR(P);
+	buffer.insize[2] = modlength >> 1;
+	buffer.inoffset[2] = modlength >> 1;
+	buffer.inunit[2] = UNIT_8_BIT;
+	buffer.inptr[3] = CAST_TO_X_PTR(Ep);
+	buffer.insize[3] = modlength >> 1;
+	buffer.inoffset[3] = modlength >> 1;
+	buffer.inunit[3] = UNIT_8_BIT;
+	buffer.inptr[4] =CAST_TO_X_PTR(iqmp);
+	buffer.insize[4] = modlength >> 1;
+	buffer.inoffset[4] = modlength >> 1;
+	buffer.inunit[4] = UNIT_8_BIT;
+	buffer.inptr[5] = CAST_TO_X_PTR(data);
+	buffer.insize[5] = modlength;
+	buffer.inoffset[5] = modlength;
+	buffer.inunit[5] = UNIT_8_BIT;
+
+	buffer.outcnt = 2;
+	buffer.outptr[0] = CAST_TO_X_PTR((Uint8 *)out_length);
+	buffer.outsize[0] = 2;
+	buffer.outoffset[0] = 2;
+	buffer.outunit[0] = UNIT_16_BIT;
+
+	buffer.outptr[1] = CAST_TO_X_PTR(result);
+	buffer.outsize[1] = modlength;
+	buffer.outoffset[1] = modlength;
+	buffer.outunit[1] = UNIT_8_BIT;
+
+	buffer.req_queue = 0;
+	buffer.req_type = request_type;
+	buffer.res_order = CAVIUM_RESPONSE_ORDERED;
+	buffer.dma_mode = global_dma_mode;
+	buffer.status = 0;
+
+	ret_val = ioctl(g_pkpdev, IOCTL_N1_OPERATION_CODE, (ptrlong)&buffer);
+
+	if (request_id)
+		*request_id = buffer.request_id;
+
+	if (!ret_val)
+		ret_val = buffer.status;/*return OPERATION STATUS: SUCCESS('0')/EAGAIN */
+
+	return ret_val;
+}
+
+int RSA_private_decrypt_cavium(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int nonblocking, Uint32 *req_id)
+	{
+	int i,ret=0;
+	unsigned char *modulus_b=NULL, *exponent_b=NULL, *from_b=NULL;
+	unsigned char *q_buf=NULL, *dmq1_buf=NULL, *p_buf=NULL;
+	unsigned char *dmp1_buf=NULL, *iqmp_buf=NULL;
+	int modulus_size, exponent_size;
+	Uint16 out_length=0;
+
+//Log ("g_pkpdev=%d", g_pkpdev);
+	if (g_pkpdev < 0)
+		{
+		//ENODEV;
+		RSAerr(RSA_F_RSA_PRIVATE_DECRYPT, RSA_R_RSA_OPERATIONS_NOT_SUPPORTED);
+		return 0;
+		}
+
+	modulus_size  = BN_num_bytes(rsa->n);
+	if ((modulus_size < 17) || (modulus_size > 512))
+		goto rsa_priv_dec_cleanup;
+
+	exponent_size = BN_num_bytes(rsa->d);
+
+	modulus_b = alloca(modulus_size);
+	if (!modulus_b)
+		{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+		}
+	memset(modulus_b, 0, modulus_size);
+
+	exponent_b = alloca(exponent_size);
+	if (!exponent_b)
+		{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+		}
+	memset(exponent_b,0,exponent_size);
+
+	from_b = alloca(modulus_size);
+	if (!from_b)
+		{
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+		}
+	memcpy(from_b,from,modulus_size);
+
+	BN_bn2bin(rsa->n, modulus_b);
+	BN_bn2bin(rsa->d, exponent_b);
+
+	q_buf = (Uint8 *)malloc(modulus_size >> 1);
+	dmq1_buf = (Uint8 *)malloc(modulus_size >> 1);
+	p_buf = (Uint8 *)malloc(modulus_size >> 1);
+	dmp1_buf = (Uint8 *)malloc(modulus_size >> 1);
+	iqmp_buf = (Uint8 *)malloc(modulus_size >> 1);
+
+	if (!q_buf || !dmq1_buf || !p_buf || !dmp1_buf || !iqmp_buf)
+		{
+		printf("malloc failre \n");
+		ret = 0;
+		goto rsa_priv_dec_cleanup;
+		}
+
+	BN_bn2bin(rsa->q, q_buf);
+	BN_bn2bin(rsa->dmq1, dmq1_buf);
+	BN_bn2bin(rsa->p, p_buf);
+	BN_bn2bin(rsa->dmp1, dmp1_buf);
+	BN_bn2bin(rsa->iqmp, iqmp_buf);
+
+	i = CavPkcs1v15CrtDec(nonblocking ? CAVIUM_NON_BLOCKING : CAVIUM_BLOCKING, BT2,
+			(Uint16)modulus_size, q_buf, dmq1_buf, p_buf, dmp1_buf, iqmp_buf,
+			from_b, &out_length, to, req_id);
+	if (i)
+		{
+		ret=0;
+		if (EAGAIN == i)
+			RSAerr(RSA_F_RSA_PRIVATE_DECRYPT, RSA_R_OPERATION_IN_PROGRESS);
+		}
+	else
+		{
+		//RSAerr(RSA_F_RSA_PRIVATE_DECRYPT, RSA_R_OPERATION_IN_PROGRESS);
+		ret = (Uint32)ntohs(out_length);
+		}
+
+rsa_priv_dec_cleanup:
+
+	if (q_buf) free(q_buf);
+	if (dmq1_buf) free(dmq1_buf);
+	if (p_buf) free(p_buf);
+	if (dmp1_buf) free(dmp1_buf);
+	if (iqmp_buf) free(iqmp_buf);
+
+	return ret;
+}
+
 int RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to,
 	     RSA *rsa, int padding)
 	{
@@ -111,6 +316,7 @@
 		return -1;
 		}
 #endif
+//Log ("RSA_private_decrypt %p %p %p", rsa, rsa->meth, rsa->meth->rsa_priv_dec);
 	return(rsa->meth->rsa_priv_dec(flen, from, to, rsa, padding));
 	}
 
diff -Nur openssl-1.0.1e/crypto/rsa/rsa_test.c sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_test.c
--- openssl-1.0.1e/crypto/rsa/rsa_test.c	2013-04-24 22:07:11.246800238 +0800
+++ sp-120/libs/openssl-1.0.1e/crypto/rsa/rsa_test.c	2013-04-24 21:35:36.109802012 +0800
@@ -209,17 +209,10 @@
 
 int main(int argc, char *argv[])
     {
-    int err=0;
-    int v;
+    int v, num, n, t, plen, clen = 0, err = 0;
     RSA *key;
-    unsigned char ptext[256];
-    unsigned char ctext[256];
+    unsigned char ptext[256], ttext[256], ctext[256], ctext_ex[256];
     static unsigned char ptext_ex[] = "\x54\x85\x9b\x34\x2c\x49\xea\x2a";
-    unsigned char ctext_ex[256];
-    int plen;
-    int clen = 0;
-    int num;
-    int n;
 
     CRYPTO_malloc_debug_init();
     CRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);
@@ -230,111 +223,161 @@
     plen = sizeof(ptext_ex) - 1;
 
     for (v = 0; v < 6; v++)
-	{
-	key = RSA_new();
-	switch (v%3) {
-    case 0:
-	clen = key1(key, ctext_ex);
-	break;
-    case 1:
-	clen = key2(key, ctext_ex);
-	break;
-    case 2:
-	clen = key3(key, ctext_ex);
-	break;
-	}
-	if (v/3 >= 1) key->flags |= RSA_FLAG_NO_CONSTTIME;
-
-	num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
-				 RSA_PKCS1_PADDING);
-	if (num != clen)
-	    {
-	    printf("PKCS#1 v1.5 encryption failed!\n");
-	    err=1;
-	    goto oaep;
-	    }
-  
-	num = RSA_private_decrypt(num, ctext, ptext, key,
-				  RSA_PKCS1_PADDING);
-	if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
-	    {
-	    printf("PKCS#1 v1.5 decryption failed!\n");
-	    err=1;
-	    }
-	else
-	    printf("PKCS #1 v1.5 encryption/decryption ok\n");
+		{
+		key = RSA_new();
+		switch (v%3)
+			{
+			case 0:
+			clen = key1(key, ctext_ex);
+			break;
+			case 1:
+			clen = key2(key, ctext_ex);
+			break;
+			case 2:
+			clen = key3(key, ctext_ex);
+			break;
+			}
+		if (v/3 >= 1) key->flags |= RSA_FLAG_NO_CONSTTIME;
+
+		num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
+					RSA_PKCS1_PADDING);
+		if (num != clen)
+			{
+			printf("PKCS#1 v1.5 encryption failed!\n");
+			err=1;
+			goto oaep;
+			}
+
+		for (t = 5; t < 1000 * 1000; t += 5)
+			{
+			num = RSA_private_decrypt_cavium(clen, ctext, ttext, key, 1, (unsigned int*)&n);
+			if (!num && (ERR_GET_REASON(ERR_peek_error()) == RSA_R_OPERATION_IN_PROGRESS))
+				{
+				usleep(t);
+				if (!RSA_check_status_cavium((unsigned int)n, NULL))
+					{
+					if (memcmp(ptext_ex, ttext, plen))
+						{
+						printf("RSA_private_decrypt_cavium failed!\n");
+						err=1;
+						break;
+						}
+					else
+						printf("RSA_private_decrypt_cavium %d done in @%dus\n", BN_num_bits(key->n), t);
+
+					if (BN_num_bits(key->n) > 512)
+						{
+						int i, c, t0 = t, bm[100];
+						memset (bm, 0, sizeof(bm));
+						for (;;)
+							{
+							for (i = c = 0; i < 100; ++i)
+								{
+								RSA_private_decrypt_cavium(clen, ctext, ttext, key, 1, (unsigned int*)&n);
+								usleep (t);
+								if (RSA_check_status_cavium((unsigned int)n, NULL))
+									++c;
+								}
+							printf ("\tRSA_check_status_cavium %d%% done in t: %dus\n", c, t);
+							bm[i = (t - t0) / 5 + 50] = 1;
+							if (c == 0)
+								t -= 5, --i;
+							else
+								t += 5, ++i;
+							if (i < 0 || i >= sizeof(bm) || bm[i])
+								break;
+							}
+						}
+
+					break;
+					}
+				}
+			}
+		num = clen;
+
+		num = RSA_private_decrypt(num, ctext, ptext, key,
+					  RSA_PKCS1_PADDING);
+		if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
+			{
+			printf("PKCS#1 v1.5 decryption failed!\n");
+			err=1;
+			}
+		else
+			printf("PKCS #1 v1.5 encryption/decryption ok\n");
 
     oaep:
-	ERR_clear_error();
-	num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
-				 RSA_PKCS1_OAEP_PADDING);
-	if (num == -1 && pad_unknown())
-	    {
-	    printf("No OAEP support\n");
-	    goto next;
-	    }
-	if (num != clen)
-	    {
-	    printf("OAEP encryption failed!\n");
-	    err=1;
-	    goto next;
-	    }
-
-	num = RSA_private_decrypt(num, ctext, ptext, key,
-				  RSA_PKCS1_OAEP_PADDING);
-	if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
-	    {
-	    printf("OAEP decryption (encrypted data) failed!\n");
-	    err=1;
-	    }
-	else if (memcmp(ctext, ctext_ex, num) == 0)
-	    printf("OAEP test vector %d passed!\n", v);
-    
-	/* Different ciphertexts (rsa_oaep.c without -DPKCS_TESTVECT).
-	   Try decrypting ctext_ex */
-
-	num = RSA_private_decrypt(clen, ctext_ex, ptext, key,
-				  RSA_PKCS1_OAEP_PADDING);
-
-	if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
-	    {
-	    printf("OAEP decryption (test vector data) failed!\n");
-	    err=1;
-	    }
-	else
-	    printf("OAEP encryption/decryption ok\n");
-
-	/* Try decrypting corrupted ciphertexts */
-	for(n = 0 ; n < clen ; ++n)
-	    {
-	    int b;
-	    unsigned char saved = ctext[n];
-	    for(b = 0 ; b < 256 ; ++b)
-		{
-		if(b == saved)
-		    continue;
-		ctext[n] = b;
+		ERR_clear_error();
+		num = RSA_public_encrypt(plen, ptext_ex, ctext, key,
+					 RSA_PKCS1_OAEP_PADDING);
+		if (num == -1 && pad_unknown())
+			{
+			printf("No OAEP support\n");
+			goto next;
+			}
+		if (num != clen)
+			{
+			printf("OAEP encryption failed!\n");
+			err=1;
+			goto next;
+			}
+
 		num = RSA_private_decrypt(num, ctext, ptext, key,
 					  RSA_PKCS1_OAEP_PADDING);
-		if(num > 0)
-		    {
-		    printf("Corrupt data decrypted!\n");
-		    err = 1;
-		    }
-		}
-	    }
+		if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
+			{
+			printf("OAEP decryption (encrypted data) failed!\n");
+			err=1;
+			}
+		else if (memcmp(ctext, ctext_ex, num) == 0)
+			printf("OAEP test vector %d passed!\n", v);
+		
+		/* Different ciphertexts (rsa_oaep.c without -DPKCS_TESTVECT).
+		   Try decrypting ctext_ex */
+
+		num = RSA_private_decrypt(clen, ctext_ex, ptext, key,
+					  RSA_PKCS1_OAEP_PADDING);
+
+		if (num != plen || memcmp(ptext, ptext_ex, num) != 0)
+			{
+			printf("OAEP decryption (test vector data) failed!\n");
+			err=1;
+			}
+		else
+			printf("OAEP encryption/decryption ok\n");
+
+		/* Try decrypting corrupted ciphertexts */
+		for(n = 0 ; n < clen ; ++n)
+			{
+			int b;
+			unsigned char saved = ctext[n];
+			for(b = 0 ; b < 256 ; ++b)
+				{
+				if(b == saved)
+					continue;
+				ctext[n] = b;
+				if (0 < RSA_private_decrypt(num, ctext, ptext, key,
+							RSA_PKCS1_OAEP_PADDING))
+					{
+					printf("Corrupt data decrypted!\n");
+					err = 1;
+					break;
+					}
+				}
+			if (err)
+				break;
+			}
     next:
-	RSA_free(key);
-	}
+		RSA_free(key);
+		}
 
-    CRYPTO_cleanup_all_ex_data();
-    ERR_remove_thread_state(NULL);
+		CRYPTO_cleanup_all_ex_data();
+		ERR_remove_thread_state(NULL);
 
-    CRYPTO_mem_leaks_fp(stderr);
+		CRYPTO_mem_leaks_fp(stderr);
 
 #ifdef OPENSSL_SYS_NETWARE
-    if (err) printf("ERROR: %d\n", err);
+		if (err) printf("ERROR: %d\n", err);
 #endif
-    return err;
+		return err;
     }
 #endif
diff -Nur openssl-1.0.1e/ssl/ssl.h sp-120/libs/openssl-1.0.1e/ssl/ssl.h
--- openssl-1.0.1e/ssl/ssl.h	2013-04-24 22:07:10.799800239 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/ssl.h	2013-04-24 21:35:36.111802010 +0800
@@ -641,6 +641,13 @@
  * TLS only.)  "Released" buffers are put onto a free-list in the context
  * or just freed (depending on the context's setting for freelist_max_len). */
 #define SSL_MODE_RELEASE_BUFFERS 0x00000010L
+/* Indicate current SSL connection has enabled the RELEASE_BUFFERS mode,
+ * but being disalbed by some reason (e.g. the buffer would be used in the future
+ * cause NON_BLOCKING mode is enabled at the same time) */
+#define SSL_MODE_RELEASE_BUFFERS_PENDING 0x00000020L
+/* Indicate that the socket below current SSL connection is
+ * a non-blocking one. (SSL3 and TLS only.) */
+#define SSL_MODE_NON_BLOCKING 0x00000040L
 
 /* Note: SSL[_CTX]_set_{options,mode} use |= op on the previous value,
  * they cannot be used to clear bits. */
@@ -1090,12 +1097,14 @@
 #define SSL_WRITING	2
 #define SSL_READING	3
 #define SSL_X509_LOOKUP	4
+#define SSL_OFFLOADING	5
 
 /* These will only be used when doing non-blocking IO */
 #define SSL_want_nothing(s)	(SSL_want(s) == SSL_NOTHING)
 #define SSL_want_read(s)	(SSL_want(s) == SSL_READING)
 #define SSL_want_write(s)	(SSL_want(s) == SSL_WRITING)
 #define SSL_want_x509_lookup(s)	(SSL_want(s) == SSL_X509_LOOKUP)
+#define SSL_wait_offloading(s)	(SSL_want(s) == SSL_OFFLOADING)
 
 #define SSL_MAC_FLAG_READ_MAC_STREAM 1
 #define SSL_MAC_FLAG_WRITE_MAC_STREAM 2
@@ -1135,6 +1144,7 @@
 	/* true when we are actually in SSL_accept() or SSL_connect() */
 	int in_handshake;
 	int (*handshake_func)(SSL *);
+	unsigned int req_id;
 
 	/* Imagine that here's a boolean member "init" that is
 	 * switched as soon as SSL_set_{accept/connect}_state
@@ -1509,6 +1519,7 @@
 #define SSL_ERROR_ZERO_RETURN		6
 #define SSL_ERROR_WANT_CONNECT		7
 #define SSL_ERROR_WANT_ACCEPT		8
+#define SSL_ERROR_WAIT_OFFLOADING	9
 
 #define SSL_CTRL_NEED_TMP_RSA			1
 #define SSL_CTRL_SET_TMP_RSA			2
diff -Nur openssl-1.0.1e/ssl/ssl_lib.c sp-120/libs/openssl-1.0.1e/ssl/ssl_lib.c
--- openssl-1.0.1e/ssl/ssl_lib.c	2013-04-24 22:07:10.801800239 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/ssl_lib.c	2013-04-24 21:35:36.113802005 +0800
@@ -2523,11 +2523,17 @@
 				return(SSL_ERROR_SYSCALL);
 			}
 		}
+
 	if ((i < 0) && SSL_want_x509_lookup(s))
 		{
 		return(SSL_ERROR_WANT_X509_LOOKUP);
 		}
 
+	if ((i < 0) && SSL_wait_offloading(s))
+		{
+		return(SSL_ERROR_WAIT_OFFLOADING);
+		}
+
 	if (i == 0)
 		{
 		if (s->version == SSL2_VERSION)
diff -Nur openssl-1.0.1e/ssl/s3_srvr.c sp-120/libs/openssl-1.0.1e/ssl/s3_srvr.c
--- openssl-1.0.1e/ssl/s3_srvr.c	2013-04-24 22:07:10.802800239 +0800
+++ sp-120/libs/openssl-1.0.1e/ssl/s3_srvr.c	2013-04-24 22:06:41.582800229 +0800
@@ -169,6 +169,8 @@
 #endif
 #include <openssl/md5.h>
 
+//extern void Log( const char* s, ... );
+
 static const SSL_METHOD *ssl3_get_server_method(int ver);
 
 static const SSL_METHOD *ssl3_get_server_method(int ver)
@@ -213,7 +215,7 @@
 int ssl3_accept(SSL *s)
 	{
 	BUF_MEM *buf;
-	unsigned long alg_k,Time=(unsigned long)time(NULL);
+	unsigned long alg_k,Time=(unsigned long)time(NULL)+(unsigned long)s;
 	void (*cb)(const SSL *ssl,int type,int val)=NULL;
 	int ret= -1;
 	int new_state,state,skip=0;
@@ -227,6 +229,7 @@
 	else if (s->ctx->info_callback != NULL)
 		cb=s->ctx->info_callback;
 
+//Log ("ssl3_accept s=%p rwstate=%d cb=%p %d", s, s->rwstate, cb, s->in_handshake);
 	/* init things to blank */
 	s->in_handshake++;
 	if (!SSL_in_init(s) || SSL_in_before(s)) SSL_clear(s);
@@ -251,6 +254,7 @@
 
 	for (;;)
 		{
+//Log ("%p state: %s, mode: 0x%x, flags: 0x%x", s, SSL_state_string_long (s), s->mode, BIO_get_flags(SSL_get_rbio(s)));
 		state=s->state;
 
 		switch (s->state)
@@ -304,7 +308,7 @@
 				 * the output is sent in a way that TCP likes :-)
 				 */
 				if (!ssl_init_wbio_buffer(s,1)) { ret= -1; goto end; }
-				
+
 				ssl3_init_finished_mac(s);
 				s->state=SSL3_ST_SR_CLNT_HELLO_A;
 				s->ctx->stats.sess_accept++;
@@ -336,17 +340,13 @@
 			s->shutdown=0;
 			ret=ssl3_send_hello_request(s);
 			if (ret <= 0) goto end;
-			s->s3->tmp.next_state=SSL3_ST_SW_HELLO_REQ_C;
+			s->s3->tmp.next_state=SSL_ST_OK;
 			s->state=SSL3_ST_SW_FLUSH;
 			s->init_num=0;
 
 			ssl3_init_finished_mac(s);
 			break;
 
-		case SSL3_ST_SW_HELLO_REQ_C:
-			s->state=SSL_ST_OK;
-			break;
-
 		case SSL3_ST_SR_CLNT_HELLO_A:
 		case SSL3_ST_SR_CLNT_HELLO_B:
 		case SSL3_ST_SR_CLNT_HELLO_C:
@@ -551,7 +551,7 @@
 			s->state=SSL3_ST_SW_FLUSH;
 			s->init_num=0;
 			break;
-		
+
 		case SSL3_ST_SW_FLUSH:
 
 			/* This code originally checked to see if
@@ -567,12 +567,25 @@
 			s->rwstate=SSL_WRITING;
 			if (BIO_flush(s->wbio) <= 0)
 				{
-				ret= -1;
+				ret = -1;
 				goto end;
 				}
-			s->rwstate=SSL_NOTHING;
-
+//Log ("FLUSH %x", BIO_get_flags(SSL_get_rbio(s)));
 			s->state=s->s3->tmp.next_state;
+			if (s->mode & SSL_MODE_NON_BLOCKING && s->state != SSL_ST_OK)
+				{
+				if (s->mode & SSL_MODE_RELEASE_BUFFERS && !s->req_id)
+					{
+					s->mode &= ~SSL_MODE_RELEASE_BUFFERS;
+					s->mode |= SSL_MODE_RELEASE_BUFFERS_PENDING;
+					}
+				BIO_set_retry_read(SSL_get_rbio(s));
+				s->rwstate = SSL_READING;
+				ret = -1;
+				goto end;
+				}
+
+			s->rwstate = SSL_NOTHING;
 			break;
 
 		case SSL3_ST_SR_CERT_A:
@@ -586,6 +599,7 @@
 			else {
 				if (s->s3->tmp.cert_request)
 					{
+//Log ("ssl3_get_client_certificate");
 					ret=ssl3_get_client_certificate(s);
 					if (ret <= 0) goto end;
 					}
@@ -597,6 +611,7 @@
 		case SSL3_ST_SR_KEY_EXCH_A:
 		case SSL3_ST_SR_KEY_EXCH_B:
 			ret=ssl3_get_client_key_exchange(s);
+//Log ("ssl3_get_client_key_exchange done %d", ret);
 			if (ret <= 0)
 				goto end;
 			if (ret == 2)
@@ -675,6 +690,7 @@
 
 			/* we should decide if we expected this one */
 			ret=ssl3_get_cert_verify(s);
+//Log ("ssl3_get_cert_verify ret %d", ret);
 			if (ret <= 0) goto end;
 
 #if defined(OPENSSL_NO_TLSEXT) || defined(OPENSSL_NO_NEXTPROTONEG)
@@ -796,16 +812,16 @@
 				{
 				s->renegotiate=0;
 				s->new_session=0;
-				
+
 				ssl_update_cache(s,SSL_SESS_CACHE_SERVER);
-				
+
 				s->ctx->stats.sess_accept_good++;
 				/* s->server=1; */
 				s->handshake_func=ssl3_accept;
 
 				if (cb != NULL) cb(s,SSL_CB_HANDSHAKE_DONE,1);
 				}
-			
+
 			ret = 1;
 			goto end;
 			/* break; */
@@ -816,7 +832,7 @@
 			goto end;
 			/* break; */
 			}
-		
+
 		if (!s->s3->tmp.reuse_message && !skip)
 			{
 			if (s->debug)
@@ -825,7 +841,6 @@
 					goto end;
 				}
 
-
 			if ((cb != NULL) && (s->state != state))
 				{
 				new_state=s->state;
@@ -2127,7 +2142,7 @@
 int ssl3_get_client_key_exchange(SSL *s)
 	{
 	int i,al,ok;
-	long n;
+	long n = 0;
 	unsigned long alg_k;
 	unsigned char *p;
 #ifndef OPENSSL_NO_RSA
@@ -2148,75 +2163,116 @@
 	EC_POINT *clnt_ecpoint = NULL;
 	BN_CTX *bn_ctx = NULL; 
 #endif
-
-	n=s->method->ssl_get_message(s,
-		SSL3_ST_SR_KEY_EXCH_A,
-		SSL3_ST_SR_KEY_EXCH_B,
-		SSL3_MT_CLIENT_KEY_EXCHANGE,
-		2048, /* ??? */
-		&ok);
-
-	if (!ok) return((int)n);
+//Log ("ssl3_get_client_key_exchange %p ver:%d opt: %x %p.rrec=%p,%p,%d", s->init_msg, s->version, s->options,
+//	s->s3, s->s3->rrec.data, s->s3->rrec.input, s->s3->rrec.length);
+	if (s->rwstate != SSL_OFFLOADING)
+		{
+		n=s->method->ssl_get_message(s,
+			SSL3_ST_SR_KEY_EXCH_A,
+			SSL3_ST_SR_KEY_EXCH_B,
+			SSL3_MT_CLIENT_KEY_EXCHANGE,
+			2048, /* ??? */
+			&ok);
+		if (!ok) return (int)n;
+		if (s->mode & SSL_MODE_RELEASE_BUFFERS_PENDING)
+			{
+			s->mode &= ~SSL_MODE_RELEASE_BUFFERS_PENDING;
+			s->mode |= SSL_MODE_RELEASE_BUFFERS;
+			}
+		}
 	p=(unsigned char *)s->init_msg;
+//Log ("p=s->init_msg=%p", p);
 
 	alg_k=s->s3->tmp.new_cipher->algorithm_mkey;
-
+//Log ("alg_k = %X", alg_k);
 #ifndef OPENSSL_NO_RSA
 	if (alg_k & SSL_kRSA)
 		{
-		/* FIX THIS UP EAY EAY EAY EAY */
-		if (s->s3->tmp.use_rsa_tmp)
+//Log ("alg_k & SSL_kRSA");
+		if (s->rwstate != SSL_OFFLOADING)
 			{
-			if ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))
-				rsa=s->cert->rsa_tmp;
-			/* Don't do a callback because rsa_tmp should
-			 * be sent already */
-			if (rsa == NULL)
+			/* FIX THIS UP EAY EAY EAY EAY */
+			if (s->s3->tmp.use_rsa_tmp)
 				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_PKEY);
-				goto f_err;
+//Log ("Use temp rsa key");
 
+				if ((s->cert != NULL) && (s->cert->rsa_tmp != NULL))
+					rsa=s->cert->rsa_tmp;
+				/* Don't do a callback because rsa_tmp should
+				 * be sent already */
+				if (rsa == NULL)
+					{
+					al=SSL_AD_HANDSHAKE_FAILURE;
+					SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_TMP_RSA_PKEY);
+					goto f_err;
+					}
 				}
-			}
-		else
-			{
-			pkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
-			if (	(pkey == NULL) ||
-				(pkey->type != EVP_PKEY_RSA) ||
-				(pkey->pkey.rsa == NULL))
+			else
 				{
-				al=SSL_AD_HANDSHAKE_FAILURE;
-				SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_RSA_CERTIFICATE);
-				goto f_err;
+//Log ("Use cert rsa key");
+
+				pkey=s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey;
+				if ((pkey == NULL) ||
+					(pkey->type != EVP_PKEY_RSA) ||
+					(pkey->pkey.rsa == NULL))
+					{
+					al=SSL_AD_HANDSHAKE_FAILURE;
+					SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_MISSING_RSA_CERTIFICATE);
+					goto f_err;
+					}
+				rsa=pkey->pkey.rsa;
 				}
-			rsa=pkey->pkey.rsa;
-			}
 
-		/* TLS and [incidentally] DTLS{0xFEFF} */
-		if (s->version > SSL3_VERSION && s->version != DTLS1_BAD_VER)
-			{
-			n2s(p,i);
-			if (n != i+2)
+			/* TLS and [incidentally] DTLS{0xFEFF} */
+			if (s->version > SSL3_VERSION && s->version != DTLS1_BAD_VER)
 				{
-				if (!(s->options & SSL_OP_TLS_D5_BUG))
+				n2s(p,i);
+//Log ("p=%p, i=%d, n=%d", p, i, n);
+				if (n != i+2)
 					{
-					SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
-					goto err;
+					if (!(s->options & SSL_OP_TLS_D5_BUG))
+						{
+						SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_TLS_RSA_ENCRYPTED_VALUE_LENGTH_IS_WRONG);
+						goto err;
+						}
+					else
+						p-=2;
 					}
 				else
-					p-=2;
+					n=i;
+				}
+//Log ("call RSA_private_decrypt_cavium %p", p);
+			i=RSA_private_decrypt_cavium((int)n, p, p, rsa, s->mode & SSL_MODE_NON_BLOCKING, &s->req_id);
+//LogHex ("RSA_private_decrypt_cavium ret %d %d / %d", &s->s3->rrec, sizeof(s->s3->rrec), s->req_id, i, ERR_GET_REASON(ERR_peek_error()));
+			if (!i && (ERR_GET_REASON(ERR_peek_error()) != RSA_R_OPERATION_IN_PROGRESS))
+				{
+				ERR_clear_error();
+				i=RSA_private_decrypt((int)n, p, p, rsa, RSA_PKCS1_PADDING);
 				}
-			else
-				n=i;
 			}
+		else
+			{
+			if (s->version > SSL3_VERSION && s->version != DTLS1_BAD_VER)
+				p+=2;
 
-		i=RSA_private_decrypt((int)n,p,p,rsa,RSA_PKCS1_PADDING);
+			if (!(al = RSA_check_status_cavium(s->req_id, (unsigned int*)&i)))
+				{
+				i=SSL_MAX_MASTER_KEY_LENGTH; //remove this line
+				s->rwstate=SSL_NOTHING;
+				}
+//LogHex ("RSA_check_status_cavium %p/%d/%d", &s->s3->rrec, sizeof(s->s3->rrec), s, s->req_id, al);
+			}
 
+//LogHex ("ssl3_get_client_key_exchange (%p) ret %d", p, SSL_MAX_MASTER_KEY_LENGTH, s, i);
 		al = -1;
-		
+
 		if (i != SSL_MAX_MASTER_KEY_LENGTH)
 			{
+			if (s->mode & SSL_MODE_NON_BLOCKING && ERR_GET_REASON(ERR_get_error()) == RSA_R_OPERATION_IN_PROGRESS) {
+				s->rwstate=SSL_OFFLOADING;
+				goto err;
+			}
+
 			al=SSL_AD_DECODE_ERROR;
 			/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_RSA_DECRYPT); */
 			}
@@ -2233,6 +2289,7 @@
 			if (!((s->options & SSL_OP_TLS_ROLLBACK_BUG) &&
 				(p[0] == (s->version>>8)) && (p[1] == (s->version & 0xff))))
 				{
+//Log ("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! FAILED!!!!!!!!!!!!!!!!!!!!!!!!!!!");
 				al=SSL_AD_DECODE_ERROR;
 				/* SSLerr(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,SSL_R_BAD_PROTOCOL_VERSION_NUMBER); */
 
@@ -2258,7 +2315,7 @@
 			if (RAND_pseudo_bytes(p+2, i-2) <= 0) /* should be RAND_bytes, but we cannot work around a failure */
 				goto err;
 			}
-	
+
 		s->session->master_key_length=
 			s->method->ssl3_enc->generate_master_secret(s,
 				s->session->master_key,
@@ -2270,6 +2327,7 @@
 #ifndef OPENSSL_NO_DH
 		if (alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd))
 		{
+//Log ("alg_k & (SSL_kEDH|SSL_kDHr|SSL_kDHd)");
 		n2s(p,i);
 		if (n != i+2)
 			{
@@ -2334,6 +2392,7 @@
 #ifndef OPENSSL_NO_KRB5
 	if (alg_k & SSL_kKRB5)
 		{
+//Log ("alg_k & SSL_kKRB5");
 		krb5_error_code		krb5rc;
 		krb5_data		enc_ticket;
 		krb5_data		authenticator;
@@ -2527,6 +2586,7 @@
 #ifndef OPENSSL_NO_ECDH
 		if (alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe))
 		{
+//Log ("alg_k & (SSL_kEECDH|SSL_kECDHr|SSL_kECDHe)");
 		int ret = 1;
 		int field_size = 0;
 		const EC_KEY   *tkey;
@@ -2683,6 +2743,7 @@
 #ifndef OPENSSL_NO_PSK
 		if (alg_k & SSL_kPSK)
 			{
+//Log ("alg_k & SSL_kPSK");
 			unsigned char *t = NULL;
 			unsigned char psk_or_pre_ms[PSK_MAX_PSK_LEN*2+4];
 			unsigned int pre_ms_len = 0, psk_len = 0;
@@ -2778,6 +2839,7 @@
 #ifndef OPENSSL_NO_SRP
 		if (alg_k & SSL_kSRP)
 			{
+//Log ("alg_k & SSL_kSRP");
 			int param_len;
 
 			n2s(p,i);
@@ -2815,6 +2877,7 @@
 #endif	/* OPENSSL_NO_SRP */
 		if (alg_k & SSL_kGOST) 
 			{
+//Log ("alg_k & SSL_kGOST");
 			int ret = 0;
 			EVP_PKEY_CTX *pkey_ctx;
 			EVP_PKEY *client_pub_pkey = NULL, *pk = NULL;
@@ -2927,7 +2990,8 @@
 		-1,
 		516, /* Enough for 4096 bit RSA key with TLS v1.2 */
 		&ok);
-
+//Log ("ssl3_get_cert_verify: ssl_get_message ret %d %d, %p.rrec=%p,%p,%d", n, ok,
+//	s->s3, s->s3->rrec.data, s->s3->rrec.input, s->s3->rrec.length);
 	if (!ok) return((int)n);
 
 	if (s->session->peer != NULL)
